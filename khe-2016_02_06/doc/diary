Diary of the KHE Project
------------------------

16 November 2009

    Have embarked on a new package called KHE, which will combine
    various ideas under one umbrella:

    * It will be a timetabling solver in the same way that KMT
      is a type systems solver, containing several assignment
      algorithms including the new time assignment algorithm
      and the old resource assignment algorithms;

    * It will support all the features of both the KTS and the
      XML formats, so that it can be used as the solve engine
      for data in both formats.

    Ultimately I intend to retrofit KHE into KTS.  Done the
    basic construction and query operations for instances,
    time groups, times, resource types, resource groups,
    resources, event groups, events, event resources, and
    five kinds of constraints so far.

17 November 2009

    Have added construction and query of all kinds of constraints
    to KHE now, except the two new constraints that relate to
    split events, and linked them to the entities they apply to.
    Have defined KHE_SOLN, KHE_SOLN_EVENT, and KHE_SOLN_RESOURCE
    types as the main containers for solutions, and their basic
    operations.  But this is where it starts to get serious.

27 November 2009

    Spent most of the last week updating HSEval to allow for split
    events.  This included updating KTS's XML download function to
    produce the new format.  Done and on the web yesterday.  Have
    been writing a spec for the serious parts of KHE, including
    time and resource domains and layers.  (Full document is now
    about 35 pages, but mostly simple.)  All documented and header
    files brought up to date, so apparently ready to implement.

30 November 2009

    Made some adjustments to the spec, have a skeleton implementation
    of everything compiled, linked, and checked.  Now the clever stuff.

1 December 2009

    Sorted out shifted time domains and implemented them.  Slow to
    build but that does not matter; very fast to access.  Also set
    up khe_soln_layer.c and worked on various solution operations,
    including copying, solution event splitting and merging, and
    assignment.  Going steadily.

13 December 2009

    Took a week off, back at work today.  Decided to allow solution
    resources to lie in multiple solution events, have been sorting
    out the consequences of that today.  All documented and basically
    implemented, although it needs an audit now.

15 December 2009

    Revised time domains and implemented them today.  Previously, the
    time domain was a clumsy intersection of two sets, now it is a
    single time group in the straightforward manner, although the
    initialization is more complex.

    KheEventSetTimeDomains is written but needs a careful audit.

16 December 2009

    Auditing everything.  Up to solutions, and specifically layers,
    and have decided to change layer indexes on the fly so as to
    have no gaps, but not done yet.

17 December 2009

    Still auditing.  Deep into khe_soln_event.c, and have implemented
    the operations to create and delete solution events.  Still quite
    a lot to do there, and for layers and solution resources, but all
    going steadily.

22 December 2009

    Have now reached a point where all functions that were planned to
    exist are implemented and compiling cleanly (though nothing is
    tested yet).  So the basic system, including the solution invariant,
    is implemented.  What needs to be done now is the soft constraint
    propagation (global tixel matching etc.).

23 December 2009

    Added archives and solution groups, which more or less implies
    that KHE will eventually model the decorative features of the XML
    format as well as the features strictly needed for solving.  Sorted
    out malloc() and multiple threads, made the array implementation
    more efficient by using structs rather than pointers to structs,
    and ensured that singleton times have enough lsets.
    
    Code to read and write archives, instances, and solution groups is
    the next logical step.  Can do some testing then.

27 January 2010

    Back from holidays, working on code to support reading and
    writing XML.

30 January 2010

    Have done a lot of the XML work, including retrievals by Id;
    the main thing left now is the tedious job of altering the
    applies_to interfaces of the constraints.  Also solutions.

31 January 2010

    Have done all the applies_to interfaces of the constraints
    except for AvoidSplitAssignmentsConstraint, which will need
    some design work, and the resource constraints, which should
    all be simple and much the same.

4 February 2010

    Lost a couple of days to computer malfunction.  Finished all
    updates to the constraint classes today, and also did some
    unfinished business in copying layers.  Have imported an XML
    module and begun to write the code that writes XML files;
    done times, resources, and events - constraints are next.

6 February 2010

    Finished the code for writing XML today.  Next step is
    reading XML.  Have to cannibalize the HSEval code, I think.

7 February 2010

    Working on code for reading XML.  Have made a new module
    called Kml for both reading and writing XML.  Finished
    that module and am now writing everything via it.  Next
    step is to read everything via it, by reading into a
    KML_ELT, then verifying and converting each bit of it.

9 February 2010

    Completed converting a KML_ELT into an archive.  So it should
    be possible to read an XML file then write it out again now.
    Testing this is next.  Also documented the KML module today.

10 February 2010

    Wrote and documented KmlFree.  Then spent the rest of the
    day sorting out the details of the solution model.  Am
    currently in the middle of implementing a proper many to
    many relation between solution events and solution resources.

11 February 2010

    Finished the many to many relation between solution events and
    solution resources.  Have clean compile.  Reorganized the
    documentation from a Report to a Book, since it's over 50 pages
    and still growing.

14 February 2010

    Got KHE to the point where it will write out the same XML file
    as it reads in.  Tested and working on BGHS98.xml; just a few
    small syntactic differences (not semantic differences).  So
    reading and writing are all done.
    
    Began work on constraint value propagation; have set up a good
    structure based on the kind of applies-to object (KHE_MONITOR
    and its subtypes), coded up the framework of this structure for
    the six constraint types that apply to solution events, and
    implemented one of them: assign time constraints.

16 February 2010

    Wrote code to infer time breaks.  These are points that no
    sub-event may ever span, according to the hard prefer times
    constraints of all the events.  Removed the distinction
    between tight and loose time domains.  Removed the three
    valued KHE_STRENGTH and replaced it with bool required.
    Revised resource domains.  All in order and documented.
    Need to get back to constraint value propagation now.

17 February 2010

    Done various useful things.  Reorganized the monitors,
    inherited assigned times when assigning, made the set
    of solution events derived from a given event into a
    proper abstraction with its own impl file etc.

18 February 2010

    Folded monitors back into constraints, which is much simpler
    although it means that any solution-dependent information
    needed for monitoring must be stored elsewhere.  Actually
    implemented monitoring for assign times constraints, prefer
    times constraints, split events constraints, and distribute
    split events constraints.  Have also changed the evaluation
    functions to use the correct (combined) weight; but at present
    they do not implement the various cost functions, merely Sum.

    NB there are three constraint types that use multiple
    deviation values per point of application:  spread events
    constraints, limit busy times constraints, and avoid
    clashes constraints.

19 February 2010

    Implemented arbitrary cost functions for the four constraints
    done so far.  Trying to do it efficiently in general is a mess,
    so I have optimized the Sum case well and given the rest a
    simple but slowish implementation.

21 February 2010

    Now attaching the four kinds of constraints as part of creating
    a solution.  Actually getting the correct badnesses for the
    two split events constraints, so they seem to be working, at
    least the initial attach is correct.  Have also done the two
    assign times constraints, and both seem to be working, but they
    give 0 on BGHS98.xml so it's hard to be sure.

    AssignResourceConstraint and PreferResourcesConstraint are the
    logical things to do next, at which point 6 of the 15 constraint
    types will be done.  There are 6 resource constraints that work
    off a resource timetable, which will need a data structure with
    constraints attached.  The other three constraint types are
    AvoidSplitAssignmentsConstraint, SpreadEventsConstraint, and
    LinkEventsConstraint; each will need careful individual attention.

22 February 2010

    Done AssignResourceConstraint and PreferResourcesConstraint.
    Current problem is that missing solution events and solution
    resources do not at present attract monitoring constraints,
    and thus their absence is not recorded as a defect.

    In HSEval every instance event is forced to have a solution
    event, and if that solution event does not contain an
    assignment to the role that is expected to be there, that
    is a defect.

23 February 2010

    Invented the concept of "complete representation" and specified
    that KHE's badness report is only correct on solutions which are
    complete representations.  Also ensured that solutions read from
    files are complete representations.  Now getting correct badness
    report for AssignResourceConstraint and PreferResourcesConstraint.

    Made a start on resource monitoring.  Have the external interface
    all done and being called correctly.  The monitor gets told when
    its resource is assigned or unassigned to a solution resource,
    and when any solution event of any solution resource it is
    assigned to is assigned or unassigned a time.  But so far it
    does nothing with this information.

24 February 2010

    Did some serious rethinking, got everything into better shape,
    and implemented AvoidClashesConstraint monitoring.  Made a
    start on AvoidUnavailableTimesConstraint monitoring, but it
    needs a rethink.

    NB when erlinks are created and removed, resources assigned to
    the solution resources below need to know this.  Still to do.

25 February 2010

    AvoidClashesConstraint and AvoidUnavailableTimesConstraint
    tested and seem to be working, at least they doesn't crash,
    and give 0 deviations in the end.  Should test them on an
    actual clash, some time.  Worked out constraint propagation
    in general, but will try to tune the general approach for
    each type of constraint.

28 February 2010

    Optimized AvoidClashesConstraint for the usual special case
    where all the constraints have Sum for their cost function.
    Should probably do workload constraints next, being simple.

3 March 2010

    Started work on limit workload constraints, found design
    issues and have been sorting them out.  Have finished
    eleven constraints now; the four still to do are

      Limit idle times constraints
      Spread events constraints
      Avoid split assignments constraints
      Link events constraints

    One resource constraint and three others.

7 March 2010

    Spent several days sorting out a proposal for changing the
    way resource workloads are calculated.  Will ponder it for a
    bit longer and then run it past Gerhard.  So I guess we are
    back to ten constraints finished, although limit workload
    constraints are done, it's just the assignment of workloads
    to solution events when splitting that is under a cloud.

    Also worked on the limit idle times constraint, producing
    a plan which involves finding the index of each time in
    its subgroup, storing sets of these indexes in lsets, and
    finding the minimum and maximum values of the lsets, as
    the basis of determining how many times are idle.  So I
    added efficient LSetMin(s) and LSetMax(s) operations to
    the LSet module.  These are now tested and ready to use.

8 March 2010

    Finished limit idle times constraints, and thus finished
    resource constraints.  Also homogenized based on a clearer
    idea of who creates nodes in the propagation network and how.
    In principle the network could be dismantled now as well as
    created, but the code for that is not a priority and has only
    been partly written.
    
    Working on avoid split assignments constraints.  Renamed soln
    event sets to event monitors.  They will hold the avoid split
    assignments monitors applicable to solution erlinks of their
    solution events.

9 March 2010

    Finished avoid split assignments constraints, and documented
    them.  There are just two constraint types, spread event
    constraints and link event constraints, still to do; although
    limit workload constraints need to have their spec finalized
    and accepted by Gerhard.  Then copying (I worked out a uniform
    approach to this today), and the basic system will be done and
    ready to support solving.

    Designed the spread events monitor and made a start on it.

10 March 2010

    Completed spread events monitoring today, and started
    thinking about the final frontier: link events constraints.

11 March 2010

    Finished link events constraints today.  Noticed that spread
    events constraints are not initialized properly when they are
    attached to an event monitor; the code assumes that attachment
    occurs only at the start, when there are no sub-events.

12 March 2010

    Audited the constraint types today, looking for prospects for
    optimization.  Here are the results:

      Assign time constraints and prefer times constraints:  these
      should be compiled into an array of total costs, created and
      stored in the instance at instance creation end time.

      Assign resource constraints and prefer resources constraints:
      ditto

      Split events constraints and distribute split events constraints:
      Not much hope of optimizing, but not really worth it anyway,
      since not likely to change in the inner loops of a solver.

      Avoid split assignments constraints:  could be optimized in
      cases where one solution resource spans the whole constraint,
      since in that case no assignments can violate it.  Have to
      look into the details.

      Spread events constraints:  not much hope here; fortunately
      it runs quite fast.

      Link events constraints: link-locking is the big hope here.

      Avoid clashes constraints:  these could be compiled, but it
      is not likely that any resource would have more than one of
      them anyway.  So no point in doing anything here.

      Avoid unavailable times constraints: ditto, although there
      could be soft and hard versions here.  Could compile into
      a cost for each time:  when passing from 0 to 1 or 1 to 0,
      if non-zero we report this cost to the solution.  But not
      likely to gain much in time.

      Limit idle times constraints:  No hope here really.

      Cluster busy times constraints: ditto

      Limit busy times constraints: ditto, and likely to be only
      one at any given time anyway.

      Limit workload constraints: very fast already.

    Executive summary:  Should really compile single-point constraints,
    since there are real speed gains to be made there.  Could actually
    compile the final cost, that is including the cost function and
    weight.  Avoid split assignments constraints look like low-hanging
    fruit too.  But the rest don't seem to offer very much.

13 March 2010

    Rethink: can't combine different constraint types, since each type
    is reported separately.  Probably, then, none of these optimizations
    is worth doing, at least until timing figures show whether they
    really are a bottleneck.  I suspect they aren't.  Enhanced HSEval
    to print constraint densities.  As expected, most instances have
    low densities of all kinds of constraints.

14 March 2010

    Working on copying solutions today.  Reduced the number of passes
    from 3 to 2, established the interfaces, and implemented it for a
    few classes, notably KHE_SOLN.  Here is a complete list of all
    solution classes.  First the solution classes known to the user:

      khe_soln.c
      khe_soln_layer.c
      khe_soln_event.c
      khe_soln_erlink.c
      khe_soln_resource.c

    The rest are all monitors.  First, event monitors and their ilk:

      khe_dev_monitor.c
      khe_event_monitor.c
      khe_avoid_split_assignments_monitor.c
      khe_spread_events_monitor.c
      khe_link_events_monitor.c

    Then resource monitors and theirs:

      khe_resource_monitor.c
      khe_time_group_monitor.c
      khe_limit_idle_times_monitor.c
      khe_cluster_busy_times_monitor.c
      khe_limit_busy_times_monitor.c

16 March 2010

    Copying code written, and tested in the sense that I've run it
    and fixed the few points where it was crashing.
    
    Also tested solution reading and evaluation.  There were several
    problems, the main one being not assigning preassignments; I've
    added and documented functions for doing that now.  All BGHS98
    constraints are giving the correct answers (as compared with
    HSEval).  Should try it on the full archive.

17 March 2010

    Began work on the split and link algorithm today.  Have written
    up a detailed spec of what it has to do, and so far I have
    built up the equivalence classes of those events which share
    a point of application of a link events constraint, either
    directly or indirectly via common event(s).

18 March 2010

    Working on KheSplitAndLink().  Now building two levels of
    equivalence classes, an outer one of linked events as
    above, and an inner one of equal durations as well,
    attaching the relevant constraints to the inner classes,
    working out summaries of them, and building sets of
    partitions that satisfy the conditions in the summaries.
    The summary is parameterised by a minimum constraint
    weight, so if you get no legal partitions you can try
    again with a larger minimum weight, which might knock
    out some constraints and make the thing feasible.

19 March 2010

    Working on KheSplitAndLink().  It now takes preassigned times
    and existing event splits into account when making its list
    of the paritions that you can split each event into.  Maximum
    amount should take spread into account when it covers the whole
    cycle; must do that next.  Have already added some helper
    functions to khe_spread_events_constraint.c.

22 March 2010

    Now have a very good plan for taking account of all kinds of
    influences on splitting and linking, all carefully documented,
    and I'm working on the implementation.  Have set up lots of
    new classes and am slowly filling them in.  Currently problem
    is to revise khe_split_strong.c, most of it attributes need
    to be replaced by a khe_split_state now.

24 March 2010

    Am now building equivalence classes, applying all kinds of
    tasks to them, and thus deducing final domains and options
    for splitting.  The next step is to carry out actual splits
    based on this information.  But before that I also need to
    maintain packability of each layer into the cycle layer.
    Run time so far is 0.00s (not a bug, it is 0.3s when you
    do a big debug print).

26 March 2010

    Written code for packability into cycle layer, and done
    a general tidy up, including fixing some residual design
    problems with class merging.  So the next step is, as
    advertised, to carry out actual splits.

31 March 2010

    Still haven't done the actual splits; I got side-tracked into
    adding layers, since they affect splits.  KheSolnAddLayers()
    written today, not tested.  Lost two days to refereeing papers.

5 April 2010

    More time lost to refereeing papers, but all done now.  Have
    been designing a combination function which does splitting,
    linking, and layering, since it turns out that they are all
    connected.  All documented, started the implementation today;
    it will use everything I've done, but there is a lot of
    refactoring to do.

7 April 2010

    Lost most of yesterday to silly jobs.  Am now deep into the
    implementation of the new KheSplitLinkAndLayer(); have a clean
    compile, with all the data types correctly laid out and the
    right functions declared; but many implementations are still
    to do, and indeed still to design in detail.

9 April 2010

    Now have an initial split forest which is accepting all tasks
    except the event assignment task, plus have to add a new layer
    task.  After that, derive a layer tree from the final forest.

12 April 2010

    Added tasks for building layers, removed other ways of building
    layers, and generally cleaned up layer handling.  All done and
    tested.  Done KheSplitForestTryEventAssign (a trivial consequence
    of the cleanup).  Deriving the final layer tree is still to do;
    everything else is done.

    Wrote and tested KhePartitionBinPackAndHow, which not only does
    the bin pack, it also reports back how it did it.

    NB there are still far too many layers.  This is because there
    is currently one layer per element of each elective; since these
    elements have no preassigned resources they are being given
    their own layers.  Even after final assignment this will still
    be done, so have to think about it and ensure that these very
    redundant layers are not added, somehow.  One layer per
    equivalence class, at the most.

13 April 2010

    Added class leaders today.  These will be useful when assigning
    solution events at the end of KheSplitLinkAndLayer().  Also
    started the final splits and assignments.

14 April 2010

    Am now splitting events.  Had to audit KheSolnEventSplit(), it
    was a bit of a mess.  Also moved soln event's constraints to
    their event monitor.  Next step is to assign split soln events.

16 April 2010

    I've decided not to assign split events here:  that is a separate
    job, to be done by a timetabling algorithm.  Instead, the result
    of KheSplitLinkAndLayer will be a layer tree, and I'll rename the
    function KheSolnBuildLayerTree.  I have documented layer trees
    precisely, including the previous KHE_SOLN_LAYER type, renamed
    KHE_LAYER, plus a new KHE_NODE type for the layer tree `+' node.

18 April 2010

    Finished implementing and documenting layer trees (that is,
    types KHE_NODE and KHE_LAYER), and have clean compile.  The
    next step is to revise the implementation of splitting and
    linking so that its result is a layer tree.

19 April 2010

    Found a few problems maintaining the invariant, and fixed
    those.  Added my workload formula to KheSolnEventSplit.

22 April 2010

    Lost a few days to installing my new quad-core computer.  All
    seems to be going well now, so should be back at work after
    today; but leaving in a couple of days for a bushwalk.

30 April 2010

    Back at work after bushwalk today.  Started work on time
    domains.

7 May 2010

    Lost a lot of time to silly jobs (refereeing papers etc.).
    Have finished time domains today; the next step is to convert
    the "splitting and linking" algorithm into a layer tree
    construction algorithm, including setting time domains.

10 May 2010

    Back from a 2-day break, working on documenting the new
    layer tree builder (prior to implementing it).

12 May 2010

    Completed the documentation and implementation of the new
    layer tree builder today.  Not tested yet, but should work.
    Also uniquefied time domains.  Needs testing now.

13 May 2010

    Tested and debugged the layer tree construction algorithm today.
    Apart from one very nasty uninitialized array, it went well.

14 May 2010

    Documented and implemented the optimization of layer tree
    building that replaces many layers by assignments.

18 May 2010

    Pondering how best to add matchings to KHE.  Have today changed
    MARRAY so that it accepts arrays of elements of arbitrary type.
    This will allow arrays of shorts, useful for domains.  Next
    step is to change time and resource groups so that they store
    these domains.

19 May 2010

    Ground through adding functions for time domains and resource
    domains (represented by ARRAY_SHORT).  Also completed the
    documentation of matching, so that now I have a good user
    interface for it all that can serve as the starting point
    for the implementation.

23 May 2010

    Refined the documentation over the last couple of days, and
    have been implementing the new bipartite matching module,
    which is now done and compiling.  The next step is to use
    it in KHE proper.  In the middle of doing that now.

24 May 2010

    Everything seems to be done in khe_soln_event.c.  When I've
    completed khe_soln_erlink.c and khe_soln_resource.c as well,
    that will be ordinary demand and supply nodes done.  After
    that, workload demand nodes (quite a big job) and matchings
    will be ready to test.

25 May 2010

    Ordinary supply and demand nodes all done, and also made
    some major corrections to splitting and merging solution
    erlinks.  Conversion of workload requirements into workload
    demand chunks and nodes is done.  So all that is left is
    KheResourceMonitorAddAllWorkloadRequirements, then test.

26 May 2010

    KheResourceMonitorAddAllWorkloadRequirements done, and
    am in the middle of testing.  There were *two* problems
    with uniqueifying, first my alorithm was wrong and then
    the comparison function did not work because the diff
    of two long pointers is a long int, which was actually
    overflowing when cast to int.  Must be careful of this.
    Anyway, the correct calls to workload setup are being
    made now.  Next step is to check the tixels.

27 May 2010

    Fixed a few bugs, and matchings seem to be working now.
    Did some tidying up also.  Begun thinking about solving.

28 May 2010

    Still thinking about solving, specifically tiling.  Added
    and documented operations for merging and splitting nodes.
    Nearly removed the node rule.

29 May 2010

    Designed, implemented, tested, and documented sublayerings
    and sublayers today.

1 June 2010

    Inference of resource partitions done and tested.

2 June 2010

    KheNodeMove designed, implemented, and documented.  Can
    also compare sublayers for similarity now (implemented
    and tested), so we're quite close to sublayer clustering.

3 June 2010

    Working on a scheme for keeping sublayers up to date
    automatically.  This will be much more convenient when
    restructuring layer trees.  The changes to khe_sublayer.c
    and khe_node.c are done (except node splitting and merging);
    must also look through khe_layer.c and khe_soln_event.c.

4 June 2010

    Sublayers all done, but not yet tested.  I reimplemented
    them in a beautifully clear way today.

5 June 2010

    And today I rechristened them "segments" and changed the
    semantics to include all nodes whose descendants touch
    the layer.  Need a drastically changed implementation,
    have done the scaffolding work today.

8 June 2010

    Completed the implementation of segments today.  It is
    wonderfully simple, just two key functions that increase
    and decrease the duration of a segment at a node; all
    the other operations call those two.  Tested and seems
    to be working.  Also finally got around to removing
    trivial nodes in KheLayerTreeMake; this reduced the
    number of nodes from 388 to 153 on BGHS98.xml.

    Promoted the concept of similarity in the KHE user's
    guide, and made functions for resource, event, node,
    and segment similarity available to the user.  The
    next step is to cluster similar segments together.

9 June 2010

    Implemented KheCoordinateSegments() today.  Next step
    is a simple assigner, and then we will be ready for
    building runarounds.

10 June 2010

    Set up a time assignment module and built a couple of
    trivial assigners plus scaffolding for my first real
    time assigner, which will be very simple.  Also made
    it easy to include matching cost in total cost.

12 June 2010

    Changed combined cost from int to long, fixed some
    other problems, and got the simple time assignment
    solver running.  Its solution is naturally not very
    good, but it all seems to be working.  Also wrote
    and tested a solver for calculating minimum runaround
    durations.  It's working but seems to have been given
    some peculiar coordinated nodes, must look into that.
    The next step after that is segment merging (need a
    better name).

13 June 2010

    Found and fixed the bug with coordination, only one
    runaround being built now, in Year 9, because the
    tighter rules produce very nice part-form tiling
    in Years 7 and 8.  Also standardized the debug
    functions and documented the changes.

    Current problem is that the matching thinks that
    two Music rooms and teachers are enough for three
    Music classes.

14 June 2010

    KheMinimumRunaroundDuration() is working well now.  Fixed
    the matching problem, now have three runarounds (Music in
    Yr7, 8, and 9) and also wrote a debug function that prints
    only the demands competing for supply at a given node.  Flew
    in the documentation of the runaround building function and
    revised it; actually building runarounds is next.

15 June 2010

    Wrote and tested KheNodeSegmentBuildRunarounds() today.
    It's working very well, so there's a milestone reached.
    Currently working on adding planning timetables to HSEval,
    so that I can see what solutions I'm getting.

16 June 2010

    Spent most of the day getting KTS working on my new
    computer.  There were some problems with generic
    data types (int and void * differ in length now),
    and some problems getting the data files across,
    but all seems to be working now.

    Added "demand" alongside "duration" as a measure of
    the size of an event, solution event, layer, node,
    and segment.  Tried calculating it incrementally but
    came a cropper, so it's offered non-incrementally.

17 June 2010

    Creeping up on real time assignment.  Added solvers for
    assigning one segment, only simple at the moment.  Set
    up a general idea of "prioritizing".  Instantiating
    this to prioritizing segments is next.

    Also generalized segment coordination to coordinate in
    "dominating" cases, where the segments are close enough
    to similar for there to be no loss of generality.  This
    handles the very similar Year 12 segments of BGHS98.

    In the middle of keeping demand up to date incrementally
    in solution events.  We have to visit all the ancestors
    anyway when assigning; this is just one more instruction.

18 June 2010

    Now keeping demand up to date incrementally in solution
    events.  Also wrote two trivial functions for flattening
    trees by moving descendants up, and documented them.

    Thinking about generic priority queues, where a single
    queue will accept objects of arbitrary type, each with
    its own priority function, which is kept up to date
    automatically.  Seems too slow, perhaps manual updating
    would be better, in which case an M package is the go.

20 June 2010

    Decided that I need more coding experience before deciding
    whether and how to include a priority queue class.  So am
    now working on ejection chains.  Have written a wonderful
    general exposition.  The current job is to implement time
    assignment move and swap functions, needed by time assignment
    ejection chain solvers.  Mostly done and documented.

21 June 2010

    Implemented an ejection chain solver for a single segment.
    Compiles but not tested yet.

22 June 2010

    Added "AssignedDuration" operations.  Got the first
    ejection chain solver going - for assigning times to
    the first segment.  It works well on the whole, but
    has some problems with awkward swaps that need to be
    looked into.  e.g. Scripture.  Also it seems slow.

23 June 2010

    Investigating the slow run time of the single segment solver.
    It is 1.44s to begin with, 0.91s with -O, 0.74 with -O3 (let's
    keep that on now).  But the matching seems to be the big thing:

                           Final cost    Run time
      -------------------------------------------
      With matching      1052787.0000       0.74s
      Without matching   1052787.0000       0.20s
      -------------------------------------------

    Nevertheless, the run time is too high.  We need to optimize
    the solver itself.

    Discovered that ejection chain solvers can't be expected to assign
    preassigned solution events, because there is no change in cost.
    So decided to implement a separate solver for assigning preassigned
    solution events.  Identifying them turned out to be awkward; I
    spent some time on function KheSolnEventIsAssignedPreassigned which
    is now finished and does it.  Also finished the preassigned time
    solvers; they need testing now.

24 June 2010

    Added MarkBegin and MarkEnd to the echain solver, run time is
    now 0.54s, no cost change.  Working on optimizing the matching
    by removing demand nodes for preassigned resources, where possible.

25 June 2010

    Still tuning the echain first segment solver.  More use of
    MarkBegin and MarkEnd got it down to 0.29s.  Then removing demand
    nodes for preassigned resources reduced it further, to 0.23s.
    Also tested preassigned times solver, it worked first time.

    If ejection chains are to be more targeted, then we need to
    find out where the problems are.  I've documented functions
    for doing this, and put their skeletons into KHE; their bodies
    need to be implemented next.

26 June 2010

    Implemented all the functions for finding out where problems
    are in the current solution.  Had an interesting idea for a
    general framework for using them, called "targeted transaction
    chains".  Implementing it will be a challenge, but it seems
    very promising.

27 June 2010

    In thinking about how to implement targeted transaction chains,
    I realized I really needed the idea of a "monitor" - one point of
    application of a constraint, together with its current cost - to
    be public.  "Active monitors" are monitors with non-zero cost, and
    these will be available in the solution as part of cost tracking.
    Have documented all this, and just begun to implement it.

28 June 2010

    Have two of the old monitors (link events monitors and spread
    events monitors) moved over to the new form, including code for
    active monitors in the soln.  Need to do that for all the old
    monitors now:
    
      khe_avoid_split_assignments_monitor.c
      khe_cluster_busy_times_monitor.c
      khe_limit_busy_times_monitor.c
      khe_limit_idle_times_monitor.c

    then go on to the new monitors.  Also need EVENT_RESOURCE_IN_SOLN.

29 June 2010

    All the old monitors now moved over to the new format, and all
    resource monitors, which makes nine of the fifteen monitors done
    and documented now.  Still to do are

      Assign time monitors
      Prefer times monitors
      Split events monitors
      Distribute split events monitors

      Assign resource monitors
      Prefer resources monitors

    I guess the event monitors (the first four) are next.

30 June 2010

    All monitors done except assign resource monitors and prefer
    resources monitors.  Should probably get rid of soln erlinks
    before attempting those.  Quite a list of things to do:
    
    * Get rid of soln_erlinks (already changed the documentation)

    * Add KHE_EVENT_RESOURCE_IN_SOLN

    * assign resource monitors and prefer resources monitors,
      and get rid of soln erlink constraints.

    * handle avoid split assignments monitors like the other
      event resource in solution monitors

    * Also thinking of offering the user KheMonitorAttach(m) and
      KheMonitorDetach(m).  Initially all monitors would be attached.
      Detaching would remove the monitor's cost from the total and
      stop monitoring of that thing until the monitor was re-attached.

    * At present the link events monitor relies on KHE_EVENT_IN_SOLN
      to do the heavy lifting; that stuff should move into the monitor.
      Most events will have at most one link events monitor anyway.

    * Polymorphic monitor handling:  KHE_EVENT_IN_SOLN,
      KHE_EVENT_RESOURCE_IN_SOLN, and KHE_RESOURCE_IN_SOLN
      should not need to worry about which kinds of monitors
      they are being passed.


1 July 2010

    Have written khe_event_resource_in_soln.c and got a clean compile
    of it alone.  Have also added KHE_EVENT_RESOURCE_IN_SOLN objects
    to KHE_EVENT_IN_SOLN objects, removed soln erlinks, and written
    khe_assign_resource_monitor.c and khe_prefer_resources_monitor.c
    (so all 15 monitors are written).

2 July 2010

    Begun work on making the monitors polymorphic.  Have to do the
    point above about link events constraints next.  It will be slow,
    but I guess we are relying on adding link locking later.

4 July 2010

    Making steady progress; mostly polymorphic now.  The next step
    is to implement KheMonitorAttach and KheMonitorDetach for each
    type of monitor, then reorganize the code for the initial
    creation and attachment of all monitors.  When that is done,
    most of the rewrite should be in good shape.

5 July 2010

    Made khe_event_resource_in_soln.c polymorphic and gave the avoid
    split assignments monitor the interface it needed for this.  Made
    a plan for how to handle resource and event timetable monitors.
    Make resource_in_soln.c polymorphic.  So just event_in_soln.c to
    go now, plus the aftershocks.

6 July 2010

    Finally got a clean compile, which means that all the functions
    are there; but many of them are "still to do" - there are 87
    occurrences of this phrase at the moment, which means there
    are about 40 functions needing a rewrite.  Plus there is a
    problem with spread events monitors not getting all they need.
    Made some new documentation explaining constraint propagation.

7 July 2010

    Sweeping through the monitors today checking them carefully.
    Have completed these ones:

      KHE_ASSIGN_RESOURCE_MONITOR
      KHE_PREFER_RESOURCES_MONITOR
      KHE_ASSIGN_TIME_MONITOR
      KHE_PREFER_TIMES_MONITOR
      KHE_SPLIT_EVENTS_MONITOR
      KHE_DISTRIBUTE_SPLIT_EVENTS_MONITOR
      KHE_AVOID_CLASHES_MONITOR
      KHE_AVOID_UNAVAILABLE_TIMES_MONITOR
      KHE_LIMIT_WORKLOAD_MONITOR
      KHE_TIME_GROUP_MONITOR

    and these ones are still to do:

      KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR
      KHE_SPREAD_EVENTS_MONITOR
      KHE_LINK_EVENTS_MONITOR
      KHE_LIMIT_IDLE_TIMES_MONITOR
      KHE_CLUSTER_BUSY_TIMES_MONITOR
      KHE_LIMIT_BUSY_TIMES_MONITOR
      KHE_TIMETABLE

    After that, the initial creation and attachment, and the
    various cost functions (remove them and reconsider?),
    then look at "still to do" (currently 82 lines' worth).

8 July 2010

    Today completed all monitors except for spread events monitors.
    Currently 33 lines of "still to do".  These are mainly spread events
    monitoring, audit of khe_event_in_soln.c, khe_event_resource_in_soln.c,
    khe_resource_in_soln.c, khe_soln_event.c and khe_soln_resource, a
    small thing in time group monitors, global costs (which need a
    redesign), and KheSolnDelete.

9 July 2010

    Completed spread events monitors, but had to return to the old
    implementation:  they didn't fit naturally under KHE_TIMETABLE,
    they needed their own version.

    Changed indexing of costs from constraint type to monitor type;
    this was needed anyway, but it also opens the way to making the
    matching another monitor.  Done new cost functions and organized
    the "Solution Monitoring" chapter.  8 lines of "still to do" left:
    
    * Initial creation and attachment of all monitors

    * khe_time_group_monitor.c remove lset when no longer wanted

    * khe_event_in_soln.c final audit and remove dead wood

    * audit khe_monitor.c against documentation
    
    * KheSolnDelete

    * Make the matching a monitor

    * Restructure khe.h so that it follows the documentation
      section by section, with every call declared in place

    * KheSolnEventAssignPreassignedResources

    * Sort out a definitive order of source files, and restructure
      khe_interns.h accordingly.

    * Test

    * Off-site backup and have a rest!

10 July 2010

    Initial creation done; remove lset in time group monitor done;
    audit of khe_event_in_soln.c, khe_event_resource_in_soln.c,
    khe_resource_in_soln.c, and khe_monitor.c done, KheSolnDelete
    done.

11 July 2010

    Restructure of khe.h done.  KheSolnEventAssignPreassignedResources
    is next, then restructure khe_interns.h.  Have reorganized the
    makefile; it is a good guide to how to organize khe_interns.h.

12 July 2010

    Restructure of khe_interns.h done.  Remaining jobs are: make the
    matching a monitor, test, and off-site backup.  This ends the
    change to monitors that began on 27 June, over two weeks ago.

15 July 2010

    Took two days to do odd jobs (prepare conference slides, etc.),
    today I tested the new code and got it working down to the
    call to KheSolnDelete, which is crashing.  There were several
    bugs, the nastiest being creating demand nodes after assignment
    was linking them to the original supply nodes, not the ancestor
    supply nodes.

16 July 2010

    New code all seems to be working now.  KheLayerTreeMake takes
    a long time, 0.28 seconds, not sure why, looking into it.  The
    cost is spread through the tasks, there is no one outstanding.

17 July 2010

    Replaced old and new active monitors with transactions
    and transaction monitors - much clearer.  Worked out
    and documented how ejection chains work with monitors.

18 July 2010

    Invented and documented group monitors.  Have begun the
    implementation and done all the easy bits.  Basically all
    I have to do now is work out what to do when a monitor is
    added to and deleted from a group monitor, and when monitors
    are attached and detached.

21 July 2010

    Going round in circles trying to understand ejection chains
    in general.  Have returned to debugging the current code,
    which currently has a memory free fault in KheSolnDelete.
    Group monitors are still incomplete.  Do we really need them?

22 July 2010

    Fixed the memory fault in KheSolnDelete, it turned out to be
    the messy interface of KheSolnUpdate which was tempting me to
    write bad array index recording code.  All cleaned up now,
    and have begun looking into my ejection chain solver for one
    layer.  It's slow and gives an imperfect result; one swap would
    fix it but it obviously searches the wrong way, and it is too
    depth-first-oriented.

23 July 2010

    Have begun to explore better ways to write an ejection chain
    solver for one layer.  So far have gathered the events of the
    layer and their monitors, now I need to group the monitors.

25 July 2010

    Time lost to visitors.  Finished off group monitors today, and
    am now working on making KheLayerTreeMake detach monitors it
    has made redundant.  All done except, in file khe_layer_tree.c,
    function KheLayerTreeOptionallyDetachLinkEventsMonitor.

26 July 2010

    Successfully detaching split events monitors, distribute split
    events monitors, link events monitors, prefer times monitors,
    and prefer resources monitors.  That's five out of fifteen!
    During time assignment we are left with assign time monitors,
    spread events monitors, and the matching.  To do: make the
    matching a monitor (can we do anything with transactions?)
    and group the remaining monitors together as appropriate.

27 July 2010

    Visitors gone.  Renamed "timetables" as "timetable monitors"
    in preparation for adding a "matching monitor" type which
    will be a wrapper for matching objects, to make them into
    monitors.  Diagnosis will be a problem but it does not
    seem to be a good idea to break a matching into smaller
    monitors, e.g. attach and detach would then be a problem.

29 July 2010

    In the middle of adding matching monitors.  Most of the
    routine stuff is done.  Have to think about the effect
    of using attach and detach to monitor the former empty
    matching type, otherwise all seems straightforward.

30 July 2010

    Working steadily through adding matching monitors.  Have a
    new plan of three functions for updating the soln when the
    matching changes:  AttachMatchingMonitor, DetachMatchingMonitor,
    and ChangeMatchingMonitorType.  Have done these in khe_soln.c,
    am working on khe_soln_event.c, then need to do them in
    khe_soln_resource.c, and then go back and call them from
    khe_matching_monitor.c.

31 July 2010

    Adding matching monitors all written and audited, ready for
    testing.  Also improved uniformity of monitor debug prints.
    One week to the PATAT conference, and the following things
    need to be done:

    * Finish off matching monitors (unmatched demand nodes, test)
    * Either bring ejection chain stuff into a coherent state,
      or else delete it (from the documentation at least)
    * Package up KHE and its documentation and post on web

1 August 2010

    Matching monitor seems to be working, so back to ejection
    chains.  Have built group monitors, one for each node, and
    they seem to be working well.  Transactions seem to be next.

2 August 2010

    Decided that the ejection chain assigner needs to be
    preceded by a bin packer that finds an initial assignment
    of the segment.  Have begun thinking about that.

3 August 2010

    Designed an algorithm for assigning times to the first
    segment, and begun its implementation.  It will end with
    a local search which could be and ejection chain solver
    but need not be.

5 August 2010

    Decided to get serious about back pointers, so I have
    renamed the impl pointers of instances to be back pointers,
    and added back pointers to all soln objects.  Started to
    use them in the first segment algorithm, to record whether
    a solution event's assignment is fixed or not, and what
    other soln events it can be assigned to.

6 August 2010

    Got the heuristic part of the first segment assigner working
    today.  After a bit of fiddling it produced a perfect assignment
    of the first segment, so the repair and adjust parts of the
    algorithm are not going to get much use.  There is a problem
    with the subtree it is given:  some OAS classes were not
    coordinated properly.  Have to sort that out next.

7 August 2010

    Had a careful look at the imperfect segment produced by
    segment coordination; it's a rather complex thing but I
    worked out what was going on.  Decided that it would be
    best to live with it, at least for now, so modified the
    first segment assigner so that in cases where it thinks
    it has no choices it tries all choices.  It worked.

    Also implemented Step 2 of the first segment assigner,
    the step that does parallel preassignments.  It works
    on BGHS98, but that is not much of a challenge.

8 August 2010

    Cleaning up for the first release, which should be today
    or tomorrow.  Got a solution produced by khe_test.c into
    a solution group for writing, wrote it, and ran it
    successfully through HSEval (very high cost, of course).
    Also detected and fixed a very nasty memory problem,
    due to uninitialized variables in KheNodeSimilar.

23 August 2010

    Spend one week at the PATAT conference and a second making
    changes to HSEval.  Now resuming work on KHE.  Have updated
    the code for monitoring spread events constraints and limit
    workload constraints to reflect the changes agreed at PATAT.

25 August 2010

    As a way of clarifying my ideas, I have written the first
    two sections of my proposed paper on ejection chains.  It
    describes them in general and presents and abstract
    implementation that I can now work towards in my coding.

29 August 2010

    My ideas on how to implement ejection chains are gradually
    clearing.  Today I'm reimplementing transactions, doing
    them properly.  Have just worked out and documented how
    undo and redo interact with creation and deletion, but
    haven't implemented those ideas yet.
    
    Another thing I need is for demand nodes to be monitors.

30 August 2010

    Finished the implementation of transactions.  Have a
    clean compile but not tested yet.

1 September 2010

    Separated the monitors aspect of transactions into a separate
    feature.  Transactions now keep track of a sequence of
    operations and nothing more; tracing keeps track of which
    monitors have changed their cost recently.  Redone all monitors
    (again) to reflect this; have clean compile, not tested.

3 September 2010

    The new version of transactions and tracing is now compiled
    and tested.

4 September 2010

    Started in on the job of making each demand node of the
    matching into a monitor.  I've rewritten the chapter on
    matchings to describe the new arrangement; now I have to
    implement it.

5 September 2010

    Have got a clean compile, but there is still a lot to do.
    However, khe_soln.c seems to be virtually done, at least.

6 September 2010

    Wrote code for copying matching objects.  Sorted out
    copying and deletion of solutions.  Have also revised
    and audited khe_resource_in_soln.c, which includes all
    the stuff for workload demand monitors.  Soln events
    are done too, although they need a functional audit.

8 September 2010

    Now have a clean compile of all the matchings changes;
    only took 4 days.  Also wrote demand monitor grouping and
    ungrouping helper functions today.  Testing still to do.

9 September 2010

    Basic testing done.  I need to return now to the main line,
    developing an ejection chain algorithm for time assignment.
    The next step seems to be to find an efficient way to
    generate Kempe time moves.  These will be swaps (at least)
    with events of the same duration and similar preassigned
    resources, and moves to spare times where available.

12 September 2010

    Tooling up for Kempe time moves.  Added finding competitors
    of demand monitors today.  These will be useful for finding
    clashing solution events.  Also redid tracing to be simpler
    and allow nested traces, and redid transactions in the same
    style as tracing.

13 September 2010

    Wrote the most concrete description of ejection chains yet,
    possibly concrete enough to base an implementation on.  It
    says that Kempe time moves should be based on the matching
    with the demand monitors grouped by solution event.

14 September 2010

    Worked over the description of ejection chains that I wrote
    yesterday.  Also added operations for maintaining the set
    of child monitors of non-zero cost.  I had these before but
    they got lost somewhere along the way, and they are needed
    for ejection chains.

15 September 2010

    More work on the description of ejection chains, which seems
    to have reached an implementable state now.  Previously, I
    wrote several functions for grouping demand monitors.  Today,
    I finished all the grouping functions that ejection chains
    need.  Kempe time moves are next.

17 September 2010

    Wasted yesterday on silly jobs and a headache.  Today I
    actually began coding Kempe time moves, at last, and even
    finished it, although Heaven knows whether it will work.

18 September 2010

    Wrote an ejection chains framework today to handle stuff
    common to all ejection chains.  All you have to write
    yourself now are the individual non-polymorphic augment
    functions.  The main loop, the polymorphic dispatch,
    depth limiting, and success checking are done for you.

    Made a start on an augment function for time value
    defects.  It will assign times when they are missing,
    and move them when they are defective.

    Probably need to assume that layer trees are in use,
    otherwise the code gets messy.

19 September 2010

    Cleaned up Kempe time move code and removed its yukky
    sub_tag parameter.  Much easier to use without it.
    Also continued work on KheEjectTimeValueAugment; it
    now handles assign time defects by trying simple
    assignments, and prefer times defects by trying
    Kempe time moves.  Event spread defects currently
    under way.

20 September 2010

    Finished event spread defects augment code, so that
    finishes time value augmenting.  Next up I should
    do resource demand augmenting, since those two
    will be enough to assign the first segment.

    Added visit numbers to solutions, solution events,
    solution resources, and nodes.  Have started to use
    them in the ejection chains framework, but there are
    some problems deciding just when to test and when to
    mark things visited.  Have to look into this more.

21 September 2010

    Redone spread defects augment code to use visit
    numbers.  All in good shape, including the assign
    time and prefer time defects augment code, which
    I have just audited.

    Started work on resource value augments, and got side
    tracked into revising the basic operations to make
    them compatible with the time ones first.  That's done
    now so time to return to resource value augments.

22 September 2010

    Written augment functions for assign resource monitors
    and prefer resource monitors, but not for avoid split
    assignments monitors, and not for resource timetable
    or resource demand monitors.  I will worry about all
    of those later.  At present, the main point is that
    I have enough to go on to repair the assignment of
    the first segment.  I really should do that next.

    Got a clean run of the old stuff to begin with.

    Started work on removing KHE_LAYER and KHE_SEGMENT.
    All gone from the core platform, now working on
    removing it from KheLayerTreeMake.  Replace layers
    by preassigned resources throughout is the plan.

23 September 2010

    Continuing to work on removing KHE_LAYER and KHE_SEGMENT.
    Have removed them from the layer tree construction
    algorithm, although the documentation needs an update
    and there is the question of what to do with the excess
    solution events of over-wide layers (we can't just make
    more layers now).

    After sorting that out, the main remaining jobs are
    segment coordination and runaround building, replacing
    layers by preassigned resources.

25 September 2010

    Wasted yesterday (not good).  Today I finished documenting
    the changes to KheLayerTreeMake (removing all trace of
    KHE_LAYER), and at the same time did an audit to confirm
    that it does what the documentation now says it does,
    although the changes have not been tested yet.  On to
    segment coordination and runaround building now.

    Finished revising segment coordination (now called node
    layer coordination), code and documentation.  Not too bad.
    It looks a bit slow, but it's probably fast enough.

    Plan for runarounds:  build node layers in increasing
    resource index num order, add each node to an array
    indexed by that order, somehow check not already added.

26 September 2010

    Runaround code done and documented.  Came out quite well.
    Only odds and ends to do now:  echain, firstseg, test.
    Just a matter of withdrawing functions that work on segments.

    Have decided to (re-)institute the KHE_SOLN_LAYER and
    KHE_SOLN_LAYERING types.  Building a non-redundant layering
    and sorting it would be useful.

27 September 2010

    Have made the KHE_SOLN_LAYER and KHE_SOLN_LAYERING types,
    and implemented everything except building layerings.
    Must complete that and then bring all the other code
    into line with this new arrangement.

28 September 2010

    Finally finished removing KHE_LAYER and replacing everything
    of that kind with KHE_SOLN_LAYER and KHE_SOLN_LAYERING.  Not
    tested yet but all documented with a clean compile.  Took
    almost a week.  Things to do now:

    * Finish off the ejection chain algorithm for repairing the
      first soln layer, and test it.

30 September 2010

    Took yesterday off.  Testing today, looking in detail at
    what the program is actually doing, fixing odd bugs etc.
    Getting a first layer assignment that has some problems,
    owing to Node 115 which belongs under Node 139 but isn't
    being put there.  It screws up the layer assignment.  I
    need to sort out this problem next.

1 October 2010

    Fixed the Node 115 problem.  It is only a problem when
    the duration of a soln layer exceeds the duration of
    its parent node, so now, after layer coordination, I
    check each soln layer and try to reduce the duration
    of oversized ones, by finding plausible node merges.

    The first soln layer now has a sensible time assignment,
    with exactly one spread defect (11-6 twice on Wed).  Just
    what we need for testing an ejection chain repairer with.

    I've written a description of such a repairer.  It seems
    that it will be fairly easy to build out of what I have.

2 October 2010

    Fiddling around getting the monitors grouped and making
    their debug prints look good.  Everything seems to be
    working.  I have got it right down to the group monitor I
    need for repairing the first layer.  As expected, it has
    exactly one defect, the spread defect mentioned above.
    So ready for chaining.

3 October 2010

    Debugging chaining.  It's close to working, but at present
    is not finding any way to fix the defective spread, although
    it is targeting it correctly and tailoring its moves correctly.
    I've done a long audit of the Kempe time moves.  There is a
    delightful case of trying to move the event to Mon1 and
    failing because there is too much other stuff on then.

    Current problem though is that it's cycling back and forth
    down to the depth limit - probably correctly - but not
    finding anything in the end.  Need to audit this carefully,
    but first I need to rationalize my debug prints, so I can
    see clearly what is going on.

5 October 2010

    Took yesterday off.  Today I fiddled with the debug output,
    to get a clear view of what the ejection chain algorithm was
    doing.  Also implemented KheTimetableMonitorPrintTimetable,
    getting pretty timetable debugs for the first time.  Useful
    in pondering what the ejection chain is doing, or could do.
    
    And lo and behold I got it working.  I even added iterative
    deepening and documented it.  Still to do:

    * Group demand monitors better, so that Kempe time moves
      don't have to search so much for them.

6 October 2010

    Changed KheSolnEventKempeMove so that it monitors the
    parent of one of se's preassigned solution resources,
    which will be more efficient.  All documented, tested,
    and working.  What's next?  General time assignment!

7 October 2010

    Have begun work on general time assignment; written some
    documentation, including specifications of functions
    KheAssignTimesByLayer and KheSolnLayerSaturationDegreeCmp,
    which now need to be implemented.

8 October 2010

    Done KheAssignTimesByLayer and KheSolnLayerSaturationDegreeCmp
    but not the key function called by KheAssignTimesByLayer to
    assign one layer.  Still thinking about that one.

10 October 2010

    Have been thinking about assigning layers other than the first,
    and as a step in that direction have defined and implemented
    functions for testing nodes and solution layers for regularity,
    and for assigning the solution events of one node using the
    assignments of another as a template.  Also wrote up an
    algorithm for assigning a non-first layer, which I plan to
    implement.

11 October 2010

    Started work on other layers, spent most of the time
    importing the KTS weighted matching module into KHE.
    There was a lot to do but it seems to be in good shape
    now for use in KHE, except that I need to do a careful
    audit, especially of memory allocation and deallocation.

12 October 2010

    Finished bringing wmatch into shape.  Written code to use it
    to find template assignments, which is tested and working.
    
    There is one weird thing.  WMatch requires edge costs to be
    non-negative, and I've verified that this is necessary; it has
    to do with adjusting edge costs so that Dijkstra's algorithm
    can be used - it requires non-negative edge costs.  Since the
    costs are usually negative in this application (we are removing
    assign time defects) I've added (LONG_MAX >> 2) to each cost.

    The next step is to adapt the previous assignment algorithm
    to assign times to the nodes of sl that were not assigned by
    the wmatch part.

18 October 2010

    I'm resuming work today after having been away for the last
    five days.  Have got an assignment algorithm for the other
    layers going, and a local search to repair the timetable
    afterwards - but at present the resource demand repair
    algorithm is a stub, so that is the next thing to do.

    Done the resource demand repair algorithm.  Here are
    the results for various schedules, best first.
    
      KheEjectControllerAddSchedule(ec, 0, true);
      KheEjectControllerAddSchedule(ec, 1, true);
      KheEjectControllerAddSchedule(ec, 2, true);
      KheEjectControllerAddSchedule(ec, INT_MAX, false);
      ------------------------------------------------
      AssignResourceMonitor                  2692.0000
      SpreadEventsMonitor                       0.0024
      AvoidClashesMonitor                       3.0000
      OrdinaryDemandMonitor                    11.0000
      ------------------------------------------------
      Total                                  2706.0024
      Run time 10.96 secs

      KheEjectControllerAddSchedule(ec, 0, true);
      KheEjectControllerAddSchedule(ec, 1, true);
      KheEjectControllerAddSchedule(ec, INT_MAX, false);
      -----------------------------------------------
      AssignResourceMonitor                  2692.0000
      SpreadEventsMonitor                       0.0003
      OrdinaryDemandMonitor                    15.0000
      ------------------------------------------------
      Total                                  2707.0003
      Run time 19.79 secs

      KheEjectControllerAddSchedule(ec, INT_MAX, false);
      ------------------------------------------------
      AssignResourceMonitor                  2692.0000
      SpreadEventsMonitor                       0.0002
      AvoidClashesMonitor                       3.0000
      OrdinaryDemandMonitor                    13.0000
      ------------------------------------------------
      Total                                  2708.0002
      Run time 14.75 secs

      KheEjectControllerAddSchedule(ec, 0, true);
      KheEjectControllerAddSchedule(ec, 2, true);
      KheEjectControllerAddSchedule(ec, INT_MAX, false);
      ------------------------------------------------
      AssignResourceMonitor                  2692.0000
      SpreadEventsMonitor                       0.0002
      AvoidClashesMonitor                       2.0000
      OrdinaryDemandMonitor                    16.0000
      ------------------------------------------------
      Total                                  2710.0002
      Run time 23.35 secs

      KheEjectControllerAddSchedule(ec, 0, true);
      KheEjectControllerAddSchedule(ec, INT_MAX, false);
      ------------------------------------------------
      AssignResourceMonitor                  2692.0000
      SpreadEventsMonitor                       0.0007
      AvoidClashesMonitor                       2.0000
      OrdinaryDemandMonitor                    17.0000
      ------------------------------------------------
      Total                                  2711.0007
      Run time 6.18 secs

    By previous standards these are not great solutions.
    From memory I was routinely getting 6 to 8 unmatched
    demand nodes on BGHS98.  The best one is within
    striking distance, although its spread is bad.  Here
    are its 11 unmatched demand nodes:

      "MathematicsFacultyMeeting_1".0+0:{Maths01}
      "x7CKO1_3_1".1+1:Rooms_ComputerRoom
      "x7A_Music_1":1.0+0:{x07A}
      "x7S_Music_1":1.0+0:{x07S}
      "x10_Science5_1":2.1+0:Rooms_ScienceLab
      "x10_Science5_1":2.1+1:Rooms_ScienceLab
      "x10_6_ComputingStudies_1_1":1.1+1:Rooms_ComputerRoom
      "x11_2_GeneralScience_1":3.1+0:Rooms_ScienceLab
      "x12_3_Arabic_1":0.0+0:Teachers_ArabicYr11_12
      "x12_3_Physics_1":3.1+0:Rooms_ScienceLab
      "x11_5_Drama_1":1.0+0:{Welfare04}

    These are the usual suspects plus a few ring-ins.

    Two good ideas: (1) Flatten!!! (2) Sort competitor
    soln events (when Kempeing) by increasing demand.

19 October 2011

    After sorting competitor soln events, the full
    schedule (0/1/2/inf) produced

      ------------------------------------------------
      AssignResourceMonitor                  2692.0000
      SpreadEventsMonitor                       0.0012
      AvoidClashesMonitor                       2.0000
      OrdinaryDemandMonitor                    11.0000
      ------------------------------------------------
      Total                                  2705.0012
      Run time 31.54 secs

    This is the best cost so far, although it is slow
    and its spread is mediocre.  Trying nearby soln events
    first is even slower, and the result is worse:

      ------------------------------------------------
      AssignResourceMonitor                  2692.0000
      SpreadEventsMonitor                       0.0019
      OrdinaryDemandMonitor                    15.0000
      ------------------------------------------------
      Total                                  2707.0019
      Run time 61.01 secs

    Presumably these are random effects, but the range
    of running times is rather disturbing.  And after
    flattening the results are faster but worse!:

      ------------------------------------------------
      AssignResourceMonitor                  2692.0000
      SpreadEventsMonitor                       0.0014
      AvoidClashesMonitor                       5.0000
      OrdinaryDemandMonitor                    18.0000
      ------------------------------------------------
      Total                                  2715.0014
      Run time 23.50 secs

    Something must be wrong, surely?

    Kempe moves not repeatable, because different competitors turn
    up.  Why is this?  Surely something is wrong.  Anyway, after
    sorting the Kempe moves and doing the best cost first, I get
    this on the full schedule:

      ------------------------------------------------
      AssignResourceMonitor                  2692.0000
      SpreadEventsMonitor                       0.0059
      OrdinaryDemandMonitor                    14.0000
      ------------------------------------------------
      Total                                  2706.0059
      KheTestSolve at end (25.64 secs so far)

    This isn't bad, although it's a bit slow, and the
    spread is terrible.

    Worked out what the problem was with Kempe moves:
    competitors are nondeterministic.  Can't really do
    anything about it, but still I should consider my
    options.  Perhaps Kempe moves should use only the
    first competitor.  It will still be failure-prone.

    There was also a problem with the way that soft
    costs were being printed.  The soft costs above
    are not trustworthy, except the last one.

20 October 2010

    Tried the full schedule, prohibiting increases in
    time value monitors, and got this:

      ------------------------------------------------
      AssignResourceMonitor                  2692.0000
      SpreadEventsMonitor                       0.0007
      AvoidClashesMonitor                       1.0000
      OrdinaryDemandMonitor                    22.0000
      ------------------------------------------------
      Total                                  2715.0007
      KheTestSolve at end (8.95 secs so far)

    Without the prohibition I get this:

      ------------------------------------------------
      AssignResourceMonitor                  2692.0000
      SpreadEventsMonitor                       0.0036
      AvoidClashesMonitor                       1.0000
      OrdinaryDemandMonitor                    11.0000
      ------------------------------------------------
      Total                                  2704.0036
      KheTestSolve at end (44.13 secs so far)

  The prohibition makes it run faster and naturally it
  improves spread, but the number of resource demand
  defects doubles, which is not good.

  But then, before flattening and running the ejection
  chain algorithm there are 181 resource demand defects,
  which is an awful lot for the algorithm to eliminate.
  Perhaps we need a better starting point rather than
  a better ejection chain algorithm.

  Begun work on adding meta-matching to solution layers;
  I've completed the initial design and documentation.
  There is a problem with making the interface easy to
  use when trying for node regularity.  Also, I need to
  look at the KTS algorithm for this to see if I have
  forgotten any wrinkles.

21 October 2010

  Begun the implementation of solution layer matchings
  today.  The KTS algorithm allows dynamic changes to
  block sizes, which we are not attempting here, but
  otherwise has nothing more than I'm preparing to do.
  I am also trying for solution event regularity here,
  which the KTS algorithm does not do.

  Got the easy parts of the implementation of solution
  layer matchings done.  Basically I just have to build
  the initial matching now.

22 October 2010

  Reorganized the documentation of solution layers,
  hopefully in a way that will stick.  Audited all the
  code so far for solution layer matches.  All done
  except for KheSolnLayerMatchAddDemandNodeToWMatch,
  which adds one demand node to the matching.

24 October 2010

  Implementation of KheSolnLayerMatchAddDemandNodeToWMatch
  finished today (I've been working only part-time, which
  is not good), so that finishes the implemetation of
  solution layer matchings begun four days ago, although
  it is not tested yet.

  Testing revealed a silly problem with edges getting out
  of date.  The edge function is supposed to prevent this.
  I think I will calculate edges on the fly after all.

27 October 2010

  It's been a nightmare (a whole week!) but now I have a
  compiled and documented soln layer match module ready
  for testing.

28 October 2010

  Used the new soln layer match module in a revised
  other soln layer assignment algorithm, which finds
  node-regular assignments when it can and soln event
  regular assignments otherwise.  It produced this
  fabulous (for demand, not spread) final result:

  [ Soln (instance "BGHS98", cost 2695.0)
    Solution Cost (2893 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                  2692.0000
    SpreadEventsMonitor                       0.0050
    OrdinaryDemandMonitor                     3.0000
    ------------------------------------------------
    Total                                  2695.0050
  ]
  KheTestSolve at end (18.23 secs so far)

  This was the state before ejection chains began:

  [ Soln (instance "BGHS98", cost 2720.0)
    Solution Cost (2457 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                  2692.0000
    SpreadEventsMonitor                       0.0133
    AvoidClashesMonitor                       1.0000
    OrdinaryDemandMonitor                    27.0000
    ------------------------------------------------
    Total                                  2720.0133
  ]

  No matter how good your adjuster is, it pays off to
  construct a good solution to begin with.  Perhaps
  further improvement to the constructor is in order:
  how often does it skip nodes and go for soln events,
  can we minimize the full solution cost (i.e. spread)
  in those cases as well?  There seems to be very
  little node-regular assignment in the junior forms.

  But it might be a good idea to rampage on now to
  resource assignment.  We can see how good it is,
  and that will tell us how much we need regularity.

29 October 2010

  Made a start on resource assignment today.  Wrote
  the start of the resource asst chapter, then
  defined, documented, and implemented soln tasks.

30 October 2010

  Defined, documented and implemented soln taskings
  (sets of tasks).  Also written a small function to
  sort resource types.  So ready for some real resource
  assignment now.

1 November 2010

  Did some renaming:  soln layers are now layers, and
  soln tasks are tasks.  Much briefer.  Also defined,
  documented, and implemented task sets (sets of
  interchangeable tasks).

2 November 2010

  Implemented KheTightenResourceDomains, quite easy.
  Added a priority queue module to KHE, flown in from
  KTS, and documented it.  Implemented the heuristic
  assignment solver, KheSimpleAssignResources.  When
  run on all resource groups, it took 0.5 secs and
  produced this:

  [ Soln (instance "BGHS98", cost 264.0)
    Solution Cost (2893 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   259.0000
    SpreadEventsMonitor                       0.0050
    AvoidClashesMonitor                       2.0000
    LimitBusyTimesMonitor                     0.0012
    OrdinaryDemandMonitor                     3.0000
    ------------------------------------------------
    Total                                   264.0062
  ]

3 November 2010

  Confirmed that HSEval's evaluation and the one above
  coincide.  All rooms were assigned except one Physics
  lab at one time.  There were also two problems with
  rooms r20 (cooking) and r32 (computing), so it seems
  we can get clashes with the current algorithm even
  without preassignments.  It just aims to minimize
  soln cost, it does not specifically avoid clashes.

  Placed MarkBegin and MarkEnd in the strategic spot
  in KheSimpleAssignResources but it made no difference
  to running time.

4 November 2010

  Revised documentation to move layers and tasks into
  the core.  Most of the implementation is done; have
  a clean compile except for many missing functions.

6 November 2010

  Revisions begun on 4 Nov now completed, documented,
  and tested.  We're back where we were, ready to try
  ejection chains for resource assignment, but now
  with tasks in the core platform where they can be
  got at safely by repair functions.

  Extracted and documented the ejection chain algorithm
  for repairing time assignments in all layers.

  Revised the ejection chains framework, simplifying
  and strengthening the interface.

7 November 2010

  Made task groups assign tasks in best-first order.
  Forbade soln resource operations when the soln
  resource lies in a task.  Added task operations
  to transactions.  Added limit_demand option to
  ejector schedules.

  Did a few experiments to see whether the "very visited"
  feature of the first layer assignment was helpful in
  conjunction with the "revisit" feature of the all
  layers ejection chain algorithm.

  Without "very visited" and with "revisit", got

    KheTestSolve after assigning resources (31.26 secs so far):
    Soln (instance "BGHS98", cost 247.0)
    Solution Cost (2893 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   241.0000
    SpreadEventsMonitor                       0.0054
    AvoidClashesMonitor                       2.0000
    LimitBusyTimesMonitor                     0.0016
    OrdinaryDemandMonitor                     4.0000
    ------------------------------------------------
    Total                                   247.0070

  With "very visited" and "revisit", got this:

    KheTestSolve after assigning resources (18.60 secs so far):
    Soln (instance "BGHS98", cost 264.0)
    Solution Cost (2893 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   259.0000
    SpreadEventsMonitor                       0.0050
    AvoidClashesMonitor                       2.0000
    LimitBusyTimesMonitor                     0.0012
    OrdinaryDemandMonitor                     3.0000
    ------------------------------------------------
    Total                                   264.0062

  With "very visited" and without "revisit", got this:

    KheTestSolve after assigning resources (11.55 secs so far):
    Soln (instance "BGHS98", cost 273.0)
    Solution Cost (2893 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   266.0000
    SpreadEventsMonitor                       0.0062
    AvoidClashesMonitor                       2.0000
    LimitBusyTimesMonitor                     0.0014
    OrdinaryDemandMonitor                     5.0000
    ------------------------------------------------
    Total                                   273.0076

  Without "very visited" and without "revisit", got this:

    KheTestSolve after assigning resources (10.21 secs so far):
    Soln (instance "BGHS98", cost 243.0)
    Solution Cost (2893 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   239.0000
    SpreadEventsMonitor                       0.0051
    AvoidClashesMonitor                       1.0000
    LimitBusyTimesMonitor                     0.0010
    OrdinaryDemandMonitor                     3.0000
    ------------------------------------------------
    Total                                   243.0061


  Summary        With Very Visited      Without Very Visited
  ----------------------------------------------------------
  Revisit     264.0062 (18.60 sec)      247.0070 (31.26 sec)
  No Revisit  273.0076 (11.55 sec)      243.0061 (10.21 sec)
  ----------------------------------------------------------

  So tests from now on will run without "very visited" and
  also without revisiting during the all layers ejection
  chain.  It's good to get rid of "very visited", it was
  always going to interact poorly with later phases.  And
  revisiting probably works badly during time assignment
  because most of the revisiting comes from redoing soln
  events that have already been tried, owing to electives.
  The great news is that this algorithm is running more or
  less fast enough, and the quality is pretty good too.

  I even tried adjusting the first layer without revisiting;
  it gave exactly the same answer as revisiting, in the same
  time, so (given the importance of getting the first layer
  right) I have left revisiting in for now.

  The next step is an ejection chain solver for improving
  resource assignments.  Should be easy to put together now.

8 November 2010

  Implemented a resource value repair function today.
  But there is a problem:  it only assigns, it
  doesn't deassign!  Need a careful rethink.

9 November 2010

  Overcame the problem with the resource value repair function
  by replacing KheSolnResourceAssign and KheTaskAssign with
  KheSolnResourceKempeAssign and KheTaskKempeAssign, which do
  the assignment then deassign clashing soln resources and tasks.
  I've audited it and it seems to be working.  It produced this:

    KheTestSolve after assigning resources (22.07 secs so far):
    Soln (instance "BGHS98", cost 206.0065)
    Solution Cost (2229 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   200.0000
    SpreadEventsMonitor                       0.0051
    AvoidClashesMonitor                       2.0000
    LimitBusyTimesMonitor                     0.0014
    OrdinaryDemandMonitor                     4.0000
    ------------------------------------------------
    Total                                   206.0065

  HSEval reports the same numbers, thankfully.  This is a
  16% improvement on the 239 assign resource defects above;
  not striking perhaps, but worthwhile.  For comparison,
  here is the KTS solution as evaluated by HSEval:

  Summary 					Inf. 	Obj.
  ----------------------------------------------------------
  Assign Resource Constraint (13 points) 	23 	  
  Split Events Constraint (6 points)	 	 7 	  
  Distribute Split Events Constraint (11 pts) 	16 	  
  Avoid Split Assignments Constraint (24 pts) 	   	250
  Spread Events Constraint (17 points) 		   	 17
  Avoid Clashes Constraint (1 points) 		 1 	  
  Limit Busy Times Constraint (24 points) 	   	 66
      Grand total (96 points) 			47 	333
  ----------------------------------------------------------

  There seems to be a long way to go.

  The next step would seem to be to add a repair function
  for timetable defects.  There may be (definitely will be)
  workload limit problems which are terminating the ejection
  chains for want of an augment function.

  I may also need to implement resource packing, but I would
  rather keep away from it for the time being.

  There is a lot of code duplication now, doing basically
  the same thing but to soln resources or to tasks.  It
  would be better to find a way to merge these types.

10 November 2010

  Hard at work merging types KHE_SOLN_RESOURCE and KHE_TASK.
  Have a clean compile, so getting close.  Things to do:

    * khe_task.c is in good shape except for interchangeability,
      where there are some "still to do" bits.

    * Need to check khe_assign_resource.c, khe_eject.c, khe_kempe.c
      at least.

    * Documentation needs a complete overhaul wrt tasks.

11 November 2010

  Working through khe_task_groups.c, have redone tasking
  construction and task groups construction.  All seems
  done, but not tested; I'm redoing the documentation now.

12 November 2010

  Documentation and some code tidying all done, ready for
  testing.  Then convert SOLN_EVENT to meet (?).

13 November 2010

  Audited the solver code that uses tasks.  Found a bug
  in KheSolnEventKempeAssign (not searching children for
  preassigned tasks) which would have had the effect of
  causing some Kempe time moves to fail when they could
  have succeeded.

  Updated KHE to implement the revised definition of
  workload (per event resource rather than per event).

  First non-crashing run gave this result:

    KheTestSolve after assigning resources (20.34 secs so far):
    Soln (instance "BGHS98", cost 214.0067)
    Solution Cost (2252 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   208.0000
    SpreadEventsMonitor                       0.0051
    AvoidClashesMonitor                       2.0000
    LimitBusyTimesMonitor                     0.0016
    OrdinaryDemandMonitor                     4.0000
    ------------------------------------------------
    Total                                   214.0067

  It's slightly worse than previously (206.0065), but
  that is just random noise.  Same run time, basically.

  Have completed the rename of soln events to meets
  in the code, have to do it in the documentation now.
  Then I should really make another off-site backup.
  Next job is to rename solution events to be meets.
  Am well advanced with this, have done all the big
  classes.

14 November 2010

  Revising the documentation to use the new terminology.  Also
  checking that it agrees with khe.h in detail.  Just finished
  the time solvers chapter; the resource solvers chapter is next.

15 November 2010

  Completed the revision of the documentation.  Made a few
  minor adjustments to the interface and documented them.

  Tried setting limit_demand to true when running the all layers
  time asst ejection chain.  It made no difference at all.

  Without debug printing, run time is 19.22 secs.  Tried compiling
  with -O3 (why do I always forget to do this?) and got the same
  answer in 8.08 seconds.  So I'll be using -O3 from now on.

  The next step is to handle limit times monitors and workload
  limit monitors in ejection chains.  But before that I really
  need to sort out the grouping as between timetable constraints
  and demand constraints.

16 November 2010

  Documented the new way of attaching and detaching monitors,
  and done the implementation.  Struggled with a shocking
  error that turned out to be an unexpected re-entry into
  khe_matching.c.  Wrote code to detect it, so it won't
  bamboozle me again.

  Got a complete run, but the solution has changed for the
  worse for no apparent reason:

    Soln (instance "BGHS98", cost 238.0033)
    Solution Cost (1450 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   224.0000
    SpreadEventsMonitor                       0.0017
    AvoidClashesMonitor                       4.0000
    AvoidUnavailableTimesMonitor              3.0000
    LimitBusyTimesMonitor                     0.0016
    OrdinaryDemandMonitor                     7.0000
    ------------------------------------------------
    Total                                   238.0033

  This should not have happened, it needs looking into.
  The AvoidUnavailableTimesMonitor problems are the usual
  suspects (Art03 and Languages04).  The low spread badness
  is suspicious; did Kempe time moves break, perhaps?

18 November 2010

  Had yesterday off.  Soon sorted out the mysterious change
  in soln:  matching nodes were not being added as children
  of soln when created.  Now they are, I'm getting this:

    KheTestSolve after assigning resources (9.09 secs so far):
    Soln (instance "BGHS98", cost 214.0067)
    Solution Cost (1450 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   208.0000
    SpreadEventsMonitor                       0.0051
    AvoidClashesMonitor                       2.0000
    LimitBusyTimesMonitor                     0.0016
    OrdinaryDemandMonitor                     4.0000
    ------------------------------------------------
    Total                                   214.0067

  which is exactly what I was getting before, except
  that -O3 makes it run much faster.

  Redid ejection chains so that they would limit the
  cost of any group monitor, instead of specifically
  the number of demand defects.  Also found a bug
  in KheMonitorCost, which when fixed led to this:

    KheTestSolve after assigning resources (4.05 secs so far):
    Soln (instance "BGHS98", cost 201.0052)
    Solution Cost (2091 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   195.0000
    SpreadEventsMonitor                       0.0036
    AvoidUnavailableTimesMonitor              2.0000
    LimitBusyTimesMonitor                     0.0016
    OrdinaryDemandMonitor                     4.0000
    ------------------------------------------------
    Total                                   201.0052

  This is the best result so far, and in only 4 secs!

  Documented a KheTightenResourceDomainsByPartition function
  for tightening the domains of general tasks, as in KTS.  The
  next job is to implement it and see how it performs.

19 November 2010

  Implemented KheTightenResourceDomainsByPartition.  Results
  were disappointing; the cost is higher, and it ran much slower:

    KheTestSolve after assigning resources (19.54 secs so far):
    Soln (instance "BGHS98", cost 213.0097)
    Solution Cost (2091 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   204.0000
    SpreadEventsMonitor                       0.0061
    AvoidClashesMonitor                       4.0000
    LimitBusyTimesMonitor                     0.0036
    OrdinaryDemandMonitor                     5.0000
    ------------------------------------------------
    Total                                   213.0097

  Things were better when the domain reductions were in for the
  construction phase of time assignment, but taken out for the
  ejection chain adjustment phase:

    KheTestSolve after assigning resources (6.53 secs so far):
    Soln (instance "BGHS98", cost 200.0093)
    Solution Cost (2091 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   195.0000
    SpreadEventsMonitor                       0.0061
    AvoidClashesMonitor                       1.0000
    LimitBusyTimesMonitor                     0.0032
    OrdinaryDemandMonitor                     4.0000
    ------------------------------------------------
    Total                                   200.0093

  This is the best so far, but the improvement is very small
  and may be noise, so I'm leaving domain reduction out for
  now.  Try it again when resource assignment gets serious.

  Implemented a repair function for limit workload and limit
  busy times defects.  Unfortunately, it is never called,
  because the monitors collected by KheTaskingMakeGroupMonitor
  are all resource value monitors.  Have to collect resource
  timetable monitors as well, for all resources lying in
  the domains of the tasks involved.

20 November 2010

  Before adding resource timetable monitors to the resource
  assignment ejection chain algorithm, the result was this:

    Solution Cost (2091 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   195.0000
    SpreadEventsMonitor                       0.0036
    AvoidUnavailableTimesMonitor              2.0000
    LimitBusyTimesMonitor                     0.0016
    OrdinaryDemandMonitor                     4.0000
    ------------------------------------------------
    Total                                   201.0052
    KheTestSolve at end (4.07 secs so far)

  After them, I got this:

    Solution Cost (2091 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   201.0000
    SpreadEventsMonitor                       0.0036
    AvoidUnavailableTimesMonitor              2.0000
    LimitBusyTimesMonitor                     0.0010
    OrdinaryDemandMonitor                     4.0000
    ------------------------------------------------
    Total                                   207.0046
    KheTestSolve at end (4.57 secs so far)

  Found and fixed a bug in KheEjectSuccess and got this:

    Solution Cost (2091 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   199.0000
    SpreadEventsMonitor                       0.0036
    AvoidUnavailableTimesMonitor              2.0000
    LimitBusyTimesMonitor                     0.0012
    OrdinaryDemandMonitor                     4.0000
    ------------------------------------------------
    Total                                   205.0048
    KheTestSolve at end (6.63 secs so far)

  Detached dgm from soln and got a much deeper search,
  which however did not actually do better:

    Solution Cost (2091 child monitors)
    ------------------------------------------------
    AssignResourceMonitor                   199.0000
    SpreadEventsMonitor                       0.0036
    AvoidUnavailableTimesMonitor              2.0000
    LimitBusyTimesMonitor                     0.0012
    OrdinaryDemandMonitor                     4.0000
    ------------------------------------------------
    Total                                   205.0048
    KheTestSolve at end (8.10 secs so far)

  Have to look into why we are not getting any deep searches for
  rooms.  I thought it was because there was no-one responding to
  avoid clashes defects, but Kempe resource moves should ensure
  that there are none of those.  Each time we try a room we really
  should be trying to reassign the thing deassigned by the Kempe
  resource move, if depth allows.

  Worked out what the problem is.  In the two cases where the
  ejection chain algorithm is trying to improve the room assignment,
  the Kempe resource assignment does not change the solution cost or
  the number of unmatched demand tixels, even though it introduces
  a clash, because the cost of a clash is the same as the cost of a
  non-assignment, and the matching is no worse afterwards than before.

  Need to place the avoid clashes and avoid unavailable times monitors
  under the resource timetable group monitors, then the search will
  try to repair the clash.  It will fail, but in principle this is
  the right way to go.

20 November 2010

  Added avoid clashes and avoid unavailable times monitors as
  resource timetable monitors, and verified that they are called.
  At present the repair functions are stubs; I will worry about
  them later, they don't seem urgent.  The current soln is:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                50      199.0000
    SpreadEventsMonitor                  36        0.0036
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                 6        0.0012
    OrdinaryDemandMonitor                 4        4.0000
    -----------------------------------------------------
    Total                                97      205.0048
    KheTestSolve at end (6.81 secs so far)

  What to do now?  Resource packing and a split assignments
  assigner seem to be the obvious next steps.

22 November 2010

  After adding a 3-phase last-ditch resource assigner I got this:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                20       38.0000
    AvoidSplitAssignmentsMonitor         32        0.0460
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   4        4.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                18        0.0044
    OrdinaryDemandMonitor                 8        8.0000
    -----------------------------------------------------
    Total                               119       52.0540
    KheTestSolve at end (6.83 secs so far)

  Turning domain tightening on again (cf 19 Nov) gave this:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                17       32.0000
    AvoidSplitAssignmentsMonitor         36        0.0550
    SpreadEventsMonitor                  61        0.0061
    AvoidClashesMonitor                   4        4.0000
    LimitBusyTimesMonitor                31        0.0070
    OrdinaryDemandMonitor                 7        7.0000
    -----------------------------------------------------
    Total                               156       43.0681
    KheTestSolve at end (20.53 secs so far)

  So there is an improvement, but the cost is quite high.
  I'll hold this in reserve, not include it for now.
  Added an ejection chain to the last-ditch solver, but
  it did not do much:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                20       38.0000
    AvoidSplitAssignmentsMonitor         32        0.0430
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   4        4.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                18        0.0040
    OrdinaryDemandMonitor                 8        8.0000
    -----------------------------------------------------
    Total                               119       52.0506
    KheTestSolve at end (8.28 secs so far)

  So again I'll hold off on this for now.

  The real question is, why are so many tasks unassignable
  at the end?  I've generated debug output to investigate
  this question, and indeed every resource seems to have
  a good reason for being unassignable.

  Did a run in which I exploded all tasks and applied an
  ejection chain to them.  Got this:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                10       19.0000
    AvoidSplitAssignmentsMonitor        117        1.1410
    SpreadEventsMonitor                  36        0.0036
    LimitBusyTimesMonitor                18        0.0036
    OrdinaryDemandMonitor                 4        4.0000
    -----------------------------------------------------
    Total                               185       24.1482
    KheTestSolve at end (20.00 secs so far)

  So all but 10 split tasks are indeed assignable (2 are rooms, 3
  are Sport teachers, the rest miscellaneous), but at the cost of
  a truly horrible number of split assignments.  Perhaps the split
  assignments can be repaired?

  Wrote an augment function for avoid split assignments defects,
  which tries every resource in the domain, unless one resource
  is assigned to a visited task, in which case it tries just
  that resource.  The results were

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 9       17.0000
    AvoidSplitAssignmentsMonitor         82        0.0960
    SpreadEventsMonitor                  36        0.0036
    LimitBusyTimesMonitor                22        0.0048
    OrdinaryDemandMonitor                 4        4.0000
    -----------------------------------------------------
    Total                               153       21.1044
    KheTestSolve at end (13.86 secs so far)

  So it did actually do some good.  However, I'm not convinced
  that open slather on split assignments is a good idea.  I think
  the next step is to port the KTS split assignments constructor
  module over, and try to get fewer split assignments that way.
  Here is the current solver with explosion of all tasks removed
  (only unassigned ones get exploded):

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                20       38.0000
    AvoidSplitAssignmentsMonitor         32        0.0440
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   4        4.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                18        0.0040
    OrdinaryDemandMonitor                 8        8.0000
    -----------------------------------------------------
    Total                               119       52.0516
    KheTestSolve at end (9.06 secs so far)

  And here is a run in which expanded domains are not reduced
  again, followed by another ejection chain (whose chances are
  better since the matching bites less tightly):

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                18       35.0000
    AvoidSplitAssignmentsMonitor         33        0.0460
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   4        4.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                18        0.0040
    OrdinaryDemandMonitor                 6        6.0000
    -----------------------------------------------------
    Total                               116       47.0536
    KheTestSolve at end (9.45 secs so far)

  Started work on split assignments.  Have got to the point
  where I can see who's available for which bits of what.
  Next step is to carry out forced assignments etc.

2? November 2010

  Continuing with split assignments; have done forced assts
  and extending them as far as possible also.  The next step
  is to divide into independent task sets.  Here is the
  current soln, with split assignments half done:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                17       33.0000
    AvoidSplitAssignmentsMonitor         32        0.0430
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   4        4.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                18        0.0040
    OrdinaryDemandMonitor                 6        6.0000
    -----------------------------------------------------
    Total                               114       45.0506

  Here is the KTS solution we are aiming to beat:

    Summary                                        Inf.  Obj.
    ---------------------------------------------------------
    Assign Resource Constraint (17 points)           36           
    Avoid Split Assignments Constraint (20 points)        200
    Spread Events Constraint (28 points)                   28
    Limit Busy Times Constraint (20 points)                46
    ---------------------------------------------------------
      Grand total (85 points)                        36   274

  After subtracting 6 from the KHE soln we have 39.0506 for
  KHE vs. 36.0274 for KTS.  So we are not too far behind on
  hard constraints, but soft constraints are a problem.

  Now partitioning split tasks into independent subproblems
  and assigning single resources.  Have this at the moment:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                17       34.0000
    AvoidSplitAssignmentsMonitor         32        0.0400
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   4        4.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                19        0.0042
    OrdinaryDemandMonitor                 6        6.0000
    -----------------------------------------------------
    Total                               115       46.0478

  And now heuristically assigning doubles; got this:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                18       35.0000
    AvoidSplitAssignmentsMonitor         31        0.0400
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   3        3.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                19        0.0042
    OrdinaryDemandMonitor                 6        6.0000
    -----------------------------------------------------
    Total                               114       46.0478
    KheTestSolve at end (10.16 secs so far)

23 November 2010

  Working on resource packing solver.  But in the course of
  getting started with it I removed the most constrained
  solver, leaving the whole resource assignment job to the
  ejection chain algorithm, and got the best soln so far:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                17       35.0000
    AvoidSplitAssignmentsMonitor         36        0.0480
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   2        2.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                16        0.0032
    OrdinaryDemandMonitor                 4        4.0000
    -----------------------------------------------------
    Total                               112       43.0548
    KheTestSolve at end (9.97 secs so far)

  Have got the resource packing solver to the point where
  all the data structures are set up, including the priqueue
  of resource nodes ordered by demand duration minus supply
  duration.

  Results from resource packing (depth_limit == 5, also 6):

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                17       34.0000
    AvoidSplitAssignmentsMonitor         31        0.0430
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   2        2.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                19        0.0038
    OrdinaryDemandMonitor                 4        4.0000
    -----------------------------------------------------
    Total                               110       42.0504
    KheTestSolve at end (9.39 secs so far)

  This is already the best so far.  With depth_limit == 7:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                17       34.0000
    AvoidSplitAssignmentsMonitor         32        0.0420
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   2        2.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                19        0.0038
    OrdinaryDemandMonitor                 4        4.0000
    -----------------------------------------------------
    Total                               111       42.0494
    KheTestSolve at end (10.71 secs so far)

  With depth_limit == 8:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                18       37.0000
    AvoidSplitAssignmentsMonitor         31        0.0430
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   1        1.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                20        0.0040
    OrdinaryDemandMonitor                 3        3.0000
    -----------------------------------------------------
    Total                               110       43.0506
    KheTestSolve at end (9.42 secs so far)

  It seems clear that we are just getting noise now.  After
  letting the ejection chain in the residual solver increase
  the number of unassigned demand nodes:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                15       30.0000
    AvoidSplitAssignmentsMonitor         28        0.0400
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   5        5.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                19        0.0038
    OrdinaryDemandMonitor                 9        9.0000
    -----------------------------------------------------
    Total                               113       46.0474
    KheTestSolve at end (7.50 secs so far)

  This is really 37.0474, the best result so far; it is
  close to KTS's 36.0274.  I've verified it with HSEval.
  Here max_depth == 6, which seems reasonable.  As usual,
  split assignments are the main remaining problem, but
  there is also a problem with under-utilization of
  resources leading to assign resource defects.  Now it's
  time for the tough to get going.

  Also spent some time getting HSEval's planning timetables
  to include unassigned solution resources.

26 November 2010

  Added colour to HSEval and KHE today.
  Found a nasty bug which caused a crash, not finalizing time
  groups properly.  Fixed now, and the result is the same:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                15       30.0000
    AvoidSplitAssignmentsMonitor         28        0.0400
    SpreadEventsMonitor                  36        0.0036
    AvoidClashesMonitor                   5        5.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                19        0.0038
    OrdinaryDemandMonitor                 9        9.0000
    -----------------------------------------------------
    Total                               113       46.0474
    KheTestSolve at end (7.43 secs so far)

  Tried KheTightenResourceDomainsByPartition again, as I
  said I would, and got this:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                12       19.0000
    AvoidSplitAssignmentsMonitor         32        0.0440
    SpreadEventsMonitor                  61        0.0061
    AvoidClashesMonitor                   7        7.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                21        0.0048
    OrdinaryDemandMonitor                14       14.0000
    -----------------------------------------------------
    Total                               148       41.0549
    KheTestSolve at end (23.17 secs so far)

  It's a lot slower but the result is considerably better:
  after subtracting demand monitors it is 27.0549, which
  beats the KTS value 36.0274 by a long way.  I've verified
  it with HSEval, and checked that what happened was that
  the considerable problems with Sport were mostly fixed
  (just 3 unassigned meets in at the Sport times now).

  The KHE solution has good meet regularity but its node
  regularity is not as good as the KTS solution's.  I need
  to look into what happened here.  For example, Year 10
  English is spread all over the place in the KHE soln.

28 November 2010

  While working on node regularity I found a glitch in
  KheEjectorOrdinaryDemandAugment: it was not considering
  moving the meet that caused the demand defect in the
  first place, only its competitors.  Fixing that gave

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                12       18.0000
    AvoidSplitAssignmentsMonitor         32        0.0480
    SpreadEventsMonitor                  37        0.0045
    AvoidClashesMonitor                   7        7.0000
    LimitBusyTimesMonitor                17        0.0046
    OrdinaryDemandMonitor                12       12.0000
    -----------------------------------------------------
    Total                               117       37.0571
    KheTestSolve at end (21.00 secs so far)

  After subtracting demand monitors this is 25.0571, the
  best yet.

  Worked out what the regularity problem was:  it was a
  logic error in the way I tried to carry template layer
  offsets over to new layers.  Fixed now, and getting a
  very regular assignment in Year 10, but Year 9 could be
  better, and even the Year 10 assignment is being wrecked
  by the ejection chain time assigner.  Have to look into
  both these problems.  Current state is

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                12       21.0000
    AvoidSplitAssignmentsMonitor         31        0.0470
    SpreadEventsMonitor                  39        0.0039
    AvoidClashesMonitor                   5        5.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                18        0.0046
    OrdinaryDemandMonitor                13       13.0000
    -----------------------------------------------------
    Total                               119       41.0555
    KheTestSolve at end (8.47 secs so far)

  which is a lost faster and no worse (apart from noise).
  (Did some more work on tables in HSEval.  Very nice now.)
  After sorting the defects by decreasing cost:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                12       22.0000
    AvoidSplitAssignmentsMonitor         30        0.0440
    SpreadEventsMonitor                  53        0.0053
    AvoidClashesMonitor                   8        8.0000
    LimitBusyTimesMonitor                12        0.0034
    OrdinaryDemandMonitor                16       16.0000
    -----------------------------------------------------
    Total                               131       46.0527
    KheTestSolve at end (9.32 secs so far)

  Slightly worse, if anything; forget it for now.  Here
  is what we get when sorting layers by decreasing node
  duration when comparing them for similarity:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                16       31.0000
    AvoidSplitAssignmentsMonitor         29        0.0430
    SpreadEventsMonitor                  39        0.0039
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                19        0.0044
    OrdinaryDemandMonitor                 8        8.0000
    -----------------------------------------------------
    Total                               113       41.0513
    KheTestSolve at end (10.79 secs so far)

  It's somewhat worse, but it seems like we really should do
  this, so I'm leaving it in.  Made the repairs during layer
  construction try harder to keep to the boundaries of the
  template layer, and got this:

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                13       24.0000
    AvoidSplitAssignmentsMonitor         31        0.0390
    SpreadEventsMonitor                  17        0.0017
    AvoidClashesMonitor                   3        3.0000
    LimitBusyTimesMonitor                21        0.0042
    OrdinaryDemandMonitor                 8        8.0000
    -----------------------------------------------------
    Total                                93       35.0449
    KheTestSolve at end (22.25 secs so far)

  It's slow, but cost 27.0449 is pretty good.  Good spread.
  However, Year 9 node regularity is still not good.  Got
  better regularity by allowing an slack (increase in cost)
  of up to (2,0) per node.  Regularity is very good indeed
  when ejection chains are turned off, but when they are
  turned on again the cost is

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                16       30.0000
    AvoidSplitAssignmentsMonitor         30        0.0400
    SpreadEventsMonitor                  25        0.0025
    AvoidClashesMonitor                   3        3.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                17        0.0038
    OrdinaryDemandMonitor                 8        8.0000
    -----------------------------------------------------
    Total                               100       42.0463
    KheTestSolve at end (11.43 secs so far)

  which is not great, but still it might be worth pursuing
  since quite a lot of the regularity does persist through
  the ejection chains phase.  With slack (0,0) we get
  
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                13       24.0000
    AvoidSplitAssignmentsMonitor         31        0.0390
    SpreadEventsMonitor                  17        0.0017
    AvoidClashesMonitor                   3        3.0000
    LimitBusyTimesMonitor                21        0.0042
    OrdinaryDemandMonitor                 8        8.0000
    -----------------------------------------------------
    Total                                93       35.0449
    KheTestSolve at end (22.32 secs so far)

  which is what we had before, logically enough.  It does
  seem to be better really.  Slack (1,0) gives

    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 9       19.0000
    AvoidSplitAssignmentsMonitor         28        0.0410
    SpreadEventsMonitor                  14        0.0014
    AvoidClashesMonitor                   5        5.0000
    LimitBusyTimesMonitor                24        0.0048
    OrdinaryDemandMonitor                 9        9.0000
    -----------------------------------------------------
    Total                                89       33.0472
    KheTestSolve at end (14.11 secs so far)

  which is the best yet (24.0472 really), although this seems to
  be just noise, so I've put the slack back to (0,0).  I need to
  refine the ejection chain part, to get the same improvements
  without wrecking regularity.

29 November 2010

  Working on node regularity by extending the KheLayerMatch
  module to allow domain restrictions.  Have the scaffolding
  up:  I can add and delete template nodes to the domains
  of sets of demand nodes, and see which are compulsory.

  Added diversifiers to solutions and started work on
  parallel threads.

30 November 2010

  Written KheParallelSolve() and also a general solver,
  KheGeneralSolve(), which can be passed to it.  The new stuff
  works perfectly, but there are many bugs in KheSolnCopy().
  I've debugged it to the point where it embarks on the multiple
  solves, but they take a long time, give different answers,
  and crash when deleting the solution at the end.  So there
  is still quite a lot of work to do.

1 December 2010

  Finally got KheParallelSolve() to run right through to the
  end, producing four identical solutions in 14.51 seconds.
  When I ran just one thread, I got that same solution in
  14.35 seconds.  So that worked.  However, when I added a
  call to KheEjectionChainAssignTimes to the general solver,
  I got four solutions in 59 seconds, not all the same:

    soln 0 has cost 51.0493 (new best)
    soln 1 has cost 42.0437 (new best)
    soln 2 has cost 42.0437
    soln 3 has cost 42.0437

  and all much worse than when I run it singly:

    KheGeneralSolve at end (38.16 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 37.0498)

  A single solve of a copy gives this:

    KheGeneralSolve at end (37.87 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 37.0498)

  and when I solve the original after copying it, I get this:

    KheGeneralSolve at end (38.29 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 37.0498)

  When I run sequentially rather than in parallel I get this:

    soln 0 has cost 37.0498 (new best)
    soln 1 has cost 37.0498
    soln 2 has cost 37.0498
    soln 3 has cost 37.0498

  which suggests that there is no problem any more with the
  copying; the problem is interference between threads.  How?
  Running a single solve through the threads gives

    soln 0 has cost 51.0493 (new best)

  and this is what we got before.   It seems that just being
  in a thread, with no copying, changes the solution.  How?
  I've found it: visit_num was undefined in split meets, and
  that introduced nondeterminism.  After fixing it, all solns
  are the same, namely this:

    KheGeneralSolve at end (10.79 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 37.0537)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                11       19.0000
    AvoidSplitAssignmentsMonitor         30        0.0470
    SpreadEventsMonitor                  21        0.0021
    AvoidClashesMonitor                   6        6.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                20        0.0046
    OrdinaryDemandMonitor                11       11.0000
    -----------------------------------------------------
    Total                               100       37.0537

  Minus demand gives 26.0537, very close to the previous
  best, which was 25.0571 (28 Nov).  Time to diversify!

  Working in khe_layer_match.c on function Try, which will
  do a tree search of node regularity restrictions.  Have
  to find a way to diversify it, but that can come later.

2 December 2010

  Implemented the tree search for node regularity, but it
  was too slow.  Here is a curious solution I got along
  the way, not sure how:

    KheGeneralSolve at end (34.20 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 32.0515)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                11       16.0000
    AvoidSplitAssignmentsMonitor         35        0.0450
    SpreadEventsMonitor                  23        0.0023
    AvoidClashesMonitor                   3        4.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                18        0.0042
    OrdinaryDemandMonitor                10       10.0000
    -----------------------------------------------------
    Total                               101       32.0515

  It's the best so far, 22.0515.  I guess it proves that
  diversity could be a big winner.
  
  Got a heuristic search version of node regularity going.
  For Year 10 it found an assignment which had 2 extras,
  one more than the full tree search found, which is not
  too bad.  However the overall solution is not wonderful:

    KheGeneralSolve at end (13.14 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 38.0498)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                18       28.0000
    PreferResourcesMonitor                1        2.0000
    AvoidSplitAssignmentsMonitor         32        0.0430
    SpreadEventsMonitor                  12        0.0012
    AvoidClashesMonitor                   3        3.0000
    LimitBusyTimesMonitor                24        0.0056
    OrdinaryDemandMonitor                 5        5.0000
    -----------------------------------------------------
    Total                                95       38.0498

  Minus demand gives 33.0498, not a great result.  Sorting
  by decreasing duration gives

    KheGeneralSolve at end (8.19 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 46.0425)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                18       29.0000
    AvoidSplitAssignmentsMonitor         27        0.0370
    SpreadEventsMonitor                  17        0.0017
    AvoidClashesMonitor                   6        7.0000
    LimitBusyTimesMonitor                19        0.0038
    OrdinaryDemandMonitor                10       10.0000
    -----------------------------------------------------
    Total                                97       46.0425

  which again is not wonderful, although the Year 10 node
  regularity result is optimal this time, and optimal in the
  final result too, suggesting that the idea is right but
  we've been unlucky afterwards.  So we'll stick with this.

  Now diversifying by rotating template nodes of equal
  duration within each demand node group before searching
  for node-regular layer assignments.  This is the result:

    soln 0 has cost 46.0425 (new best)
    soln 1 has cost 42.0586 (new best)
    soln 2 has cost 32.0518 (new best)
    soln 3 has cost 57.0460
    Soln (instance "BGHS98", diversifier 2, cost 32.0518)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                14       24.0000
    AvoidSplitAssignmentsMonitor         33        0.0440
    SpreadEventsMonitor                  22        0.0022
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                21        0.0056
    OrdinaryDemandMonitor                 6        6.0000
    -----------------------------------------------------
    Total                                98       32.0518

  Actual cost is 26.0518, which is quite good.  Inspection
  reveals however that the final result is not very node
  regular in Year 10.  There is quite a lot of diversity,
  which is promising, although the worst cost, 57.0460, is
  quite bad.  The slowest ran in 21 seconds.  Here is the
  result of 16 threads:

    soln 0 has cost 46.0425 (new best)
    soln 1 has cost 42.0586 (new best)
    soln 2 has cost 32.0518 (new best)
    soln 3 has cost 57.0460
    soln 4 has cost 44.0408
    soln 5 has cost 46.0427
    soln 6 has cost 37.0458
    soln 7 has cost 45.0438
    soln 8 has cost 44.0568
    soln 9 has cost 47.0440
    soln 10 has cost 37.0615
    soln 11 has cost 57.0373
    soln 12 has cost 46.0425
    soln 13 has cost 42.0586
    soln 14 has cost 50.0387
    soln 15 has cost 57.0460
    [ Soln (instance "BGHS98", diversifier 2, cost 32.0518)
      Soln                            Defects          Cost
      -----------------------------------------------------
      AssignResourceMonitor                14       24.0000
      AvoidSplitAssignmentsMonitor         33        0.0440
      SpreadEventsMonitor                  22        0.0022
      AvoidClashesMonitor                   2        2.0000
      LimitBusyTimesMonitor                21        0.0056
      OrdinaryDemandMonitor                 6        6.0000
      -----------------------------------------------------
      Total                                98       32.0518
    ]

  It's disappointing that there is no further improvement after
  the third thread, and indeed the others don't come close.

  Viewing the best of four solutions without the ejection chain
  time assigner reveals a wonderfully node-regular timetable,
  but the Year 9 Science-Music runaround seems to be missing.
  Looked into this and discovered that I had broken it when
  uniqueifying sorting.  Fixed now, single solution is

    KheGeneralSolve at end (15.81 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 46.0342)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                14       26.0000
    AvoidSplitAssignmentsMonitor         22        0.0280
    SpreadEventsMonitor                  20        0.0020
    AvoidClashesMonitor                   7        8.0000
    LimitBusyTimesMonitor                18        0.0042
    OrdinaryDemandMonitor                12       12.0000
    -----------------------------------------------------
    Total                                93       46.0342

  best of 4 is (55.13 secs!)

    soln 0 has cost 46.0342 (new best)
    soln 1 has cost 37.0599 (new best)
    soln 2 has cost 39.0493
    soln 3 has cost 44.0501
    Soln (instance "BGHS98", diversifier 1, cost 37.0599)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                15       24.0000
    AvoidSplitAssignmentsMonitor         40        0.0530
    SpreadEventsMonitor                  17        0.0017
    AvoidClashesMonitor                   1        1.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                23        0.0052
    OrdinaryDemandMonitor                10       10.0000
    -----------------------------------------------------
    Total                               107       37.0599

  and best of 16 is

    soln 0 has cost 46.0342 (new best)
    soln 1 has cost 37.0599 (new best)
    soln 2 has cost 39.0493
    soln 3 has cost 44.0501
    soln 4 has cost 38.0457
    soln 5 has cost 51.0387
    soln 6 has cost 44.0437
    soln 7 has cost 36.0555 (new best)
    soln 8 has cost 39.0442
    soln 9 has cost 41.0355
    soln 10 has cost 46.0440
    soln 11 has cost 42.0490
    soln 12 has cost 46.0342
    soln 13 has cost 37.0599
    soln 14 has cost 39.0493
    soln 15 has cost 44.0501
    [ Soln (instance "BGHS98", diversifier 7, cost 36.0555)
      Soln                            Defects          Cost
      -----------------------------------------------------
      AssignResourceMonitor                16       22.0000
      AvoidSplitAssignmentsMonitor         34        0.0510
      SpreadEventsMonitor                   7        0.0007
      AvoidClashesMonitor                   3        3.0000
      AvoidUnavailableTimesMonitor          1        1.0000
      LimitBusyTimesMonitor                18        0.0038
      OrdinaryDemandMonitor                10       10.0000
      -----------------------------------------------------
      Total                                89       36.0555
    ]

  which is 26.0555, not too bad but we've seen better.  The
  node regularity of the final solution is fairly good.

  Am now detaching ordinary demand monitors before comparing
  parallel solutions, to get the true cost.  Also found a
  slight bug: I was still fixing edges, after node regularity.
  Here are the 16 results after these changes:

    soln 0 has cost 26.0455 (new best)
    soln 1 has cost 31.0458
    soln 2 has cost 29.0483
    soln 3 has cost 47.0414
    soln 4 has cost 35.0387
    soln 5 has cost 31.0399
    soln 6 has cost 29.0453
    soln 7 has cost 26.0440 (new best)
    soln 8 has cost 32.0466
    soln 9 has cost 29.0497
    soln 10 has cost 30.0493
    soln 11 has cost 32.0418
    soln 12 has cost 26.0455
    soln 13 has cost 26.0445
    soln 14 has cost 29.0483
    soln 15 has cost 47.0414

  And here's a dinky histogram of them:

    46.0000 | **
    44.0000 | 
    42.0000 | 
    40.0000 | 
    38.0000 | 
    36.0000 | 
    34.0000 | *
    32.0000 | **
    30.0000 | ***
    28.0000 | ****
    26.0000 | ****

  and the details of the best:

    Soln (instance "BGHS98", diversifier 7, cost 26.0440)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                15       23.0000
    AvoidSplitAssignmentsMonitor         32        0.0380
    SpreadEventsMonitor                  16        0.0016
    AvoidClashesMonitor                   3        3.0000
    LimitBusyTimesMonitor                21        0.0044
    -----------------------------------------------------
    Total                                87       26.0440

  Things to do
  ------------

  Despite having different diversifiers, soln 12 equals soln
  0 above and there are other repetitions.  Can we fix this?

  Need to document layer match node regularity, and possibly
  remove edge fixing.  I never liked edge fixing.

  Tightening by partition is not the same as the KTS algorithm
  at the moment, and it probably should be.  Anyway we need to
  do something about non-specialist teachers being forced to
  take reams of stuff out of their faculty.

3 December 2010

  Done the documentation of node regularity, done some fiddling
  with HSEval's planning timetables.  Tried to get more diversity
  but got nowhere for a while, so I started to think and ended up
  doing some experiments, written up in the user's guide.  The
  upshot is that I can get more diversity now, and running 16
  threads gave this:

    soln 0 has cost 26.0455 (new best)
    soln 1 has cost 31.0458
    soln 2 has cost 29.0483
    soln 3 has cost 47.0414
    soln 4 has cost 35.0387
    soln 5 has cost 31.0399
    soln 6 has cost 29.0453
    soln 7 has cost 26.0440 (new best)
    soln 8 has cost 32.0466
    soln 9 has cost 29.0497
    soln 10 has cost 30.0493
    soln 11 has cost 32.0418
    soln 12 has cost 27.0377
    soln 13 has cost 30.0507
    soln 14 has cost 27.0463
    soln 15 has cost 31.0422

  Sure enough they are all distinct (I've checked).  Histo:

    46.0000 | *
    44.0000 | 
    42.0000 | 
    40.0000 | 
    38.0000 | 
    36.0000 | 
    34.0000 | *
    32.0000 | **
    30.0000 | *****
    28.0000 | ***
    26.0000 | ****

  The best one, cost 26.0440, is as above.

4 December 2010

  Thought of a better diversification function overnight, and after
  some fiddling got a great one, which is diverse up to c = 8 and
  probably thereafter as well.  All documented.  When using this
  function the results of 16 threads are

    soln 0 has cost 26.0455 (new best)
    soln 1 has cost 31.0458
    soln 2 has cost 29.0558
    soln 3 has cost 38.0438
    soln 4 has cost 35.0503
    soln 5 has cost 38.0408
    soln 6 has cost 25.0520 (new best)
    soln 7 has cost 26.0440
    soln 8 has cost 23.0539 (new best)
    soln 9 has cost 32.0444
    soln 10 has cost 31.0479
    soln 11 has cost 28.0396
    soln 12 has cost 29.0453
    soln 13 has cost 33.0498
    soln 14 has cost 29.0526
    soln 15 has cost 33.0491

    38.0000 | **
    37.0000 | 
    36.0000 | 
    35.0000 | *
    34.0000 | 
    33.0000 | **
    32.0000 | *
    31.0000 | **
    30.0000 | 
    29.0000 | ***
    28.0000 | *
    27.0000 | 
    26.0000 | **
    25.0000 | *
    24.0000 | 
    23.0000 | *

  The best of these is pretty good:

    Soln (instance "BGHS98", diversifier 8, cost 23.0539)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                12       20.0000
    AvoidSplitAssignmentsMonitor         34        0.0420
    SpreadEventsMonitor                  61        0.0061
    AvoidClashesMonitor                   1        2.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                22        0.0058
    -----------------------------------------------------
    Total                               131       23.0539

  The best so far, 22.0515 (2 Dec), came from I know not where,
  but this one (23.0539) is nearly as good.

  Added slack to KheLayerMatchImproveNodeRegularity.  For four
  processes, here are the results of using slack:

     Slack            Best result of 4
     ---------------------------------
     KheCost(0, 0)    26.0455 (61 secs)
     KheCost(1, 0)    23.0536 (40 secs)
     KheCost(2, 0)    26.0523 (17 secs)
     KheCost(3, 0)    25.0532 (32 secs)
     ---------------------------------

  This needs to be tried again later.  For now I am using
  KheCost(1, 0) as slack, since I suspect that the good
  result it produces is not just noise.

  16 threads with slack KheCost(1, 0) gave best soln

    Soln (instance "BGHS98", diversifier 10, cost 22.0430)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                11       14.0000
    AvoidSplitAssignmentsMonitor         27        0.0360
    SpreadEventsMonitor                  19        0.0020
    AvoidClashesMonitor                   5        8.0000
    LimitBusyTimesMonitor                19        0.0050
    -----------------------------------------------------
    Total                                81       22.0430

  This is the best solution so far.

  I improved domain tightening and documented the improved
  version.  Its results are:

     Slack            Best result of 4
     ---------------------------------
     KheCost(0, 0)    28.0387 (14 secs)
     KheCost(1, 0)    23.0455 (13 secs)
     KheCost(2, 0)    26.0413 (14 secs)
     KheCost(3, 0)    18.0391 (13 secs)
     ---------------------------------

  The last of these is a new record.  It is also the best of 16.
  Even if these results don't actually look better, they are,
  because better resources are going to Sport, etc.  Back to
  KheCost(1, 0), where I feel more comfortable, the best result
  for 16 threads is

    Soln (instance "BGHS98", diversifier 7, cost 23.0404)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                10       20.0000
    AvoidSplitAssignmentsMonitor         22        0.0320
    SpreadEventsMonitor                  24        0.0024
    AvoidClashesMonitor                   3        3.0000
    LimitBusyTimesMonitor                23        0.0060
    -----------------------------------------------------
    Total                                82       23.0404

  Not a brilliant number, but only 3 clashes, and these are
  likely to be the most intractable of the remaining defects.

  Are we exploding all tasks before the final ejection chain
  repair?  We should be.

5 December 2010

  Documented a useful generalization of domain tightening.
  In the middle of a rather messy implementation of it now:

  * khe_event_resource.c, KheEventResourceFindDomain.  Have
    just realized that there is no mapping back from the
    event resource to the event group of its avoid split
    assignments constraints.  Have to do something about
    this, else there will be a ridiculously long search.

  * khe_assign_resource.c old code has been commented out
    but some of it may be useful in khe_tighten.c

  * khe_tighten.c, KheChangeTaskDomains is there at the
    end but it's just a stub at the moment.  Need to
    fill it in and then comment out all the stuff that
    becomes obsolete in this file.

7 December 2010

  Add four functions beginning with KheTaskSetDomainAllCheck()
  to previous list of things to do.  But then subsequently
  folded them into the other functions by adding a recursive
  parameter to them.  All done and documented.

  Have tidied up tasks by introducing KheTaskState() and
  related functions.  This classifies tasks in the way
  that solvers need them to be classified.  Still to do:

  * KheChangeTaskDomains, the criminal that started all this
    now generalized into KheTaskTreeMake().

  * Should also audit KheAvoidSplitAssignmentsAssignTasks()
    from file khe_task_group.c; it needs to be coordinated
    with these new ideas about tasks and their domains.

  * Need to revise how matching domains are changed by task
    assignments.  They should work like meet domains, off the
    root task unless evaluating; but at present they don't.

  * What if the root task has no event resource, as is likely?
    Perhaps we would do better to avoid this case?

  * KheSolnMakeCompleteRepresentation should set the domain
    of each task to the full set of resources of its type,
    and leave it to KheTaskTreeMake to reduce these domains.

  * KheLayerTree make claims to detach prefer resources monitors.
    What can that be about?

  * The resource solvers chapter is being radically reorganized.
    The task tree reorganization section needs reorganization,
    and the later sections need an audit, the last section,
    which puts everything together, will need a complete rewrite
    later on.

8 December 2010

  Documentation all done except for two sections marked to be done
  later after the dust settles.

  Done and documented KheMonitorAttachCheck for all monitor types,
  although one or two got a stub implementation.  I'm back working
  on khe_task_tree.c.  It's going steadily, have done the jobs for
  prefer resources constraints and avoid split assignments constraints;
  now I only have to fly in the old code for tightening to a partition.

  Except I don't seem to be checking preserve_invariant; must do that.

  Recursive domain tightening should change as little as possible,
  consistent with maintaining the solution invariant.

9 December 2010

  Tighten to partition job done, and so the construction, as opposed
  to reconstruction, part of khe_split_tree.c is all done now.

  Defined, documented, and implemented the small but beautiful
  KheInvariantTransactionBegin and KheInvariantTransactionEnd
  and used them in khe_split_tree.c.

  Still to do (compiled by trawling the above, and grepping the code)
  -------------------------------------------------------------------

  (done) KheAssignResources (khe_assign_resource.c), the function that
  puts it all together, has regressed to a stub at the moment.  It needs
  to be brought back in a new form, and the corresponding section
  of the doc (the last section of the Resource Solvers chapter)
  rewritten to explain it.

  (done) KheAvoidSplitAssignmentsAssignTasks and possibly other
  functions in khe_task_group.c should be obsolete now; need to
  look into this, make sure that removing overlaps does not drop
  anything useful, and do it.

  (done) Replace the 4-state classification scheme with a 3-state.

  (done) Need to revise how matching domains are changed by task
  assignments.  They should work like meet domains, off the
  root task unless evaluating; but at present they don't.

  What if a root task has no event resource, as is likely?
  Need to audit everything to make sure it makes sense in
  this case.  Can probably delete such tasks when nothing is
  assigned to them.  Are we even creating them now?  Perhaps
  we should be, as an alternative to tightening domains?

  (done) KheSolnMakeCompleteRepresentation should set the domain
  of each task to the full set of resources of its type, and
  leave it to KheTaskTreeMake to reduce these domains.  Also
  have to think about when and how to call KheTaskTreeMake
  from the main line of the solver, taking into account
  such arcana as the fact that it assigns preassigned tasks.

  (done) KheLayerTree make claims to detach prefer resources
  monitors.  It should butt out of this area now; need to audit
  it and fix.  Also it should "Check" rather than merely "Detach".

  (done) Need to produce a variety of task tree reorganization
  functions, including KheTaskTreeDelete, and document them.

  (x) Recursive domain tightening should change as little as
  possible, consistent with maintaining the solution invariant.

  (done) KheMonitorAttachCheck is done and documented except
  for prefer times monitors, where there is a serious job to do,
  coordinated with the equivalent thing that is already being
  done within KheLayerTreeMake somewhere.

  (done) KheFindResidualResourceAssignments() contains a number
  of steps, many of which are affected by the current changes.
  Need to think whether we want this function at all (we
  could fold its steps into KheAssignResources), and anyway
  re-implement them in the new way.

  Off-site backup once this is all done and tested.

10 December 2010

  Definition of domain used by ordinary demand nodes
  --------------------------------------------------

  This is KheResourceGroupResourceIndexes(rg) where rg
  is defined as follows:

    case KHE_MATCHING_TYPE_EVAL_INITIAL:
    case KHE_MATCHING_TYPE_EVAL_TIMES:

      KheTaskDomain(task);

    case KHE_MATCHING_TYPE_SOLVE:
    case KHE_MATCHING_TYPE_EVAL_RESOURCES:

      KheTaskDomain(KheTaskRoot(task));

  So the domains change when the matching type changes,
  when the domain changes, and when the assignments change.
  Have written the core functions that implement this, but
  not yet incorporated them properly where they need to be
  called, or separated them from the quite separate code
  that needs to be called when a resource is assigned.

11 December 2010

  Documented the initial domains of meets and tasks more
  clearly, and made them analogous.  Seems like all is
  ready to start using the new structure in the algorithms.

  (x) Move documentation of specific ejection chain algorithms
  to the relevant chapters (time solvers, resource solvers,
  and later on general solvers).  Move the chapter which
  introduces ejection chains to the start of the solvers
  section, or perhaps to after layer tree solvers.

  (done) I've revised the resource solvers chapter's remaining
  sections, and they are all ready to implement, and the
  implementation does not look very difficult.  Do that next,
  and we will be close to done.

  Still to do
  -----------

  (done) Move documentation of monitor grouping to the Monitoring
  chapter and distribute it by monitor type.

  (done) Investigate whether these groupings should change as the
  meets and tasks are regrouped, and how.

  (done) Move Kempe time moves to the Time Solvers chapter, and
  move Kempe resource assignments to the Resource Solvers chapter.

  (done) *Specify* time and resource repair algorithms in sections
  of the Time Solvers and Resource Solvers chapters, *implement*
  them in the separate Ejection Chains chapter.

  Also want to explain in the mcf, resource packing, and split
  assignments sections why there is no preserve_invariant
  option (it's compulsory).  Where there isn't a good reason,
  I should really add the option.

  Off-site backup once it's all running and tested.

  (done) Currently working on a new chapter called "Monitor
  Grouping and Tracing".  It's all done except the last section,
  the one defining the helper functions for grouping.  When that
  is done, I need to remove the progenitor sections from their
  old chapters, move Kempe sections as above, and then review
  the structure of the guide.

  (done) Need to audit and document the monitor grouping assumptions
  of Kempe resource assignments.

13 December 2010

  Still to do
  -----------

  (done) Investigate whether monitor groupings should change as the
  meets and tasks are regrouped, and how.  There are ungrouping
  and regrouping operations in the time solver code, and at
  the start of ejection chain resource assignment.

  (done) KheTaskingMakeGroupMonitor out on a limb - where does it fit?

  (done) Need to audit and document the monitor grouping
  assumptions of Kempe resource assignments.

  (done) "Putting it all together" section of Time Solvers chapter.

  Off-site backup once it's all running and tested.

14 December 2010

  Sorted out and documented the principles that govern how
  monitors should be attached and grouped.  Am now working
  through ensuring that these principles are followed by the
  general solver.  Up to the start of time assignment.

  (done) Audit augment functions, and particularly allow Kempe
  moves to try every leader meet, not just the highest.

  (done) Simple-minded time assignment functions need a clear out.

  (done) Need a function for detaching all workload monitors, to
  put in KheGeneralSolve.

  Look at how solvers are distributed into files, and spread
  them out more.

15 December 2010

  Still struggling with attaching and grouping.  Or rather,
  attaching is done, and I know now exactly what needs to
  be done for grouping, but I'm making heavy weather of it.

  I've deviated into revising the augment functions.  I've
  documented the revised versions and done some implementation,
  but there is a lot more to do.  It's wonderful though, all
  much more principled than before.

16 December 2010

  Revising all the augment functions today, and documenting
  them in detail.  Have completed event monitors and event
  resource monitors so far, and am close on resource monitors:
  all that remains to do is to make sure the existing code is
  applied only in cases of overloads, not underloads.

17 December 2010

  Finished the revision and documentation of the augment
  functions, except for those parts documented as still to
  do; they are not needed for solving Australian instances.

  Still to do
  -----------

  (done) Ensure that the monitor attachment and grouping invariant
  is preserved by the solvers.

  (done) KheTaskingMakeGroupMonitor out on a limb - where does it fit?

  (done) Need a function for detaching all workload monitors, to
  put in KheGeneralSolve.

  Look at how solvers are distributed into files, and spread
  them out more.

  Off-site backup once it's all running and tested.

  Survey of all monitor grouping
  ------------------------------

  KheGroupEventMonitors groups event monitors
  It is currently called only by KheGroupAllMonitors

  KheGroupEventResourceMonitors groups event resource monitors
  It is currently called only by KheGroupAllMonitors

  KheGroupResourceMonitors groups demand monitors
  It is currently called only by KheGroupAllMonitors

  KheGroupOrdinaryDemandMonitorsByTask groups ordinary demand
  monitors by task.  It doesn't seem to be called at all.

  KheGroupOrdinaryDemandMonitorsByMeet groups ordinary demand
  monitors by meet.  It is called twice by KheGroupAllMonitors,
  once for preassigned and once for unpreassigned demand mon's.

  KheGroupWorkloadDemandMonitorsByResource groups workload
  demand monitors by resource
  It is currently called only by KheGroupAllMonitors

  KheGroupWorkloadDemandMonitorsByTimeGroup groups workload
  demand monitors by time group.  It is not currently used.

  KheTaskingMakeGroupMonitor groups event resource monitors
  (assumed to exist with type KHE_SUBTAG_EVENT_RESOURCE)
  and resource monitors (assumed to exist with type
  KHE_SUBTAG_RESOURCE) under a single grandparent group
  monitor, for use in ejection chain resource assignment
  for a given tasking - these are the defects that the
  ejection chain works on.

  KheEjectionChainAssignResources builds a single group
  monitor holding all demand monitors, and passes it to
  the ejector via KheEjectorAddMonitorCostLimit to keep
  its cost constant.

  KheFirstLayerGroupMonitorMake builds a group layer
  holding the event monitors (type KHE_SUBTAG_EVENT) and
  demand monitors (no type checked) of the first layer.
  It is used by KheFirstLayerLocalSearch, and deleted
  afterwards.

  KheAllLayersGroupMonitorMake does the same thing, but for
  all child nodes, not just the nodes of the first layer.
  It is used by KheEjectionChainAssignTimes, and deleted
  afterwards.

  KheGroupAllMonitors is not currently called, but it
  was called previously by the time assignment algorithms.

18 December 2010

  New versions of the higher level grouping functions done
  and documented.  New versions of ejection chain solvers
  done and documented.

  Things to do
  ------------

  KheEjectionChainRepairTimes thinks it can repair preassigned
  demand defects, but there are none of those under the group
  monitor it passes to the ejector.  I should probably have kept
  the previous scheme, of grouping preassigned demand nodes by
  meet.  Must look into this and make the appropriate adjustments
  to the code and documentation.

  Look at how solvers are distributed into files, and spread
  them out more.

  Off-site backup once it's all running and tested.

19 December 2010

  Sorted out grouping for Kempe time moves and resource
  assignments, so that completes the coding.  This rewrite,
  which is now finished, began on 5 December.

  (done) Also want to explain in the mcf, resource packing,
  and split assignments sections why there is no preserve_invariant
  option (it's compulsory).  Where there isn't a good reason,
  I should really add the option.

  Audited how solvers are distributed into files, rearranged
  them, and documented the arrangement in the makefile.

20 December 2010

  Testing and debugging today.  Quite a long list of small
  problems.  After fixing them all, apparently, I got this:

    KheGeneralSolve at end (28.34 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 33.0445)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                13       29.0000
    AvoidSplitAssignmentsMonitor         30        0.0380
    SpreadEventsMonitor                  21        0.0021
    AvoidClashesMonitor                   2        3.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                20        0.0044
    -----------------------------------------------------
    Total                                87       33.0445

  from one thread, and

    Soln (instance "BGHS98", diversifier 2, cost 29.0409)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                13       25.0000
    AvoidSplitAssignmentsMonitor         21        0.0330
    SpreadEventsMonitor                  39        0.0039
    AvoidClashesMonitor                   3        4.0000
    LimitBusyTimesMonitor                17        0.0040
    -----------------------------------------------------
    Total                                93       29.0409

  is the best of 4 threads.  These results are somewhat
  inferior to what I was getting before, because Sport 
  has gone bad again - why?  After fiddling with it, got
  a better arrangement but the solution was unlucky:

    KheGeneralSolve at end (16.44 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 38.0433)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                17       35.0000
    AvoidSplitAssignmentsMonitor         25        0.0320
    SpreadEventsMonitor                  65        0.0071
    AvoidClashesMonitor                   2        2.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                19        0.0042
    -----------------------------------------------------
    Total                               129       38.0433

  Here is the best of 4 threads:

    Soln (instance "BGHS98", diversifier 3, cost 27.0572)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                11       25.0000
    AvoidSplitAssignmentsMonitor         33        0.0500
    SpreadEventsMonitor                  14        0.0014
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                23        0.0058
    -----------------------------------------------------
    Total                                83       27.0572

  Still inferior to before.  I think the problem is an
  irregular Year 10 time assignment.  That needs to be
  looked into.  Here is best of 16:

    44.0000 | *
    43.0000 | 
    42.0000 | 
    41.0000 | 
    40.0000 | 
    39.0000 | *
    38.0000 | **
    37.0000 | 
    36.0000 | 
    35.0000 | ***
    34.0000 | *
    33.0000 | *
    32.0000 | 
    31.0000 | ***
    30.0000 | *
    29.0000 | 
    28.0000 | *
    27.0000 | *
    26.0000 | 
    25.0000 | *

    Soln (instance "BGHS98", diversifier 5, cost 25.0478)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 9       21.0000
    AvoidSplitAssignmentsMonitor         30        0.0430
    SpreadEventsMonitor                  16        0.0016
    AvoidClashesMonitor                   3        3.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                16        0.0032
    -----------------------------------------------------
    Total                                75       25.0478

  This best solution is more regular in Year 10, so that does
  seem to be the place to start.  Can also see cases where a
  shallow ejection chain would improve resource assignment; I
  suspect that it's not working properly after split assignments.
  How does it group event resource monitors at that stage?

  Tried removing the time assignment ejection chain run that
  is before flattening.  Here is the best of 4:

    Soln (instance "BGHS98", diversifier 2, cost 22.0431)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 9       20.0000
    AvoidSplitAssignmentsMonitor         28        0.0370
    SpreadEventsMonitor                  23        0.0023
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                18        0.0038
    -----------------------------------------------------
    Total                                80       22.0431

  This seems to be the best so far (apart from the 18 outlier
  that I rejected), so it looks like that first ejection
  adjustment was a bad idea.  This was also the best of 16.
  But the Year10 regularity problem, and the ejection chain
  after splitting problem, are still there.

21 December 2010

  Fixed a bug in the call to KheTaskingAllowSplitAssignments
  (it was splitting unassigned slots only), and got this as
  the best of 4 (12 secs):

    31.0000 | *
    18.0000 | *
    13.0000 | *
    12.0000 | *

    Soln (instance "BGHS98", diversifier 1, cost 12.0499)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 8       11.0000
    AvoidSplitAssignmentsMonitor         33        0.0430
    SpreadEventsMonitor                  31        0.0031
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                18        0.0038
    -----------------------------------------------------
    Total                                91       12.0499

  And here is the best of 16:

    44.0000 | *
    42.0000 | 
    40.0000 | 
    38.0000 | 
    36.0000 | 
    34.0000 | *
    32.0000 | 
    30.0000 | *
    28.0000 | 
    26.0000 | *
    24.0000 | **
    22.0000 | 
    20.0000 | *
    18.0000 | ***
    16.0000 | *
    14.0000 | **
    12.0000 | **
    10.0000 | 
     8.0000 | *

    Soln (instance "BGHS98", diversifier 9, cost 8.0845)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 5        7.0000
    AvoidSplitAssignmentsMonitor         53        0.0750
    SpreadEventsMonitor                  49        0.0049
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                20        0.0046
    -----------------------------------------------------
    Total                               128        8.0845

  Hard costs are pretty close to the mark, but there is
  a huge number of avoid split assignments defects.  And
  sure enough, this timetable looks more regular too.

  Simplified Kempe resource assignment so it just goes to
  the timetable and deassigns unpreassigned clashes (also
  it checks for unavailable times).  The result was

    KheGeneralSolve at end (12.67 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 12.0397)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 7       10.0000
    AvoidSplitAssignmentsMonitor         29        0.0330
    SpreadEventsMonitor                  21        0.0021
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                20        0.0046
    -----------------------------------------------------
    Total                                79       12.0397

  Best of 16 was

    13.0000 | *
    12.0000 | *
    11.0000 | ***
    10.0000 | *
     9.0000 M *****
     8.0000 | ***
     7.0000 | 
     6.0000 | *
     5.0000 | *

    Soln (instance "BGHS98", diversifier 11, cost 5.0624)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 1        2.0000
    AvoidSplitAssignmentsMonitor         48        0.0540
    SpreadEventsMonitor                  31        0.0038
    AvoidClashesMonitor                   2        2.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                19        0.0046
    -----------------------------------------------------
    Total                               102        5.0624

  I tried with 64 threads but there were only 24 distinct
  solutions, and this one was the best of those.

  Here are some experiments where I vary the slack cost:

     Slack cost         Best of 1         Best of 16
     -----------------------------------------------
     KheCost(0, 0)       6.0562            6.0562
     KheCost(0, 1000)    6.0562            6.0562
     KheCost(1, 0)      12.0397            5.0624
     KheCost(2, 0)       7.0672            6.0608
     KheCost(3, 0)      15.0677            7.0544
     -----------------------------------------------

  Let's stick with the tried and true KheCost(1, 0).

22 December 2010

  Added a bit of diversity to the runaround building and got

    KheGeneralSolve at end (15.75 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 10.0623)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 4        7.0000
    AvoidSplitAssignmentsMonitor         43        0.0480
    SpreadEventsMonitor                  76        0.0079
    AvoidClashesMonitor                   2        3.0000
    LimitBusyTimesMonitor                27        0.0064
    -----------------------------------------------------
    Total                               152       10.0623
  
  which is better than the 12.0397 first result before.
  Best of 16 was

    25.0000 | **
    24.0000 | 
    23.0000 | *
    22.0000 | 
    21.0000 | 
    20.0000 | *
    19.0000 | 
    18.0000 | ****
    17.0000 | *
    16.0000 | 
    15.0000 | 
    14.0000 | ***
    13.0000 | **
    12.0000 | 
    11.0000 | 
    10.0000 | *
     9.0000 | *

  so I've withdrawn this feature; but that it should make such
  a difference is a worry.  Diversifying first layer no use either:

    25.0000 | *
    24.0000 | 
    23.0000 | 
    22.0000 | 
    21.0000 | 
    20.0000 | **
    19.0000 | *
    18.0000 | **
    17.0000 | *
    16.0000 | *
    15.0000 | 
    14.0000 | ***
    13.0000 | **
    12.0000 | **
    11.0000 | *

  Resurrected sorting defects into decreasing cost order at
  the start of KheEjectSolve:

    14.0000 | *
    13.0000 | 
    12.0000 | **
    11.0000 | **
    10.0000 M ***
     9.0000 M 
     8.0000 M ******
     7.0000 | *
     6.0000 | *

    Soln (instance "BGHS98", diversifier 5, cost 6.0537)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 2        4.0000
    AvoidSplitAssignmentsMonitor         42        0.0460
    SpreadEventsMonitor                  31        0.0031
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                20        0.0046
    -----------------------------------------------------
    Total                                97        6.0537
   
  Although this is one worse than the 5.0624 result, the soft
  cost is somewhat better (six fewer split assignments), and
  the final timetable looks a lot more node-regular.

  The problem now, as always, is split assignments.  The first
  step would seem to be to encourage resource packing to leave
  behind tasks that are easily moved in time.  When that is
  done, we can try an ejection chain that moves tasks in time
  to places where they can be assigned resources.

23 December 2010

  Decided overnight to try two node-based methods of improving
  time assignment before flattening and applying ejection chains
  to the meets:

  (1) An ejection chain whose repairs are node swaps.

  (2) A weighted bipartite matching whose demand nodes are
      the nodes of one layer, whose supply nodes are the
      spaces that those demand nodes currently occupy, with
      one edge for each legal assignment, labelled by the
      cost delta when that assignment is made; and then
      simply accept the minimum matching.

  Did (2) first.  All written and seems to be working, judging
  from some detailed debug output I've pored over.  Sadly, no
  improvements were found.

  Tried (2) after assigning every layer, on the grounds that
  there might be more freedom to move before all the layers
  have been assigned.  And indeed it found exactly one
  improvement.  Here is the solution:

    KheGeneralSolve at end (11.63 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 10.0627)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 5        7.0000
    AvoidSplitAssignmentsMonitor         44        0.0550
    SpreadEventsMonitor                  23        0.0023
    AvoidClashesMonitor                   2        2.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                21        0.0054
    -----------------------------------------------------
    Total                                96       10.0627

  And here is the solution without layer node repairing:

    KheGeneralSolve at end (11.05 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 11.0632)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 7       10.0000
    AvoidSplitAssignmentsMonitor         51        0.0570
    SpreadEventsMonitor                  20        0.0020
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                19        0.0042
    -----------------------------------------------------
    Total                                98       11.0632

  So at the cost of about 0.6 seconds we have a slightly
  better solution.  Here is the best of 16 with it:

    16.0000 | *
    15.0000 | *
    14.0000 | 
    13.0000 | 
    12.0000 | **
    11.0000 | *
    10.0000 | *
     9.0000 | 
     8.0000 M **
     7.0000 M *****
     6.0000 | ***

    Soln (instance "BGHS98", diversifier 10, cost 6.0497)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        4.0000
    AvoidSplitAssignmentsMonitor         38        0.0430
    SpreadEventsMonitor                  19        0.0019
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                20        0.0048
    -----------------------------------------------------
    Total                                82        6.0497

  And without it:

    14.0000 | *
    13.0000 | 
    12.0000 | **
    11.0000 | **
    10.0000 M ***
     9.0000 M 
     8.0000 M ******
     7.0000 | *
     6.0000 | *

    Soln (instance "BGHS98", diversifier 5, cost 6.0537)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 2        4.0000
    AvoidSplitAssignmentsMonitor         42        0.0460
    SpreadEventsMonitor                  31        0.0031
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                20        0.0046
    -----------------------------------------------------
    Total                                97        6.0537

  The best is only marginally better on hard constraints and
  split assignments, but the median is noticeably better, as
  is spread, presumably because there was less disruption by
  the meet ejection chain algorithm, because it had less to
  do.  So let's keep it until we find something better.

24 December 2010

  Discovered a couple of problems with the layer matching.
  
  First, the search for a similar template layer was
  returning layers of tiny duration which did not give
  adequate choice.  Fixed this by requiring template
  layers to have maximum duration as a first priority.
  
  Second, the layer matching was not breaking down oversized
  supply nodes at the end of the construction, and as a result
  the Maths faculty meeting was being put into a ridiculously
  bad slot.  Fixed this now.  Here is best of 1:

    KheGeneralSolve at end (17.04 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 11.0685)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 5        8.0000
    AvoidSplitAssignmentsMonitor         52        0.0610
    SpreadEventsMonitor                  35        0.0035
    AvoidClashesMonitor                   2        2.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                18        0.0040
    -----------------------------------------------------
    Total                               113       11.0685

  and here is best of 16:

    14.0000 | *
    13.0000 | 
    12.0000 | *****
    11.0000 M ******
    10.0000 | 
     9.0000 | **
     8.0000 | *
     7.0000 | 
     6.0000 | *

    Soln (instance "BGHS98", diversifier 3, cost 6.0602)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 4        6.0000
    AvoidSplitAssignmentsMonitor         45        0.0530
    SpreadEventsMonitor                  18        0.0018
    LimitBusyTimesMonitor                24        0.0054
    -----------------------------------------------------
    Total                                91        6.0602

  Funny, it's worse with a much worse median.  Regularity in
  Year 10 is *still* a problem, and needs looking into.

     Slack cost         Best of 1         Best of 16
     -----------------------------------------------
     KheCost(0, 0)      11.0673            8.0581
     KheCost(1, 0)      11.0685            6.0602
     KheCost(2, 0)      17.0650            8.0622
     KheCost(3, 0)      16.0496            8.0628
     -----------------------------------------------

  So once again we conclude that KheCost(1, 0) is best.

24 December 2010

  Trying to track down the cause of the poor node regularity in
  Year 9.  Discovered that the forced node test did not take
  account of slack, so changed it so it did.  In theory this
  should give fewer forced nodes and more chances to the good
  node regularity.   Best of 1:

    KheGeneralSolve at end (14.84 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 12.0689)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 5        8.0000
    AvoidSplitAssignmentsMonitor         53        0.0600
    SpreadEventsMonitor                  29        0.0029
    AvoidClashesMonitor                   4        4.0000
    LimitBusyTimesMonitor                22        0.0060
    -----------------------------------------------------
    Total                               113       12.0689

  Best of 16:

    15.0000 | *
    14.0000 | **
    13.0000 | **
    12.0000 | **
    11.0000 M **
    10.0000 | *
     9.0000 | **
     8.0000 | *
     7.0000 | *
     6.0000 | 
     5.0000 | 
     4.0000 | **

    Soln (instance "BGHS98", diversifier 3, cost 4.0606)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        4.0000
    AvoidSplitAssignmentsMonitor         46        0.0520
    SpreadEventsMonitor                  34        0.0034
    LimitBusyTimesMonitor                21        0.0052
    -----------------------------------------------------
    Total                               104        4.0606

  Same median, but 4.0606 is a new best.  It is probably an
  outlier, and it is not node-regular at all, but the change makes
  sense so I'll keep it and keep trying to improve node regularity.

  Tried using the first layer repeatedly as template layer, got this:

    17.0000 | **
    16.0000 | 
    15.0000 | 
    14.0000 | 
    13.0000 | **
    12.0000 | ***
    11.0000 | 
    10.0000 M *
     9.0000 M **
     8.0000 | ***
     7.0000 | *
     6.0000 | **

    Soln (instance "BGHS98", diversifier 10, cost 6.0554)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 2        3.0000
    AvoidSplitAssignmentsMonitor         40        0.0480
    SpreadEventsMonitor                  20        0.0020
    AvoidClashesMonitor                   2        2.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                23        0.0054
    -----------------------------------------------------
    Total                                88        6.0554

  Slightly better median, signficantly better soft constraints,
  but not really better overall.

  I think we need more bias towards node regularity.  The KTS
  solution is very node-regular, and it must have been done
  at a cost; then small adjustments pare the cost back again.

  Tried handling Maths first when improving node regularity
  (i.e. nodes with fewer child nodes first, on the grounds
  that these will be harder to repair later).  Best of 16
  when using the first layer as template layer throughout was

    10.0000 | *
     9.0000 | ***
     8.0000 M ******
     7.0000 | ****
     6.0000 | 
     5.0000 | **

    Soln (instance "BGHS98", diversifier 5, cost 5.0733)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        4.0000
    AvoidSplitAssignmentsMonitor         51        0.0630
    SpreadEventsMonitor                  50        0.0051
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                23        0.0052
    -----------------------------------------------------
    Total                               128        5.0733

  There may be some repetition in these solutions.

    16.0000 | *
    15.0000 | **
    14.0000 | **
    13.0000 | *
    12.0000 M **
    11.0000 M ***
    10.0000 | *
     9.0000 | **
     8.0000 | **

    Soln (instance "BGHS98", diversifier 15, cost 8.0592)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 2        2.0000
    AvoidSplitAssignmentsMonitor         46        0.0520
    SpreadEventsMonitor                  34        0.0034
    AvoidClashesMonitor                   2        3.0000
    AvoidUnavailableTimesMonitor          1        3.0000
    LimitBusyTimesMonitor                18        0.0038
    -----------------------------------------------------
    Total                               103        8.0592

  although the soft constraints are better.

  All these results are promising, but still there is not enough
  node regularity.  Something more radical is needed.

  The problem with Yr9 Science is that it is a runaround with
  shape 2 1 1 1 1 and thus is not regular with the other
  nodes of duration 6, whose shape is 2 2 1 1.  Is there some
  way we can change the shape of Yr 9 Science when building
  its runaround?

27 December 2010

  Working on building runarounds to conform to a node
  template.  Have got the template down to the runaround
  building function, now have to use it.  Have decided
  that transactions will be needed, and prepared for that.

28 December 2010

  Got the revised runaround builder to work, but now the time
  solver it uses is not up to the job of finding a timetable
  for the runaround.  Need to use layer solving for that, but
  layer solving currently assumes that the parent node is the
  root node.
  
  Improved KheLayerMatchMake so that it always succeeds, even
  when the matching is incomplete.  The invariant is now that
  the incompleteness must not get worse.

  Things to do:

  * Revise khe_layer_time.c so that it does not assume that
    its parent node is the cycle node, and to improve it
    generally.  Assigning the first layer should be done the 
    same way as assigning the others (with a layer matching),
    except that we need parallel assignments first and a
    repair afterwards.

    I've documented what I want it to do in the "Layer time
    assignment" section of the time solvers chapter.  Have
    to make the implementation conform to this.

    It might be worth offering the two major sub-parts,
    parallel assignments and single-layer repair, as public
    functions.  At least this will tighten up the documentation.

  * Need to think more about preassignments.  Do we need
    some way to reduce the domains of meets lying in
    interior nodes, so that their children can be assigned
    to them?  Do we need some operation to keep the whole
    layer tree consistent in this respect?  What does
    KheLayerTreeMake do about this?

  * Use the improved layer solver when building runarounds,
    and thus return to the problem which inspired all this:
    the Year 9 Science/Music runaround in BGHS98.

29 December 2010

  Revised khe_layer_time.c today, all implemented and tested.
  Using the "drastic" option:

    24.0000 | *
    23.0000 | ***
    22.0000 | 
    21.0000 | 
    20.0000 | *
    19.0000 M ***
    18.0000 M ***
    17.0000 | 
    16.0000 | 
    15.0000 | 
    14.0000 | **
    13.0000 | *
    12.0000 | *
    11.0000 | *

    Soln (instance "BGHS98", diversifier 4, cost 11.0776)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 7        8.0000
    AvoidSplitAssignmentsMonitor         57        0.0690
    SpreadEventsMonitor                  34        0.0034
    AvoidClashesMonitor                   3        3.0000
    LimitBusyTimesMonitor                24        0.0052
    -----------------------------------------------------
    Total                               125       11.0776

  Without the "drastic" option:

    16.0000 | ****
    15.0000 | 
    14.0000 | *
    13.0000 | 
    12.0000 | *
    11.0000 M ***
    10.0000 | ****
     9.0000 | **
     8.0000 | 
     7.0000 | 
     6.0000 | *

    Soln (instance "BGHS98", diversifier 10, cost 6.0536)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        4.0000
    AvoidSplitAssignmentsMonitor         44        0.0470
    SpreadEventsMonitor                  24        0.0024
    AvoidClashesMonitor                   1        2.0000
    LimitBusyTimesMonitor                20        0.0042
    -----------------------------------------------------
    Total                                92        6.0536

  Using the layer solver to build runarounds seems to be worse:

    19.0000 | ***
    18.0000 | 
    17.0000 | 
    16.0000 | 
    15.0000 | 
    14.0000 | *
    13.0000 | **
    12.0000 M ***
    11.0000 | ***
    10.0000 | **
     9.0000 | *
     8.0000 | *

    Soln (instance "BGHS98", diversifier 15, cost 8.0704)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 5        6.0000
    AvoidSplitAssignmentsMonitor         51        0.0610
    SpreadEventsMonitor                  42        0.0042
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                24        0.0052
    -----------------------------------------------------
    Total                               123        8.0704

  Needs looking into.  Spent some time writing a timetable
  printer for nodes, looks quite nice, and will help to
  show at a glance when things have gone wrong there.

  Still to do: revise the part of KheNodeChildLayersAssignTimes
  that does the repairing.  It is not au fait with the new,
  more general spec (arbitrary parent node) at the moment,
  and that is presumably why we are getting some clashes
  in the preassigned student group resources.

30 December 2010

  Finally got to apply the general time assignment algorithm
  to runarounds, and was gratified to see the Year 9 Science
  Music runaround perfectly aligned.  But Year 9 still does
  not align fully, probably because of the limited choices
  for PE (needs a re-check, but it was true before).

  Best of 1:

    Soln (instance "BGHS98", diversifier 0, cost 8.0617)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 5        6.0000
    AvoidSplitAssignmentsMonitor         45        0.0530
    SpreadEventsMonitor                  31        0.0031
    AvoidClashesMonitor                   1        1.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                24        0.0056
    -----------------------------------------------------
    Total                               107        8.0617

  Best of 16:

    12.0000 | *
    11.0000 | *
    10.0000 | *
     9.0000 | *
     8.0000 M ****
     7.0000 M ***
     6.0000 | *****

    Soln (instance "BGHS98", diversifier 2, cost 6.0592)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 2        2.0000
    AvoidSplitAssignmentsMonitor         46        0.0520
    SpreadEventsMonitor                  24        0.0024
    AvoidClashesMonitor                   2        2.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                20        0.0048
    -----------------------------------------------------
    Total                                95        6.0592

  A pretty good result, and pretty robust, too.  The best
  of 16 with the "drastic" flag set was 10.0530 with a
  median of 15, so I'm abandoning the drastic flag now.
  Funny, I got this this time:

    12.0000 | *
    11.0000 | ****
    10.0000 | *
     9.0000 | *
     8.0000 M ***
     7.0000 | *
     6.0000 | *****

    Soln (instance "BGHS98", diversifier 2, cost 6.0592)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 2        2.0000
    AvoidSplitAssignmentsMonitor         46        0.0520
    SpreadEventsMonitor                  24        0.0024
    AvoidClashesMonitor                   2        2.0000
    AvoidUnavailableTimesMonitor          1        2.0000
    LimitBusyTimesMonitor                20        0.0048
    -----------------------------------------------------
    Total                                95        6.0592

  I think this is the result of changing the workload
  limit evaluation function slightly to make it less
  susceptible to roundoff error problems.

  Added categories to the layer match, and observed an
  improved Year 9 Science/Music runaround, and an improved
  top-level time assignment.  Very cheap, very good.

  Best of 1:

    KheGeneralSolve at end (11.74 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 7.0633)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        4.0000
    AvoidSplitAssignmentsMonitor         48        0.0570
    SpreadEventsMonitor                  15        0.0015
    AvoidClashesMonitor                   2        3.0000
    LimitBusyTimesMonitor                22        0.0048
    -----------------------------------------------------
    Total                                90        7.0633

  Best of 16:

    17.0000 | *
    16.0000 | 
    15.0000 | *
    14.0000 | 
    13.0000 | *
    12.0000 | *
    11.0000 | ***
    10.0000 M **
     9.0000 | **
     8.0000 | *
     7.0000 | ***
     6.0000 | *

    Soln (instance "BGHS98", diversifier 11, cost 6.0793)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 6        6.0000
    AvoidSplitAssignmentsMonitor         62        0.0730
    SpreadEventsMonitor                  19        0.0019
    LimitBusyTimesMonitor                18        0.0044
    -----------------------------------------------------
    Total                               105        6.0793

  Funny, it turned out worse, perhaps it is over-weighting
  spread.  But I think I'll stick with it on principle.  If
  we don't refresh the template layer, we get this:

    14.0000 | **
    13.0000 | 
    12.0000 | ****
    11.0000 | *
    10.0000 M *
     9.0000 M *****
     8.0000 | *
     7.0000 | **

    Soln (instance "BGHS98", diversifier 5, cost 7.0554)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 1        1.0000
    AvoidSplitAssignmentsMonitor         40        0.0460
    SpreadEventsMonitor                  58        0.0058
    AvoidClashesMonitor                   3        5.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                16        0.0036
    -----------------------------------------------------
    Total                               119        7.0554

  The hard costs are much the same, but split assignments
  are better and spread is worse.  We still haven't struck
  at the heart of the problem:  inadequate node regularity.

31 December 2010

  Here's an idea for improving the time assignment of a layer
  without disturbing its node regularity:  permute the meets
  within each template layer to minimize solution cost.  Even
  swaps might work well.

  Spent the morning re-doing the layer matching module to add
  supply node groups.  They make a better model, and I thought
  they were needed for repairing, but it turns out that it is
  best to do repairing quite separately from the layer matching.
  There was a slight change in function, and the best of 16 now
  costs 6.0634, although the best of one is quite poor at 17.0650.

  Made a start on the idea above, have built the correct
  neighbourhoods, now I only need to delete duds and I'm
  ready to start swapping.

  Best of 1 without template layer repair:

    KheGeneralSolve at end (13.88 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 17.0650)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                10       14.0000
    AvoidSplitAssignmentsMonitor         49        0.0550
    SpreadEventsMonitor                  58        0.0058
    AvoidClashesMonitor                   3        3.0000
    LimitBusyTimesMonitor                17        0.0042
    -----------------------------------------------------
    Total                               137       17.0650

  Best of 16 without template layer repair:

    18.0000 | **
    17.0000 | *
    16.0000 | 
    15.0000 | 
    14.0000 | *
    13.0000 | *
    12.0000 | *
    11.0000 | 
    10.0000 M ****
     9.0000 | **
     8.0000 | **
     7.0000 | 
     6.0000 | **

    Soln (instance "BGHS98", diversifier 8, cost 6.0634)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        4.0000
    AvoidSplitAssignmentsMonitor         43        0.0550
    SpreadEventsMonitor                  30        0.0030
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                22        0.0054
    -----------------------------------------------------
    Total                               100        6.0634

  Best of 1 with template layer repair:

    KheGeneralSolve at end (11.78 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 10.0725)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        3.0000
    AvoidSplitAssignmentsMonitor         49        0.0610
    SpreadEventsMonitor                  59        0.0059
    AvoidClashesMonitor                   4        4.0000
    AvoidUnavailableTimesMonitor          1        3.0000
    LimitBusyTimesMonitor                25        0.0056
    -----------------------------------------------------
    Total                               141       10.0725

  Best of 16 with template layer repair:

    14.0000 | **
    13.0000 | ***
    12.0000 | *
    11.0000 | *
    10.0000 M ****
     9.0000 | **
     8.0000 | *
     7.0000 | **

    Soln (instance "BGHS98", diversifier 3, cost 7.0675)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 5        6.0000
    AvoidSplitAssignmentsMonitor         49        0.0560
    SpreadEventsMonitor                  51        0.0051
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                26        0.0064
    -----------------------------------------------------
    Total                               132        7.0675

  Not much in it: faster, but arguably slightly worse.  Once
  again, we aren't getting at the real issues yet.

  There seems to be a bug in KheLayerNodeMatchingRepairTimes,
  in that I have evidence that it does not preserve node
  regularity, as it should.

1 January 2011

  Sorted out the problem with KheLayerNodeMatchingRepairTimes.
  Actually it wasn't a bug; the problem is that it happens to
  take us down an inferior path, that's all.  I did add a
  transaction to make sure it changed things only when the
  overall solution cost decreases.  Best of 1 now is:

    KheGeneralSolve at end (17.13 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 16.0704)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                10       12.0000
    AvoidSplitAssignmentsMonitor         54        0.0620
    SpreadEventsMonitor                  24        0.0024
    AvoidClashesMonitor                   4        4.0000
    LimitBusyTimesMonitor                25        0.0060
    -----------------------------------------------------
    Total                               117       16.0704

  Best of 16 is:

    16.0000 | **
    15.0000 | *
    14.0000 | *
    13.0000 | ***
    12.0000 M *
    11.0000 M *
    10.0000 | *
     9.0000 | ***
     8.0000 | ***

    Soln (instance "BGHS98", diversifier 2, cost 8.0554)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        5.0000
    AvoidSplitAssignmentsMonitor         45        0.0510
    SpreadEventsMonitor                   8        0.0008
    AvoidClashesMonitor                   1        1.0000
    AvoidUnavailableTimesMonitor          2        2.0000
    LimitBusyTimesMonitor                16        0.0036
    -----------------------------------------------------
    Total                                75        8.0554
  
  So things have decaysed a bit, although spread is great,
  so let's keep all these things at least for now.  But,
  once again, the problem is our old friend: inadquate
  node regularity.

  Tried again with drastic flag in layer match.  Best of 1
  had cost 25.0848, best of 16 had cost

    25.0000 | ***
    24.0000 | 
    23.0000 | 
    22.0000 | 
    21.0000 | 
    20.0000 | **
    19.0000 | 
    18.0000 | 
    17.0000 | 
    16.0000 | 
    15.0000 | 
    14.0000 | 
    13.0000 | 
    12.0000 | 
    11.0000 M ***
    10.0000 M **
     9.0000 | 
     8.0000 | 
     7.0000 | 
     6.0000 | ******

    Soln (instance "BGHS98", diversifier 1, cost 6.0498)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        5.0000
    AvoidSplitAssignmentsMonitor         41        0.0420
    SpreadEventsMonitor                  16        0.0016
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                25        0.0062
    -----------------------------------------------------
    Total                                86        6.0498

  This is probably the best so far on soft cost.  But the
  spread of results is quite alarming.  Obviously need to
  do something along these lines, only smarter.  And this
  very good result is still not node-regular.

  Observed the solution cost layer by layer.  Up to the
  end of Year 10 it is perfect (no defects at all).  A
  layer-by-layer repair, initially open only to the layer
  affected, seems like the go.  Have to flatten though.
  Drastic, flatten, repair that layer only, continue.
  Also have the ejection chain node repair to try.

  Tooling up for ejection chain node repair.  Wrote functions
  for meet swapping and for sorting meets within nodes.  Wrote
  KheNodeDemandAugment, like KheDemandAugment but it swaps nodes
  rather than moving meets.  I may not bother with a similar thing
  for event defects.  KheGroupOrdinaryDemandMonitorsByChildNode
  done.  Working on KheNodeMeetSwapRepairTimes in khe_assign_time.c.
  With all these helpers done, it just needs putting together now.
  
  NB ejection chain node repair is probably best with the
  drastic flag or something like it, since otherwise the
  horse has bolted before it gets called.

2 January 2011

  Working on a reorganization of the grouping helper functions.
  Have done the event group monitors, event resource group
  monitors, and resource group monitors so far, and just started
  demand group monitors (see still to do in khe_grouping.c).

3 January 2011

  Finished off monitor grouping today.  I just have to change
  the calls to grouping functions in the rest of KHE from the
  old interfaces to the new ones, and add the node grouping
  one that sparked this two-day reorganization, and then I
  will be ready for node repair.

4 January 2011

  Completed the grouping reorganization, and finished off
  KheNodeMeetSwapRepairTimes as well.  Here are the result
  of a competition between KheLayerNodeMatchingRepairTimes
  and KheNodeMeetSwapRepairTimes.  Both are called at the
  same points, potentially (after each layer is assigned,
  for example), and they do much the same thing.  If we
  use KheLayerNodeMatchingRepairTimes only, we get this:

  Best of 1:

    KheGeneralSolve at end (15.07 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 13.0657)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 8       12.0000
    AvoidSplitAssignmentsMonitor         47        0.0560
    SpreadEventsMonitor                  29        0.0031
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                25        0.0066
    -----------------------------------------------------
    Total                               110       13.0657

  Best of 16:

    19.0000 | *
    18.0000 | 
    17.0000 | 
    16.0000 | 
    15.0000 | 
    14.0000 | 
    13.0000 | **
    12.0000 M *****
    11.0000 M *
    10.0000 | *
     9.0000 | ****
     8.0000 | 
     7.0000 | 
     6.0000 | *
     5.0000 | 
     4.0000 | 
     3.0000 | 
     2.0000 | *

    Soln (instance "BGHS98", diversifier 3, cost 2.0791)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 2        2.0000
    AvoidSplitAssignmentsMonitor         56        0.0660
    SpreadEventsMonitor                  75        0.0075
    LimitBusyTimesMonitor                23        0.0056
    -----------------------------------------------------
    Total                               156        2.0791

  Wow!  If we use KheNodeMeetSwapRepairTimes instead of
  KheLayerNodeMatchingRepairTimes we get this:

  Best of 1:

    KheGeneralSolve at end (16.10 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 10.0632)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 6        9.0000
    AvoidSplitAssignmentsMonitor         37        0.0510
    SpreadEventsMonitor                  76        0.0076
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                21        0.0046
    -----------------------------------------------------
    Total                               141       10.0632

  Best of 16:

      17.0000 | *
      16.0000 | 
      15.0000 | *
      14.0000 | *
      13.0000 | **
      12.0000 | 
      11.0000 | *
      10.0000 M ****
       9.0000 | *
       8.0000 | ***
       7.0000 | *
       6.0000 | 
       5.0000 | 
       4.0000 | 
       3.0000 | *

    Soln (instance "BGHS98", diversifier 10, cost 3.0664)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        3.0000
    AvoidSplitAssignmentsMonitor         45        0.0540
    SpreadEventsMonitor                  63        0.0070
    LimitBusyTimesMonitor                23        0.0054
    -----------------------------------------------------
    Total                               134        3.0664

  This is pretty darn good too.  However, for the moment
  we will stick with KheLayerNodeMatchingRepairTimes, and
  the best so far result of 2.0791, although admittedly
  the second best result is quite a long way above that,
  and *still* we don't have good node regularity.

  Tried for better node regularity by repairing meets
  first with 0, then with 1, etc., a kind of global
  interative deepening.  Best of 1:

    KheGeneralSolve at end (17.13 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 14.0532)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 9       12.0000
    AvoidSplitAssignmentsMonitor         40        0.0440
    SpreadEventsMonitor                  34        0.0034
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                24        0.0058
    -----------------------------------------------------
    Total                               109       14.0532

  Best of 16:

    15.0000 | *
    14.0000 | *
    13.0000 | **
    12.0000 | *
    11.0000 | **
    10.0000 M ***
     9.0000 | 
     8.0000 | *
     7.0000 | *
     6.0000 | *
     5.0000 | ***

    Soln (instance "BGHS98", diversifier 10, cost 5.0647)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        4.0000
    AvoidSplitAssignmentsMonitor         50        0.0550
    SpreadEventsMonitor                  39        0.0039
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                26        0.0058
    -----------------------------------------------------
    Total                               119        5.0647

  Not wonderful by comparison with what we had before, not
  even in the split assignments department that we were
  supposed to be improving.  The result does look a bit more
  node-regular, but not much more.

  Turning on the drastic flag gives similar uninspiring results.
  It's time to go for the heart of the problem.  I've turned off
  KheEjectionChainRepairTimes, and I've set the drastic flag in
  KheLayerMatchMake and in KheLayerMatchImproveNodeRegularity to
  be true when we are at the overall root node.  And they are
  both staying that way until I get good node regularity!

  Found a glitch in the way KheLayerMatchMake works which
  occasionally prevents it from splitting supply nodes in
  the same way as the template layer, because the order in
  which things get split affects the feasibility of other
  splits, in a curious way.  Have to do something about it.

5 January 2011

  Encourage the layer matching to split large supply nodes
  before small ones.

  Have revised the documentation of layer matching, including
  being explicit about the priorities of its various aims, and
  revised its implementation.  Also revised the way it is called
  (from KheNodeChildLayersAssignTimes) and documented that.
  Time to test.

6 January 2011

  Tested revised layer match.  It did everything I wanted,
  first time.  Now have perfect node regularity in years
  12, 11, 10, and 9, which is probably enough, at least
  for this time around.  Year 8 is very irregular anyway.

  We're staying with drastic.  After turning on repair,
  got this for best of 1:

    KheGeneralSolve at end (11.01 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 14.0555)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                10       14.0000
    AvoidSplitAssignmentsMonitor         39        0.0440
    SpreadEventsMonitor                  39        0.0039
    LimitBusyTimesMonitor                26        0.0076
    -----------------------------------------------------
    Total                               114       14.0555

  and this for best of 16:

    16.0000 | **
    15.0000 | **
    14.0000 | **
    13.0000 | 
    12.0000 | *
    11.0000 | 
    10.0000 | 
     9.0000 M ***
     8.0000 | *
     7.0000 | **
     6.0000 | *
     5.0000 | **

    Soln (instance "BGHS98", diversifier 10, cost 5.0612)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 2        3.0000
    AvoidSplitAssignmentsMonitor         44        0.0530
    SpreadEventsMonitor                  18        0.0018
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                28        0.0064
    -----------------------------------------------------
    Total                                94        5.0612
  
  The repair caused a truly massive loss of node regularity,
  but at least this shows that we can get from a node regular
  solution to one with few hard constraint violations, which
  suggests we are on the right track.  Just need to find a
  way to do it with less disruption to node regularity.  It's
  slow with repair though: 39 seconds.  We need to repair
  layer by layer, I believe.

  There is one demand defect after Year 10 is assigned (an Arabic
  teacher) and 35 after Year 9 is assigned.  Here are the 35 defects:

    [ "x9_PD_3_1"d2.1$Mon7-Mon8+0:Teacher_PDHPEYr7_10 ]
    [ "x9_PD_2_1"d2.1$Mon7-Mon8+1:Teacher_PDHPEYr7_10 ]
    [ "x9_PD_4_1"d2.1$Mon7-Mon8+1:Teacher_PDHPEYr7_10 ]
    [ "x9_PD_5_1"d2.1$Mon7-Mon8+1:Teacher_PDHPEYr7_10 ]
    [ "x9_PD_4_1"d2.1$Mon7-Mon8+0:Teacher_PDHPEYr7_10 ]
    [ "x9_PD_3_1"d2.1$Mon7-Mon8+1:Teacher_PDHPEYr7_10 ]
    [ "x9_PD_2_1"d2.1$Mon7-Mon8+0:Teacher_PDHPEYr7_10 ]
    [ "x9_PD_1_1"d2.1$Mon7-Mon8+0:Teacher_PDHPEYr7_10 ]
    [ "x9_PD_1_1"d2.1$Mon7-Mon8+1:Teacher_PDHPEYr7_10 ]
    [ "x9_PD_5_1"d2.1$Mon7-Mon8+0:Teacher_PDHPEYr7_10 ]

    [ "x12_2_Biology_1":1d2.1$Mon1-Mon2+1:Room_ScienceLab ]
    [ "x12_2_Biology_1":3d1.1$Wed1+0:Room_ScienceLab ]
    [ "x12_2_GeneralScience_1_1":3d1.1$Wed1+0:Room_ScienceLab ]
    [ "x12_2_Biology_1":2d2.1$Fri1-Fri2+1:Room_ScienceLab ]
    [ "x12_2_GeneralScience_1_1":2d2.1$Fri1-Fri2+1:Room_ScienceLab ]
    [ "x12_2_Biology_1":2d2.1$Fri1-Fri2+0:Room_ScienceLab ]
    [ "x12_2_GeneralScience_1_1":2d2.1$Fri1-Fri2+0:Room_ScienceLab ]

    [ "x12_5_ComputingStudies_1":1d2.1$Tue1-Tue2+1:Room_ComputerRoom ]
    [ "x9_5ComputingStudies_1":0d1.1$Thu2+0:Room_ComputerRoom ]
    [ "x9_5ComputingStudies_1":1d2.1$Fri4-Fri5+1:Room_ComputerRoom ]
    [ "x9_5ComputingStudies_1":2d1.1$Mon6+0:Room_ComputerRoom ]
    [ "x12_5_CS_Applic_1":0d1.1$Mon5+0:Room_ComputerRoom ]
    [ "x9_5ComputingStudies_1":1d2.1$Fri4-Fri5+0:Room_ComputerRoom ]
    [ "x12_5_ComputingStudies_1":0d1.1$Mon5+0:Room_ComputerRoom ]
    [ "x12_5_CS_Applic_1":1d2.1$Tue1-Tue2+1:Room_ComputerRoom ]

    [ "x9_5_Drama_1":2d1.0$Mon6+0:Teacher_DramaYr7_10 ]
    [ "x12_2_Biology_1":3d1.0$Wed1+0:Teacher_Biology ]
    [ "x9_5_Drama_1":1d2.0$Fri4-Fri5+0:Teacher_DramaYr7_10 ]
    [ "x9_5_Drama_1":0d1.0$Thu2+0:Teacher_DramaYr7_10 ]
    [ "x10_5_Arabic_1_1":0d1.0$Wed2+0:Teacher_ArabicYr7_10 ]
    [ "x12_2_Biology_1":2d2.0$Fri1-Fri2+0:Teacher_Biology ]
    [ "x12_2_Biology_1":2d2.0$Fri1-Fri2+1:Teacher_Biology ]
    [ "x9_5_Drama_1":1d2.0$Fri4-Fri5+1:Teacher_DramaYr7_10 ]
    [ "x9_7_Arabic_1_1":0d1.0$Wed3+0:Teacher_ArabicYr7_10 ]  (* from Year 10 *)
    [ "x12_5_CS_Applic_1":1d2.0$Tue1-Tue2+1:{TAS01..TAS07} ]

  Apart from the obvious problem of aligning Year 10 and Year 9
  PDHPE, which accounts for 10 defects, we are two Science labs
  down at Wed1, Fri1, and Fri2, as well as one Science teacher,
  one computing lab down at various times, one Drama teacher
  down at various times, plus a few odds and ends.

  NB there are two Teacher_DramaYr7_10 teachers, but one of them
  is forced into Year 11-12 drama at 3x6 times (12_2, 11_2, 11_5)
  The Year7-10 drama demand is 4x4 (9_5, 9_6, 10_6, 10_7).

  Result appeared inferior in Years 12-9, found out that this was because
  of feedback from Years8-7 in KheLayerNodeMatchingNodeRepairTimes, so
  added KheLayerNodeMatchingLayerRepairTimes to confine the changes to
  the current year, and got this when repair is added (best of 1):

    KheGeneralSolve at end (10.75 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 7.0671)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 5        6.0000
    AvoidSplitAssignmentsMonitor         48        0.0560
    SpreadEventsMonitor                  64        0.0065
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                19        0.0046
    -----------------------------------------------------
    Total                               137        7.0671

  and this for best of 16: 

    19.0000 | *
    18.0000 | 
    17.0000 | *
    16.0000 | *
    15.0000 | *
    14.0000 | *
    13.0000 | *
    12.0000 | *
    11.0000 M *
    10.0000 M ***
     9.0000 | *
     8.0000 | **
     7.0000 | *
     6.0000 | *

    Soln (instance "BGHS98", diversifier 10, cost 6.0730)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 4        5.0000
    AvoidSplitAssignmentsMonitor         47        0.0610
    SpreadEventsMonitor                  54        0.0054
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                28        0.0066
    -----------------------------------------------------
    Total                               134        6.0730

  which is not wonderful.  But, as usual, the repair is
  making hay of the node regularity.

  What we really need before we can go further is a node
  regular assignment of years 12-9 that has *many* fewer
  than the 35 demand defects listed above.  At present,
  everything else is pretty good, just one spread defect.

  One simple thing which reduces the number to just 5
  (3 Science labs and 2 Arabic teachers) is to re-use
  the first layer as the template layer throughout.
  Doing this and adding repair gives this best of 1:

    KheGeneralSolve at end (10.39 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 10.0568)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 6        8.0000
    AvoidSplitAssignmentsMonitor         43        0.0500
    SpreadEventsMonitor                  17        0.0018
    AvoidClashesMonitor                   2        2.0000
    LimitBusyTimesMonitor                24        0.0050
    -----------------------------------------------------
    Total                                92       10.0568

  and this best of 16:

    24.0000 | *
    23.0000 | 
    22.0000 | 
    21.0000 | 
    20.0000 | 
    19.0000 | 
    18.0000 | 
    17.0000 | 
    16.0000 | *
    15.0000 | 
    14.0000 | 
    13.0000 | *
    12.0000 | *
    11.0000 | 
    10.0000 M *****
     9.0000 | ***
     8.0000 | 
     7.0000 | ****

    Soln (instance "BGHS98", diversifier 11, cost 7.0401)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 4        6.0000
    AvoidSplitAssignmentsMonitor         30        0.0340
    SpreadEventsMonitor                  17        0.0017
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                21        0.0044
    -----------------------------------------------------
    Total                                73        7.0401

  Not a great result on hard constraints, but easily the best
  so far on split assignments (KTS did no better); perhaps we
  should go this way.  Anyway, the result looks node-regular,
  confirming again the general principle that node regularity
  reduces split assignments.  But we need to do even better.

  What about blocking in the most regular events in all layers
  and then timetabling the irregular ones around them?

  Gone back to refreshing template layers and not preferring
  node regularity over cost when improving node regularity, on
  the principle that I might be getting better node regularity
  now anyway from the other changes I made.  Best of 1:

    KheGeneralSolve at end (15.20 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 5.0528)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 4        4.0000
    AvoidSplitAssignmentsMonitor         43        0.0460
    SpreadEventsMonitor                  21        0.0022
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                22        0.0046
    -----------------------------------------------------
    Total                                91        5.0528

  Best of 16:

    11.0000 | **
    10.0000 | *
     9.0000 M *****
     8.0000 M **
     7.0000 | *
     6.0000 | **
     5.0000 | **
     4.0000 | 
     3.0000 | *

    Soln (instance "BGHS98", diversifier 6, cost 3.0691)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 2        2.0000
    AvoidSplitAssignmentsMonitor         50        0.0580
    SpreadEventsMonitor                  44        0.0045
    AvoidClashesMonitor                   1        1.0000
    LimitBusyTimesMonitor                29        0.0066
    -----------------------------------------------------
    Total                               126        3.0691

  Low total, but many split assignements due to the usual
  poor node regularity.

  Before pursuing this further I've decided to implement global
  time swaps, as yet another way to improve time assignments
  without loss of node regularity.  I've documented it and
  implemented and documented some new monitor grouping functions
  it needs.   Done quite a lot of the setting up, but struck
  a problem with the domains of the meets of the intermediate
  node I'm introducing.

8 January 2011

  Spent a couple of hours tracking down and fixing a bug that
  turned out to be in KheMeetSplit.  Grr.

  And now I've discovered that the design for handling time
  domains does not work correctly when meets are split, at
  least, not when there are preassigned times.  So there is
  a whole whack of stuff there to do that I will do later
  (done, see just below).

  Currently implementing KheTimeGroupReduceInternal in file
  khe_time_group.c, so that I can get maximal domains for
  the node swapper.

  Places where KheMeetSplit is called:

    KheNodeGlobalSwapRepairTimes to split the meets of the
    swap node, which at this point have singleton domains.

    KheLayerTreeMake() to ensure that all meets have durations
    which do not exceed the number of times in the instance.

    khe_split_class.c to split meets during layer tree
    construction.

  Places where KheMeetSetDomain is called:

    KheNodeGlobalSwapRepairTimes, to copy a domain.

    KheMinimumRunaroundDuration, to copy a domain.

    KheNodeMakeFromTemplate (KheTryRunaround), to copy a domain.

    KheSolnMakeCycleMeet, to set the domain of a cycle meet.

    khe_transaction.c, to undo and redo.

    khe_split_class.c, to set the domains of the newly split
    meets; these domains are complex results of applying
    jobs during KheLayerTreeMake.

  Worked out a whole new plan for meet domains (sigh) and am
  implementing it now.  Have basically finished the new module,
  khe_time_group_nhood.c, and now have to use it.

9 January 2011

  Completed the implementation of the new plan for meet domains,
  all documented and tested.  So can go back to the thing that
  sparked it off, global swaps, now.

  Is this part of the solution invariant or not?

  # If meet @C { meet } is preassigned time @M { t } (if it is
  # derived from an instance event which is preassigned time @M { t })
  # then the current time domain of @C { meet } is a subset of
  # @M { lbrace t rbrace };

10 January 2011

  It would be good to optimize KheSolnTimeGroupBegin etc. so
  that it only creates a new time group when it has to, i.e.
  when existing time groups don't do the job.

  Got KheNodeGlobalSwapRepairTimes working.  It found two
  repairs which together reduced soft cost from 53 to 46.
  The overall solution cost was reduced from this (best of 1):

    KheGeneralSolve at end (11.49 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 10.0753)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 7        7.0000
    AvoidSplitAssignmentsMonitor         54        0.0670
    SpreadEventsMonitor                  21        0.0021
    AvoidClashesMonitor                   3        3.0000
    LimitBusyTimesMonitor                27        0.0062
    -----------------------------------------------------
    Total                               112       10.0753

  and this (best of 16):

    14.0000 | ***
    13.0000 | *
    12.0000 | *
    11.0000 | **
    10.0000 M **
     9.0000 | ****
     8.0000 | 
     7.0000 | *
     6.0000 | *
     5.0000 | 
     4.0000 | *

    Average of 16 solutions           Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 6.4        7.0000
    AvoidSplitAssignmentsMonitor         48.1        0.0556
    SpreadEventsMonitor                  27.9        0.0028
    AvoidClashesMonitor                   1.8        2.0000
    AvoidUnavailableTimesMonitor          0.2        0.0000
    LimitBusyTimesMonitor                22.6        0.0052
    -------------------------------------------------------
    Total                               107.0        9.0636

    Soln (instance "BGHS98", diversifier 8, cost 4.0581)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 2        2.0000
    AvoidSplitAssignmentsMonitor         46        0.0490
    SpreadEventsMonitor                  41        0.0041
    AvoidClashesMonitor                   1        1.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                21        0.0050
    -----------------------------------------------------
    Total                               112        4.0581

  to this (best of 1):

    KheGeneralSolve at end (9.60 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 8.0585)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 6        6.0000
    AvoidSplitAssignmentsMonitor         44        0.0520
    SpreadEventsMonitor                  17        0.0017
    AvoidClashesMonitor                   1        2.0000
    LimitBusyTimesMonitor                23        0.0048
    -----------------------------------------------------
    Total                                91        8.0585

  and this (best of 16):

    14.0000 | *
    13.0000 | 
    12.0000 | ***
    11.0000 | *
    10.0000 | *
     9.0000 M ***
     8.0000 | ****
     7.0000 | *
     6.0000 | 
     5.0000 | **

    Average of 16 solutions           Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 5.9        7.0000
    AvoidSplitAssignmentsMonitor         46.4        0.0545
    SpreadEventsMonitor                  28.3        0.0028
    AvoidClashesMonitor                   1.2        1.0000
    AvoidUnavailableTimesMonitor          0.2        0.0000
    LimitBusyTimesMonitor                22.9        0.0051
    -------------------------------------------------------
    Total                               105.1        8.0624

    Soln (instance "BGHS98", diversifier 14, cost 5.0582)
    Soln                            Defects          Cost
    -----------------------------------------------------
    AssignResourceMonitor                 3        3.0000
    AvoidSplitAssignmentsMonitor         44        0.0520
    SpreadEventsMonitor                  20        0.0020
    AvoidClashesMonitor                   1        1.0000
    AvoidUnavailableTimesMonitor          1        1.0000
    LimitBusyTimesMonitor                20        0.0042
    -----------------------------------------------------
    Total                                89        5.0582

  Run times are faster and solutions are much the same.  They
  do look a bit more node-regular, although they are still not
  node-regular.  Back to the same problem:  node regularity.

  Tried global swaps at the end of each layer.  Best of 1:

    KheGeneralSolve at end (9.11 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 6.0562)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   5        5.0000
    AvoidSplitAssignmentsMonitor           46        0.0490
    SpreadEventsMonitor                    32        0.0032
    AvoidClashesMonitor                     1        1.0000
    LimitBusyTimesMonitor                  19        0.0040
    -------------------------------------------------------
    Total                                 103        6.0562

  Best of 16:

    20.0000 | *
    19.0000 | 
    18.0000 | 
    17.0000 | 
    16.0000 | 
    15.0000 | 
    14.0000 | *
    13.0000 | 
    12.0000 | **
    11.0000 | *
    10.0000 | **
     9.0000 M ***
     8.0000 | ***
     7.0000 | 
     6.0000 | ***

    Average of 16 solutions           Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 6.0        7.0000
    AvoidSplitAssignmentsMonitor         46.0        0.0526
    SpreadEventsMonitor                  34.6        0.0034
    AvoidClashesMonitor                   1.6        2.0000
    AvoidUnavailableTimesMonitor          0.2        0.0000
    LimitBusyTimesMonitor                20.8        0.0047
    -------------------------------------------------------
    Total                               109.1        9.0607

    Soln (instance "BGHS98", diversifier 6, cost 6.0550)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   5        5.0000
    AvoidSplitAssignmentsMonitor           46        0.0480
    SpreadEventsMonitor                    32        0.0032
    AvoidClashesMonitor                     1        1.0000
    LimitBusyTimesMonitor                  17        0.0038
    -------------------------------------------------------
    Total                                 101        6.0550

  No better really, not using it.

  Made the first step towards allowing multiple template
  layers, which is to support them but only actually use
  the first.  Next step is to make use of them.

11 January 2011

  Have changed khe_layer_match.c so that template nodes are stored
  in supply nodes and demand node groups indexed by template layer,
  and done a careful audit of this radically changed version.  The
  next step is to find better node regularity algorithms using the
  additional template layers.  I've implemented one simple algorithm,
  which is to try for an exact match with any node in any template
  layer, and after that fall back on the usual heuristic search.
  Need to test this algorithm now, then improve it.

  First test gave 20 demand defects at the end of the last layer,
  which is a good number, but the result was not very regular.
  With repair, best of 1 had cost 16.0564, best of 16 had cost
  5.0671, median 12, and there were only 6 distinct solutions,
  which seems odd.

  An improved first test gave 27 demand defects at the end of
  the last layer, which is not great but the result seems to
  be pretty regular (Year 9 English has a genuine problem in
  being regular, otherwise Year 9 looks pretty right).  With
  repair, best of 1 had cost 11.0625.  Best of 16 had cost
  3.0525, but it was a phenomenal outlier:

    14.0000 | *
    13.0000 | ****
    12.0000 | 
    11.0000 M ****
    10.0000 | *
     9.0000 | *
     8.0000 | ****
     7.0000 | 
     6.0000 | 
     5.0000 | 
     4.0000 | 
     3.0000 | *

    Average of 16 solutions           Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 6.4        8.0000
    AvoidSplitAssignmentsMonitor         45.5        0.0525
    SpreadEventsMonitor                  25.4        0.0025
    AvoidClashesMonitor                   1.1        1.0000
    AvoidUnavailableTimesMonitor          0.4        0.0000
    LimitBusyTimesMonitor                23.3        0.0055
    -------------------------------------------------------
    Total                               102.1        9.0605

    Soln (instance "BGHS98", diversifier 11, cost 3.0525)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   1        1.0000
    AvoidSplitAssignmentsMonitor           41        0.0450
    SpreadEventsMonitor                    24        0.0025
    AvoidClashesMonitor                     2        2.0000
    LimitBusyTimesMonitor                  20        0.0050
    -------------------------------------------------------
    Total                                  88        3.0525

  As usual the good node regularity before repair was lost.
  After more fiddling, here are some more experiments:

     Slack cost         Best of 1         Best of 16
     -----------------------------------------------
     KheCost(0, 0)      10.0685             4.0593
     KheCost(1, 0)       9.0651             3.0525 (outlier)
     KheCost(2, 0)      17.0595             7.0609
     KheCost(3, 0)      11.0666             3.0545
     -----------------------------------------------

  We'll stick with KheCost(1, 0) as usual, but more work is
  needed auditing the effectiveness of the new layer match
  node regularity algorithm.

  * At present Year 9 has 6 demand defects (one inherited
    from Year 10).  If we can spread the Year 9 Science/Music
    runaround out more we can remove 2 of these 6 defects.

  * The problem with Year 9 English is genuine, but it would
    be good to fix it without relying on diversification.
    Could we do a maximum matching (unweighted, perhaps) of
    the nodes of maximum duration, rather than heuristically
    fixing the first?  Or of all sets of similar nodes?

  If we could fix both of these problems, then Year 9 would
  probably be good enough, and that would probably do for
  the initial time assignment.  Then need to make the time
  repair algorithm less regularity-destroying.

12 January 2011

  Decided I needed a specialized runaround time solver, otherwise
  I will never be sure of getting neat runarounds.  Have documented
  a design for such a solver and built the infrastructure for it
  (khe_runaround_time.c); currently it is compiled and running and 
  builds the solver object that is needed, ready to implement the
  actual algorithm.

13 January 2011

  Implemented and tested the runaround time solver.  It's working
  but the iterator needs to be changed so that it preferably
  visits each parent meet just once, at an offset that depends
  on the shift.  At present we aren't getting enough variety
  within each parent meet.

15 January 2011

  Finally got the runaround solver working well.  Best of 1:

    Soln (instance "BGHS98", diversifier 0, cost 9.0650)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   5        7.0000
    AvoidSplitAssignmentsMonitor           52        0.0580
    SpreadEventsMonitor                    18        0.0018
    AvoidClashesMonitor                     2        2.0000
    LimitBusyTimesMonitor                  21        0.0052
    -------------------------------------------------------
    Total                                  98        9.0650

  Best of 16:

    14.0000 | **
    13.0000 | 
    12.0000 | 
    11.0000 | **
    10.0000 M *******
     9.0000 | *
     8.0000 | *
     7.0000 | **
     6.0000 | *

    Average of 16 solutions           Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 5.0        7.0000
    AvoidSplitAssignmentsMonitor         46.8        0.0531
    SpreadEventsMonitor                  23.9        0.0023
    AvoidClashesMonitor                   2.1        2.0000
    AvoidUnavailableTimesMonitor          0.4        0.0000
    LimitBusyTimesMonitor                23.2        0.0054
    -------------------------------------------------------
    Total                               101.3        9.0608

    Soln (instance "BGHS98", diversifier 11, cost 6.0645)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   4        4.0000
    AvoidSplitAssignmentsMonitor           46        0.0580
    SpreadEventsMonitor                    11        0.0011
    AvoidClashesMonitor                     2        2.0000
    LimitBusyTimesMonitor                  21        0.0054
    -------------------------------------------------------
    Total                                  84        6.0645

  Not great, but still it's right to have decent runarounds, and
  we are down to just five demand defects (one inherited from
  Year 10) after assigning Year 9 (this is best of 1):

    [ "x11_4_ComputingStudies_1":3d1.1$Wed2+0:Room_ComputerRoom ]
    [ "x9_7_Arabic_2_1":2d1.0$Wed3+0:Teacher_ArabicYr7_10 ]
    [ "x12_3_Physics_1":0d1.1$Wed4+0:Room_ScienceLab ]
    [ "x12_3_Physics_1":3d1.1$Thu3+0:Room_ScienceLab ]
    [ "x10_5_Arabic_1_1":0d1.0$Fri3+0:Teacher_ArabicYr7_10 ]

  and 23 after assigning all layers.  This is better than the
  35 we were getting originally.

  Looking at the unrepaired timetable, Year 10 is perfect now
  but Year 9 is not quite perfect.  Need to investigate Year 9
  and see if it can be made better.

  Tried allowing inexact match in TrySingle and got best of
  1 cost 8.0565 and best of 16 cost 6.0495.  Not great.

  Did a test which proved that on the first solution there was
  no node-regular assignment for Year 9 English.  Not entirely
  sure why not, but it seems to be a fact.  You can get one by
  increasing the slack to about KheCost(3, 0).

  I think it might be time to try for a meet repair that is
  less disruptive of node regularity than the one we have now.
  Even a simple meet swapper, taking meets in order of lowest
  demand first, might do some good.

  Current best of 1 is 13.0724, current best of 16 is 6.0715,
  which is not great.

16 January 2011

  Have decided on a Plan.  Use KheCost(3, 0) which gives a very
  node-regular timetable, but with 30 demand defects.  The Plan
  is to somehow swap away almost all of these demand defects,
  after flattening, without totally destroying node regularity.
  At present, best of 1 without repair is

    KheGeneralSolve after time assignment (1.58 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 2808.0048)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 666     2787.0000
    SpreadEventsMonitor                    45        0.0048
    OrdinaryDemandMonitor                  21       21.0000
    -------------------------------------------------------
    Total                                 732     2808.0048

  If the current ejection chain algorithm is used, we get

    KheGeneralSolve after time assignment (3.86 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 2790.0014)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 666     2787.0000
    SpreadEventsMonitor                    14        0.0014
    OrdinaryDemandMonitor                   3        3.0000
    -------------------------------------------------------
    Total                                 683     2790.0014

  This shows that the ejection chain algorithm is effective,
  but it's slow (over 2 seconds) and disrupts node regularity.
  The challenge now is to find a method which is just as
  effective, but which runs faster and is less disruptive.
  I've set up khe_simple_repair.c which is to do this.

  Found and fixed a nasty bug in KheGroupMonitorDefectSort,
  it was forgetting to bring the cost up to date before
  starting the sort, so the size of the array of defects
  was sometimes changing as the sort went on.

17 January 2011

  Got the simple swapper going on repairing demand defects; it
  plus loosening reduced the number of demand defects from 28
  to 9, although after resource assignment, somehow (inexactness
  of Sport?), there were only 4.  It seems likely that running
  this first, followed by the ejection chain algorithm to clean
  up the small residue, would be good.

  Tried with KheCost(4, 0) and followed the simple repair with
  an ejection chain repair.  The best of 1 was also best of 16:

    13.0000 | **
    12.0000 | *
    11.0000 | **
    10.0000 M ***
     9.0000 M *
     8.0000 | *
     7.0000 | **
     6.0000 | ****

    Average of 16 solutions           Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 4.6        6.0000
    AvoidSplitAssignmentsMonitor         46.8        0.0545
    SpreadEventsMonitor                  35.8        0.0035
    AvoidClashesMonitor                   1.8        2.0000
    AvoidUnavailableTimesMonitor          0.3        0.0000
    LimitBusyTimesMonitor                23.4        0.0058
    -------------------------------------------------------
    Total                               112.6        8.0638

    Soln (instance "BGHS98", diversifier 0, cost 6.0636)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   3        6.0000
    AvoidSplitAssignmentsMonitor           49        0.0550
    SpreadEventsMonitor                    26        0.0026
    LimitBusyTimesMonitor                  23        0.0060
    -------------------------------------------------------
    Total                                 101        6.0636

  The ejection chain repair continues to play havoc with node
  regularity.  Added simple spread repair and got this best of 1
  (KheCost(4, 0), incl. ejection chains):

    KheGeneralSolve at end (16.29 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 9.0621)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   3        6.0000
    AvoidSplitAssignmentsMonitor           51        0.0540
    SpreadEventsMonitor                    22        0.0023
    AvoidClashesMonitor                     2        3.0000
    LimitBusyTimesMonitor                  23        0.0058
    -------------------------------------------------------
    Total                                 101        9.0621

  and this best of 16:

    16.0000 | *
    15.0000 | 
    14.0000 | 
    13.0000 | **
    12.0000 | ****
    11.0000 | 
    10.0000 | 
     9.0000 M ***
     8.0000 | ***
     7.0000 | 
     6.0000 | **
     5.0000 | *

    Average of 16 solutions           Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 4.4        7.0000
    AvoidSplitAssignmentsMonitor         46.7        0.0534
    SpreadEventsMonitor                  42.1        0.0042
    AvoidClashesMonitor                   2.0        2.0000
    AvoidUnavailableTimesMonitor          0.1        0.0000
    LimitBusyTimesMonitor                25.3        0.0059
    -------------------------------------------------------
    Total                               120.7        9.0635

    Soln (instance "BGHS98", diversifier 2, cost 5.0649)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   4        5.0000
    AvoidSplitAssignmentsMonitor           43        0.0530
    SpreadEventsMonitor                    47        0.0047
    LimitBusyTimesMonitor                  28        0.0072
    -------------------------------------------------------
    Total                                 122        5.0649

  Not remarkable.  Without ejection chain repair the best of
  16 was 12.0622.

  Documented the simple repair algorithm.

  Documented a version of ejection chains that tries to
  minimize disruption.  Seems quite implementable and not
  necessarily slow.  Will implement it next.

18 January 2011

  Working on the new kind of ejection chain today.  Have
  implemented and documented it and a new solvers assuming
  its presence.  Best of 1 with the regular repair:

    KheGeneralSolve at end (11.67 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 10.0560)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   5        6.0000
    AvoidSplitAssignmentsMonitor           42        0.0500
    SpreadEventsMonitor                    16        0.0016
    AvoidClashesMonitor                     3        4.0000
    LimitBusyTimesMonitor                  21        0.0044
    -------------------------------------------------------
    Total                                  87       10.0560

  and best of 16:

    14.0000 | **
    13.0000 | *
    12.0000 | 
    11.0000 | 
    10.0000 M ***********
     9.0000 | **

    Average of 16 solutions           Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 5.2        7.0000
    AvoidSplitAssignmentsMonitor         49.0        0.0551
    SpreadEventsMonitor                  33.7        0.0034
    AvoidClashesMonitor                   2.1        2.0000
    AvoidUnavailableTimesMonitor          0.4        0.0000
    LimitBusyTimesMonitor                23.9        0.0055
    -------------------------------------------------------
    Total                               114.3        9.0640

    Soln (instance "BGHS98", diversifier 2, cost 9.0606)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   7        8.0000
    AvoidSplitAssignmentsMonitor           47        0.0520
    SpreadEventsMonitor                    30        0.0030
    AvoidClashesMonitor                     1        1.0000
    LimitBusyTimesMonitor                  24        0.0056
    -------------------------------------------------------
    Total                                 109        9.0606

  This is with KheCost(4, 0).  With KheCost(1, 0) the best of
  16 is 4.0730.

  Best of 1 with the new "long" repair:

    KheGeneralSolve at end (19.91 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 11.0689)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   6        9.0000
    AvoidSplitAssignmentsMonitor           51        0.0600
    SpreadEventsMonitor                    23        0.0023
    AvoidClashesMonitor                     1        2.0000
    LimitBusyTimesMonitor                  25        0.0066
    -------------------------------------------------------
    Total                                 106       11.0689

  and best of 16:

    12.0000 | *
    11.0000 | **
    10.0000 | **
     9.0000 M ***
     8.0000 M *****
     7.0000 | *
     6.0000 | *
     5.0000 | *

    Average of 16 solutions           Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 4.4        6.0000
    AvoidSplitAssignmentsMonitor         44.7        0.0520
    SpreadEventsMonitor                  44.4        0.0045
    AvoidClashesMonitor                   1.4        2.0000
    LimitBusyTimesMonitor                24.6        0.0060
    -------------------------------------------------------
    Total                               119.5        8.0625

    Soln (instance "BGHS98", diversifier 4, cost 5.0735)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   3        4.0000
    AvoidSplitAssignmentsMonitor           51        0.0580
    SpreadEventsMonitor                    79        0.0079
    AvoidClashesMonitor                     1        1.0000
    LimitBusyTimesMonitor                  30        0.0076
    -------------------------------------------------------
    Total                                 164        5.0735

  With KheCost(1, 0) the best is 5.0562.

  and with long repair, but not limiting disruption:

    KheGeneralSolve at end (28.58 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 7.0724)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   4        5.0000
    AvoidSplitAssignmentsMonitor           50        0.0590
    SpreadEventsMonitor                    78        0.0078
    AvoidClashesMonitor                     1        2.0000
    LimitBusyTimesMonitor                  26        0.0056
    -------------------------------------------------------
    Total                                 159        7.0724

  Best of 16 with this setting is quite good:

    11.0000 | ***
    10.0000 | **
     9.0000 | 
     8.0000 | 
     7.0000 M ***
     6.0000 M *
     5.0000 | *******

    Average of 16 solutions           Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 3.9        5.0000
    AvoidSplitAssignmentsMonitor         45.8        0.0528
    SpreadEventsMonitor                  67.3        0.0068
    AvoidClashesMonitor                   1.3        1.0000
    AvoidUnavailableTimesMonitor          0.1        0.0000
    LimitBusyTimesMonitor                24.4        0.0059
    -------------------------------------------------------
    Total                               142.8        6.0655

    Soln (instance "BGHS98", diversifier 3, cost 5.0541)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   3        4.0000
    AvoidSplitAssignmentsMonitor           37        0.0430
    SpreadEventsMonitor                    61        0.0061
    AvoidClashesMonitor                     1        1.0000
    LimitBusyTimesMonitor                  21        0.0050
    -------------------------------------------------------
    Total                                 123        5.0541

  With KheCost(1, 0) the best is

    Soln (instance "BGHS98", diversifier 8, cost 4.0619)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   2        3.0000
    AvoidSplitAssignmentsMonitor           42        0.0530
    SpreadEventsMonitor                    41        0.0041
    AvoidClashesMonitor                     1        1.0000
    LimitBusyTimesMonitor                  21        0.0048
    -------------------------------------------------------
    Total                                 107        4.0619

  which is the best of this run of tests, although as usual
  not a node-regular assignment.  I've worked out why swapping
  meets can disrupt Year 10: it's because the Year 10 Maths
  classes are all linked.  If you decide to move one, you
  move the lot, and there goes your node regularity.  Debug
  runs have shown transactions doing all this - and yet they
  are the least disruptive ones.

  One possibility would be to actually limit disruption rather
  than merely to minimize it as we are doing now.

18 January 2011

  Reorganized ejectors to unify the new ideas and allow
  disruption to be limited as well as minimized.  All
  done, documented, audited, and tested.  Results:

    7.0734 in 8.32 secs on KHE_EJECTOR_FIRST_SUCCESS
    4.0809 in 22.11 secs on KHE_EJECTOR_MIN_COST,
    7.0708 in 20.91 secs on KHE_EJECTOR_MIN_DISRUPTION_THEN_COST

  Then setting max_disruption to 60 got

   11.0617 in 13.33 secs on KHE_EJECTOR_MIN_DISRUPTION_THEN_COST
   10.0609 in 7.57 secs on KHE_EJECTOR_MIN_COST

  These last are noticeably better in soft constraint cost (avoid
  split assignments costs, basically) than the others, and one can
  see some residual node regularity in the display.  Keeping to
  (KHE_EJECTOR_MIN_COST, 60), best of 16 is 8.0583.

  What to do now?  I'm still at the same problem:  I can get
  reasonable node regularity in Year 9, I can get reasonable
  demand cost in Year 9, but I don't seem to be able to get
  both, whatever I do.  I really need to solve this problem.
  The KTS solution has both, why can't I get it in KHE?

  I'm running out of ideas, but one possibility is to make
  a version of KheLayerMatchImproveNodeRegularity which has
  the following priorities:

  * First, demand cost for nodes where there are no children,
    hence no real prospects for swapping demand problems away
    later on.

  * Second, node regularity.

  * Third, demand cost for nodes with children.

  This way, we might avoid intractable demand costs but still
  get good node regularity.  Current vanilla-flavoured results:

    KheGeneralSolve at end (8.46 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 15.0622)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   5       10.0000
    AvoidSplitAssignmentsMonitor           46        0.0550
    SpreadEventsMonitor                    14        0.0014
    AvoidClashesMonitor                     3        4.0000
    AvoidUnavailableTimesMonitor            1        1.0000
    LimitBusyTimesMonitor                  23        0.0058
    -------------------------------------------------------
    Total                                  92       15.0622

  and best of 16:

    15.0000 | **
    14.0000 | **
    13.0000 | *
    12.0000 | 
    11.0000 | **
    10.0000 M **
     9.0000 | *
     8.0000 | 
     7.0000 | 
     6.0000 | ****
     5.0000 | **

    Average of 16 solutions           Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                 5.2        7.0000
    AvoidSplitAssignmentsMonitor         43.6        0.0495
    SpreadEventsMonitor                  21.5        0.0021
    AvoidClashesMonitor                   1.4        1.0000
    AvoidUnavailableTimesMonitor          0.4        0.0000
    LimitBusyTimesMonitor                22.0        0.0052
    -------------------------------------------------------
    Total                                94.1        8.0568

    Soln (instance "BGHS98", diversifier 7, cost 5.0537)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   4        5.0000
    AvoidSplitAssignmentsMonitor           41        0.0470
    SpreadEventsMonitor                    21        0.0021
    LimitBusyTimesMonitor                  20        0.0046
    -------------------------------------------------------
    Total                                  86        5.0537

28 January 2011

  Just returned from a week's holiday.  Not sure where to go from
  here so decided to do the re-implementation of HSEval using KHE.

  Added reports to KHE's archive printing.  KHE already reads and
  ignores reports (except for format errors), which is OK as is.

  Finished the conversion of main.c and cgi.c in HSEval.

29 January 2011

  Continuing with the conversion of HSEval.  Added deviation
  reporting to KHE, and also audited the function calculated,
  which was sometimes wrong for cost functions other than Sum.

1 February 2011

  Revised HSEval now compiled and tested.  It all seems to
  be working.  Should really use it for a while at home
  before installing it on the net.

2 February 2011

  Working on KHE solving again.  Must stop soon.  Added a
  min_cost_improvement parameter to KheSimpleRepairTimes,
  it seemed to work quite well:  when passed KheCost(1, 0),
  it found a few key repairs, but did not greatly disturb
  node regularity.

  Implementing KheMergeMeets uncovered errors in KheMeetSplit
  and KheMeetMerge.  All fixed now.  Got a cost reduction from
  25.0573 to 25.0552 from KheMergeMeets, which is bad because
  it shows that there were 21 cases of adjacent meets; in one
  case (x8_LPD_1234_1) two doubles merged into a quadruple!

3 February 2011

  Documented a new algorithm for improving node regularity,
  one which distinguishes between child nodes without children
  and child nodes with children.  Next step is to implement it.

4 February 2011

  Have a clean compile of the new algorithm for improving node
  regularity.  It ran first time without crashing and after some
  minor debugging produced a good timetable for Year 10.  Need
  to investigate its behaviour closely now and refine it.

5 February 2011

  The new algorithm was handling Year 10 perfectly, but Year 9
  less so.  Fixed a problem with the Year 9 segmentation, and
  allowed KheLayerMatchMake to take account of a spread events
  constraint, which has eliminated a small spread problem in
  the first layer.

6 February 2011

  The new layer matching code is in pretty good shape, so I
  thought it was time to bring back the various time repairs
  and see what we get overall.  Best of 1:

    KheGeneralSolve at end (15.52 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 10.0454)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   7        8.0000
    AvoidSplitAssignmentsMonitor           36        0.0410
    SpreadEventsMonitor                     8        0.0008
    AvoidClashesMonitor                     2        2.0000
    LimitBusyTimesMonitor                  15        0.0036
    -------------------------------------------------------
    Total                                  68       10.0454

  Best of 16:

      11.0000 | ***
      10.0000 | ****
       9.0000 M *
       8.0000 M **
       7.0000 | ***
       6.0000 | ***

    Soln (instance "BGHS98", diversifier 3, cost 6.0492)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   6        6.0000
    AvoidSplitAssignmentsMonitor           40        0.0430
    SpreadEventsMonitor                     8        0.0008
    LimitBusyTimesMonitor                  24        0.0054
    -------------------------------------------------------
    Total                                  78        6.0492

  This is more or less the best so far on soft constraints,
  which may be more important than reducing hard constraint
  cost to 2 or 3.  Also fixed a bug with meet merging; child
  meets were being given the wrong offsets.

  Holding everything the same but refreshing the template layer:

    KheGeneralSolve at end (11.53 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 8.0733)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   5        8.0000
    AvoidSplitAssignmentsMonitor           56        0.0650
    SpreadEventsMonitor                    27        0.0027
    LimitBusyTimesMonitor                  22        0.0056
    -------------------------------------------------------
    Total                                 110        8.0733

  Best of 16:

    14.0000 | *
    13.0000 | 
    12.0000 | 
    11.0000 | 
    10.0000 | *
     9.0000 | **
     8.0000 M ********
     7.0000 | **
     6.0000 | 
     5.0000 | *
     4.0000 | *

    Soln (instance "BGHS98", diversifier 7, cost 4.0641)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   3        3.0000
    AvoidSplitAssignmentsMonitor           49        0.0570
    SpreadEventsMonitor                     9        0.0009
    AvoidClashesMonitor                     1        1.0000
    LimitBusyTimesMonitor                  25        0.0062
    -------------------------------------------------------
    Total                                  87        4.0641

  Although hard cost is better, it is not better on average.
  Soft cost is noticeably worse, and eyeballing the timetable
  shows that it is much less regular.  So let's not refresh.

  Have decided to spend some time on resoure adjustment, to
  see whether these fairly large numbers of split assignments
  can be reduced by means other than further improving node
  regularity, which is getting hard.  Two ideas:

  * bring over from KTS the algorithm for deassigning and
    reassigning the two resources involved in the split;

  * try an ejection chain repair algorithm that reassigns
    times as well as resources.

  I've documented a function which does the first of these,
  have to implement it now.

8 February 2011

  In the middle of transporting the two-colouring code
  across from KTS.  Actually it has more or less turned
  into a complete rewrite.

9 February 2011

  Two-colouring module working.  It found five improvements, but
  by the end there were just two improvements, so someone else
  must have been at work on those defects as well.  Best of 16:

    11.0000 | ***
    10.0000 | ****
     9.0000 M *
     8.0000 M ****
     7.0000 | *
     6.0000 | ***

    Soln (instance "BGHS98", diversifier 3, cost 6.0503)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   6        6.0000
    AvoidSplitAssignmentsMonitor           42        0.0440
    SpreadEventsMonitor                     9        0.0009
    LimitBusyTimesMonitor                  24        0.0054
    -------------------------------------------------------
    Total                                  81        6.0503

  Found a problem with KheTaskKempeAssignResource.  It was
  working on arbitrary tasks, not leader tasks, and if the
  task it is given has no meet (quite possible with leader
  tasks) it thinks its job is easy.

  I've implemented, tested, and documented a new version which
  works with leader tasks only.  Best of 1:

    KheGeneralSolve at end (6.18 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 10.0452)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   7        8.0000
    AvoidSplitAssignmentsMonitor           34        0.0400
    SpreadEventsMonitor                     8        0.0008
    AvoidClashesMonitor                     2        2.0000
    LimitBusyTimesMonitor                  17        0.0044
    -------------------------------------------------------
    Total                                  68       10.0452

  Best of 16:

    11.0000 | ****
    10.0000 | **
     9.0000 M **
     8.0000 M ****
     7.0000 | *
     6.0000 | ***

    Soln (instance "BGHS98", diversifier 3, cost 6.0494)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   5        5.0000
    AvoidSplitAssignmentsMonitor           39        0.0430
    SpreadEventsMonitor                     8        0.0008
    AvoidClashesMonitor                     1        1.0000
    LimitBusyTimesMonitor                  22        0.0056
    -------------------------------------------------------
    Total                                  75        6.0494

  It does seem somewhat better on split assignments, as it
  should be, because the old version was introducing them
  before they were expected.

10 February 2011

  Options                           Time (1)   Cost(1)  Cost(16)
  --------------------------------------------------------------
  1 As above                            6.18   10.0452    6.0494
  2 layer_node_matching_repair_times   14.55   20.0513    5.0455
  3 node_meet_swap_repair_times        12.30    6.0381    6.0381
  4 with_long_repair                    9.39   12.0475    6.0494
  1+2+3                                11.37    7.0433    4.0538
  1+2+3+4                              11.37    7.0433    4.0538
  --------------------------------------------------------------
  Let's use 1+2+3 for now.

  Thing to do:

  * try an ejection chain repair algorithm that reassigns
    times as well as resources.

12 February 2011

  Working on building new versions of my instances and solutions
  for Gerhard.  Came upon a nasty problem:  the code for inferring
  time breaks was complete rubbish.  Have implemented a revised
  version, quarantined in a separate file, and am ready to test
  it.  But I'm wondering now, since time breaks are used to
  build cycle meets, whether they should be part of the solution
  and not part of the instance at all.  Who else uses time breaks
  in the instance?

13 February 2011

  Have decided that time break inference belongs in solutions, not
  in instances.  Have documented the new stuff and implemented most
  of it, and now I need to remove the documentation of the old stuff
  and unimplement it.

14 February 2011

  Removed old cycle meet stuff and its documentation, and added
  the new stuff, documented it, and tested it - seems to work,
  am getting the same cost (7.0433) as before.

15 February 2011

  Placed a new version of HSEval on the internet, and sent off
  new versions of instances BGHS98, TES99, and SAHS96, with
  solutions, to Gerhard.

  There is a problem with MArrayContains when compiled at uni;
  there seems to be some confusion about the sizeof values, it
  says it's casting a pointer to an integer of a different size.

16 February 2011

  Working on evenness monitoring.  Have made partitions clearer
  and given each of them an index in the instance.  Tested.
  Documented and implemented evenness monitors, ready for testing.

17 February 2011

  Evenness monitoring seems to be working.  Best of 1:

    KheGeneralSolve at end (13.54 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 9.0434)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   4        7.0000
    AvoidSplitAssignmentsMonitor           35        0.0380
    SpreadEventsMonitor                     4        0.0004
    AvoidClashesMonitor                     2        2.0000
    LimitBusyTimesMonitor                  21        0.0050
    -------------------------------------------------------
    Total                                  66        9.0434

  Best of 16:

    15.0000 | **
    14.0000 | 
    13.0000 | 
    12.0000 | 
    11.0000 | ***
    10.0000 | *
     9.0000 M ***
     8.0000 | *
     7.0000 | ****
     6.0000 | 
     5.0000 | **

    Soln (instance "BGHS98", diversifier 4, cost 5.0464)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   4        4.0000
    AvoidSplitAssignmentsMonitor           33        0.0390
    SpreadEventsMonitor                    20        0.0020
    AvoidClashesMonitor                     1        1.0000
    LimitBusyTimesMonitor                  23        0.0054
    -------------------------------------------------------
    Total                                  81        5.0464

  Turning it off gives best of 1:

    KheGeneralSolve at end (11.18 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 7.0433)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   5        7.0000
    AvoidSplitAssignmentsMonitor           31        0.0380
    SpreadEventsMonitor                     5        0.0005
    LimitBusyTimesMonitor                  20        0.0048
    -------------------------------------------------------
    Total                                  61        7.0433

  and best of 16 is 4.0538, with 42 split assignments.  All
  this may just be noise.

  Have been fiddling around with resource packing, to get it to
  focus on packing tasks that will be difficult to move in time
  later.  Changing just this one thing gives best of 1:

    KheGeneralSolve at end (9.57 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 6.0415)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   5        6.0000
    AvoidSplitAssignmentsMonitor           29        0.0360
    SpreadEventsMonitor                     5        0.0005
    LimitBusyTimesMonitor                  20        0.0050
    -------------------------------------------------------
    Total                                  59        6.0415

  and best of 16:

    24.0000 | **
    22.0000 | 
    20.0000 | 
    18.0000 | 
    16.0000 | 
    14.0000 | 
    12.0000 | *
    10.0000 | **
     8.0000 M ****
     6.0000 | *****
     4.0000 | **

    Soln (instance "BGHS98", diversifier 4, cost 4.0511)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   2        3.0000
    AvoidSplitAssignmentsMonitor           42        0.0450
    SpreadEventsMonitor                     7        0.0007
    AvoidClashesMonitor                     1        1.0000
    LimitBusyTimesMonitor                  23        0.0054
    -------------------------------------------------------
    Total                                  75        4.0511

  This is very marginally better (just noise), but presumably
  there will now be a tendency for the split assignments to
  concentrate in the more movable tasks, even though the
  start to this given by resource packing is not continued
  on through the ejection chain repairs.

  With evenness get best of 1: 9.0457 (13.77 secs), best of
  16: 5.0498, which is nothing remarkable.  Increasing the
  weight of evenness monitors to KheCost(0, 5) gave best
  of 1: 8.0372 (14.77 secs), best of 16: 5.0412, with 32
  split assignments, again not a remarkable result.

  There seems to have been something wrong with resource
  packing, not packing everything it could.  It seems to
  be working now, but I'm not sure what I did.  Anyway
  the best of 1 is now 5.0559 (12.27 secs) and best of
  16 is 4.0483, which is the best we've done recently:

    26.0000 | **
    24.0000 | 
    22.0000 | 
    20.0000 | 
    18.0000 | 
    16.0000 | 
    14.0000 | 
    12.0000 | *
    10.0000 | ****
     8.0000 M **
     6.0000 | **
     4.0000 | *****

    Soln (instance "BGHS98", diversifier 4, cost 4.0483)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   2        3.0000
    AvoidSplitAssignmentsMonitor           36        0.0420
    SpreadEventsMonitor                     7        0.0007
    AvoidClashesMonitor                     1        1.0000
    LimitBusyTimesMonitor                  26        0.0056
    -------------------------------------------------------
    Total                                  72        4.0483

  There are 6 Maths split assignments in this solution, which
  is not good, especially considering that there is a remaining
  workload of 4, which ought to give some room to move.

  There is a Year 8 split assignment which can be removed by
  a simple move of one half of the split to the resource of
  the other.  That fix would clear the way for removing the
  split assignment in x12_4_Maths_6P_1, which if removed would
  give one overload defect which itself could be removed by
  an ejection chain.  So there are prospects for reducing the
  6 Maths split assignments to 4, a more acceptable number.
  
  Why is this not being done?  Have to track it through the
  various stages of ejection chains etc.  This solution has
  diversifier 4, can we start off one soln with this value?

18 February 2011

  Found and fixed the bug just referred to.  It was caused by
  defect lists changing as they were traversed, causing some
  defects to be skipped over without any repair being attempted.
  I've verified that there are no easy repairs now.

  Best of 1 now has cost 9.0495 (13.17 secs), and best of 16 has
  cost 9.0438.  There is a diversity problem (only 6 distinct
  solutions), and a problem with node regularity in Year 9 that
  needs looking into.  It looks like the more effective ejection
  chain has done a better job of disrupting node regularity
  during time assignment.

  And when I turned off time adjustment, a dirty little secret
  was revealed:  once again, the Maths meeting is being dumped
  on top of the Staff meeting.  Fixed now; it turned out that
  KheNodeMeetSwapRepairTimes was swapping the assignments of
  some unassigned meets, a very silly thing to do.  The similar
  KheLayerNodeMatchingLayerRepairTimes was already ensuring that
  all the nodes it included were fully assigned.

  With ordinary time adjustment, best of 1 now has cost 16.0504
  (20.71 sections), best of 16 has cost 8.0518.  With extended
  time adjustment *instead*, best of 1 has cost 18.0540 (14.38
  secs), best of 16 has cost 8.0585.  Still only six distinct
  solutions.  Either way the node regularity remains poor,
  although the extended one does seem to be less bad:  it has
  left Year 10 unwrecked.

  Tried extended repair without simple adjustment first.  Got
  best of 1 26.0399 (16.20 secs), and best of 16 9.0429.  The
  best of 16 had some disruption to Year 10 node regularity.
  Need to look into preserving node regularity.

  Back to simple and non-extended time repair.  Without node
  meet swapping, best of 1 is 11.0481 (13.15 secs) and best
  of 16 is 7.0470.  Node regularity seems not so bad, not
  sure why that would be.  Still we seem better off without
  it, will turn it off for the time being.

  Have been looking at KheLayerTemplateRepairTimes to see
  whether it can be encouraged to remove a small spread
  defect from Year 10.  But noticed a strange thing:  it
  is reporting that E10_5 and E10_7 share a template node,
  but in the solution I can see, they don't.  The info it
  is printing implies that there has been a subsequent swap
  of E10_4 with E10_7, but I have no idea who did this.

  Yes I do: it will be KheLayerNodeMatchingNodeRepairTimes.
  Yep, that was it.  But we still have the spread problem
  in Year 10 to fix.

19 February 2011

  Thinking about a more unified way of repairing time assignments,
  one that incorporates most of the different ideas into a
  single ejection chain algorithm.

  Taken the first step in this direction by defining zones,
  which will replace template layers but be part of the core
  platform, so that everyone can access them.  Documented,
  implemented, and tested (worked first time!).  Now to use it.

20 February 2011

  Revising layer matching to work with zones instead of template
  layers.  Documentation done, implementation done, tested, and
  working.  There seems to have been a strange bug in the old
  node regularity code, can't see how it could have worked.
  Best of 1 cost 8.0447 (11.79 secs), and this was also the
  best of 16 (actually only 6 distinct solutions).  So it
  looks like we have some work to do to get back to 4.xxxx.

  There is a spread problem in Year 10:  E10_5 is being assigned
  blocks {Tue1, Tue2}, {Thu7}, {Thu8}, and this has 1 spread
  defect.  There is no node-regular repair that would remove
  this, because the other occupant of the block containing
  {Thu7} and {Thu8} is E10_7, and it already has a block on
  Thursdays.  But that other block could swap with the E10_4
  block {Wed5, Wed6}, and this would fix everything - an
  ejection chain of depth 2.  The current function for fixing
  these problems, KheLayerTemplateRepairTimes, just tries
  swaps, not ejection chains.

  Another job: review the handling of node regularity generally
  in the User's Guide.  The functions defined in Section 10.5
  don't seem to be getting much use.  Even KheLayerRegular,
  formerly used to find template layers, is not currently used).
  The whole concept is supported by zones but zones are not
  mentioned in that section.

21 February 2011

  Planned and documented automatic time domains, which allow
  meets to adapt their domains as other meets are assigned to
  them and unassigned from them.  Implementation done, and no
  problems with existing code, but have not actually tested
  anything that uses automatic domains yet.

  Could update the global swaps code to use automatic domains
  right now, as a test.

  Also need to redo KheLayerTemplateRepairTimes so that it
  uses zones, not a template layer.

  Then we have the following node-regular repair functions:

    KheLayerTemplateRepairTimes
    KheLayerNodeMatchingLayerRepairTimes
    KheLayerNodeMatchingNodeRepairTimes
    KheNodeMeetSwapRepairTimes
    KheNodeGlobalSwapRepairTimes

  most of which can be folded into a single node-regular ejection
  chain repair algorithm applied after each layer is assigned.

22 February 2011

  Had an idea for a better way to structure my next PATAT paper, using
  the single node-regular ejection chain time repair algorithm as the
  focus.  Spent the morning sketching that out.  This afternoon I
  converted KheLayerTemplateRepairTimes into KheLayerZoneRepairTimes.
  All documented, implemented, tested, and working.  Also converted
  KheNodeGlobalSwapRepairTimes to use automatic domains; it worked
  first time.  And checked all occurrences of KheMeetDomain to make
  sure they are OK with automatic domains.

  The next step would seem to be a unified description of the
  combined ejection chain time repair algorithm, followed by
  its implementation.

24 February 2011

  Working on the new paper about node-regular time repair.  It
  looks good in itself and will nicely complement a second paper,
  which I will write later in the year, about solving the
  XHSTT2011 instances.

26 February 2011

  Written most of the new paper, in the course of which I have
  sorted out my ideas about generalizing the various functions
  I've written for time repair into a single ejection chain
  time repair function.

  I should now implement those ideas, do some experiments, and
  add their results to the paper, which will finish it off.  It
  will not need to be updated, whatever I do later this year.

27 February 2011

  Changed the monitor grouping functions to accept an extra
  parameter which causes them to group assigned meets only.
  Currently working on a better Kempe meet move function,
  in khe_time_repair.c.

28 February 2011

  I've redone KheKempeMeetMove to allow different durations in
  the time-adjacent case.  Still to test, but I've audited it
  and documented it carefully - it's great.

  Also finished and audited the new prefer times augment,
  including preserving zones, but not yet node moves.  Have
  to do them, then spread and demand augments.

1 March 2011

  Spent the morning fiddling with the documentation, clearing
  up a few conceptual points.  Finished off the whole ejection
  chains time repair algorithm.  Still need to document it.
  I've reorganized the time solvers chapter, but this ejection
  chain algorithm is documented (in detail, that is) in the
  ejection chains chapter.

  It might be better to divide up the explanations of the
  augment functions.  The current arrangement assumes
  that there will only ever be one augment function for
  each kind of constraint, whereas in reality there may
  be one for each (algorithm, constraint) pair.

  So the ejection chains algorithm should be organized
  as a general introduction followed by one section
  for each algorithm.

2 March 2011

  Documented and implemented vizier nodes, the new name for the node
  inserted under the cycle node, including new code for handling zones.

  Knocked the time solvers chapter into decent shape at last.  The only
  remaining question is the name and final form of the function documented
  in the "Putting it all together" section of that chapter, including
  where vizier nodes are best incorporated.

  Reviewed the distribution of the time solvers code into files, which is
  in reasonable shape.  Next, I need to reorganize ejection chain code and
  doc (see above).  At that point I should be ready to test the new stuff.
  
  (1) Sort out "Putting it all together" in time_solvers;
  (2) Reorganize ejection chains chapter;
  (3) Start testing

3 March 2011

  (1) done, although now I'm puzzled about why domain tightening is
  a part of that algorithm.  Should it move to the general solver?

  (2) is done.  Ultimately I need to remove khe_augment.c, but at
  present its augment functions are still called by the old ejection
  chain algorithms documented in the time solvers chapter.  Until I
  can get rid of them, khe_augment.c must remain.

4 March 2011

  Incorporated vizier splits into the time assignment algorithm.
  Then ran the new algorithm.  It worked first time, basically.
  Best of 1:

    KheGeneralSolve at end (19.11 secs so far):
    Soln (instance "BGHS98", diversifier 0, cost 9.0494)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   6        7.0000
    AvoidSplitAssignmentsMonitor           34        0.0410
    SpreadEventsMonitor                    36        0.0036
    AvoidClashesMonitor                     1        1.0000
    AvoidUnavailableTimesMonitor            1        1.0000
    LimitBusyTimesMonitor                  22        0.0048
    -------------------------------------------------------
    Total                                 100        9.0494

  Best of 16:

    13.0000 | *
    12.0000 | ***
    11.0000 | *
    10.0000 | **
     9.0000 M ***
     8.0000 | 
     7.0000 | ***
     6.0000 | 
     5.0000 | ***

  [ Soln (instance "BGHS98", diversifier 2, cost 5.0432)
    Soln                              Defects          Cost
    -------------------------------------------------------
    AssignResourceMonitor                   5        5.0000
    AvoidSplitAssignmentsMonitor           34        0.0380
    SpreadEventsMonitor                     4        0.0004
    LimitBusyTimesMonitor                  20        0.0048
    -------------------------------------------------------
    Total                                  63        5.0432

  This compares quite well with a previous result that I seem to
  have considered to be good: 4.0483 (17 February).  Still only
  6 distinct solutions, I really must do something about that.
  Run time is another thing to look at.  Also it would be good
  to get some idea of where the ejection chain is finding its
  improvements (it is certainly finding many improvements).
  Also min-disruptive repair after removing structures.
  Also look at the timetable before removing structures.

  Have begun to generate graphs, added one to the paper so far.

5 March 2011

  Finished my first PATAT12 paper, on time repair in high
  school timetabling.

1 April 2011

  Tidied up the documentation and made an off-site backup and
  new release.

15 May 2011

  Have been fixing a couple of bugs reported by users of HSEval,
  one a straight bug in khe_dev_monitor.c, the other forgetting
  that the resources of event resource groups have to be event
  resources in themselves.  New version published today.

6 June 2011

  Fixed a reported bug in HSEval that turned out to be caused
  by confusion between preassignments owing to preassigned
  resources, and preassignments owing to singleton domains.

17 January 2011

  Revised the specification of when two Id's clash, and made
  the one change required by the revision (ensuring that two
  resources must have distinct Id's, even if their resource
  types differ).

3 July 2012

  Have just completed quite a lot of work directed towards making
  KHE faster and less memory-hungry when evaluating solutions.  It
  can now read archives incrementally, replacing solutions by
  placeholders which contain the cost but nothing else.  Matchings
  and evenness monitoring are optional.

20 Sep 2012

  Promised Gerhard I would see if I could make suggestions about
  which instances from ITC2011 would be best for XHSTT-2013.  So
  I'm currently working on making KHE solves the ITC2011 instances.
  I've fixed one bug, and now I'm writing a solver to find solutions
  to multiple instances in parallel.  Seems to be working.

21 Sep 2012

  Today's problem is that the HSEval planning timetables function
  is producing an incomplete result.  I'm guessing that that's
  because it is running out of memory, so I've rewritten it to
  write its timetables incrementally.  This included changing
  KheArchiveReadIncremental so that it calls back at the
  beginning and end of the archive, and at the beginning and
  end of each solution group, as well as after each solution.
  All written and compiling, but the first test didn't go
  very well:  it took an inordinately long time to put up
  the first solution's planning timetables, and then the
  run ended without any others being printed at all.
  Fixed one bug in timetable.c, but the run is still very
  slow, not sure why.  When I do it non-webly, i.e.

     ./run > op

  it comes back quite quickly with an apparently complete
  HTML output file.

25 Nov 2012.

  Begun work on adding the new OrderEventsConstraint to KHE
  and HSEval.  I did the HSEval documentation a few days ago,
  and the KHE documentation today.  Also began work on the
  implementation; I've more or less finished the boilerplate
  (khe_order_events_constraint.c and khe_order_events_monitor.c
  files, new entries in khe.h, etc.).

29 Nov 2012

  Finished khe_order_events_constraint.c with a clean compile,
  and also khe_order_events_monitor.c except none of the logic
  is done yet.  Still, that logic is all that is left to do.
  At present I have followed the structure of link events
  constraints, but that seems to be wrong, the logic needs
  to follow a different pattern, more like two spread events
  monitors, keeping track of the max time of first_event and
  the min time of second_event.  Also check attachment.

30 Nov 2012

  Got side-tracked into pushing constraint density down from
  HSEval to KHE, which I've finished now, except have to do
  density count and total of order events constraint.  Should
  probably audit all the density calculations.  Then return
  to jobs of 29 Nov.

9 Dec 2012

  Back at work today after a week off.  Have documented constraint
  density and audited it, including the order events constraint.
  Have implemented order events constraints except for the helper
  function for AttachCheck (KheOrderEventsMonitorMustHaveZeroCost),
  but the evaluation logic needs a check.

10 Dec 2012

  Finished implementing order events constraints today, now I
  need to test the code I've written, but it should be OK.
  Also added INHERIT_CONSTRAINT and INHERIT_MONITOR macros.

11 Dec 2012

  Lightly tested and seems to work, publishing it now.

(at this point, neighbouring file diary14 should be included)

12 Oct 2015

  Got clean compile with the new version of gcc that came
  with my new computer.  The only new errors were variables
  set but not used; I managed to get rid of them all.

  Investigated inconsistencies in the way that time groups,
  resource groups, and event groups are implemented:

  * resource groups and event groups have a *_group_type
    attribute recording more comprehensively than is really
    needed where the group came from, whereas time groups
    only have the _PREDEFINED value for their kind, which
    should not be exposed to the user anyway.

  * time groups created during solving are added to the
    solution for removal later, but this is not done for
    resource groups and event groups.

  Both of these problems are fixed now.

12 Oct 2015.  Ensured we get an informative abort rather than a
  crash when trying to write a reference to an entity with a null
  Id.  Also revised HSEval, got localhost working, and did a few
  tests.  It all seems to be working, but I won't publish the
  new version for the time being.

9 Dec 2015.  Publishing a new version today, which hopefully will
  fix a bug reported by John Tass.  The function that copied
  monitor links was copying one field twice and another not at all.

6 Feb 2015.  Releasing a new version today.  There have been
  several bug fixes and several new versions lately, which I
  have neglected to diarize.  Today's release is mainly about
  tightening up the rules for when a solution can be written,
  to require no inconsistency between assigned and preassigned
  times and resources.


Still to Do
===========

  Nothing at the moment.
