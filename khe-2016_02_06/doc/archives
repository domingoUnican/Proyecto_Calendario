@Chapter
    @Title { Archives and Solution Groups }
    @Tag { archives }
@Begin
@LP
This chapter describes the @C { KHE_ARCHIVE } and @C { KHE_SOLN_GROUP }
data types, representing archives and solution groups as in the XML
format.  Their use is optional, since instances are not required to lie
in archives, and solutions are not required to lie in solution groups.
@BeginSections

@Section
   @Title { Archives }
   @Tag { archives.archives }
@Begin
@LP
An archive is defined in the XML format to be a collection
of instances together with groups of solutions to those
instances.  There may be any number of instances and
solution groups.  To create a new, empty archive, call
@ID @C {
KHE_ARCHIVE KheArchiveMake(char *id, KHE_ARCHIVE_METADATA md);
}
Both parameters are optional (may be @C { NULL }); @C { id } is
an identifier for the archive, and @C { md } is metadata, which
can be created by @C { KheArchiveMetaDataMake } below.  Functions
@ID @C {
char *KheArchiveId(KHE_ARCHIVE archive);
KHE_ARCHIVE_METADATA KheArchiveMetaData(KHE_ARCHIVE archive);
}
return these two attributes.  To set and retrieve the back pointer
(Section {@NumberOf intro.common}), call
@ID @C {
void KheArchiveSetBack(KHE_ARCHIVE archive, void *back);
void *KheArchiveBack(KHE_ARCHIVE archive);
}
Archive metadata may be created by calling
@ID @C {
KHE_ARCHIVE_METADATA KheArchiveMetaDataMake(char *name,
  char *contributor, char *date, char *description, char *remarks);
}
where @C { remarks }, being optional, may be @C { NULL }.  The
attributes may be retrieved by calling
@ID @C {
char *KheArchiveMetaDataName(KHE_ARCHIVE_METADATA md);
char *KheArchiveMetaDataContributor(KHE_ARCHIVE_METADATA md);
char *KheArchiveMetaDataDate(KHE_ARCHIVE_METADATA md);
char *KheArchiveMetaDataDescription(KHE_ARCHIVE_METADATA md);
char *KheArchiveMetaDataRemarks(KHE_ARCHIVE_METADATA md);
}
Initially an archive contains no instances and no solution groups.
Solution groups are added automatically as they are created, because
every solution group lies in exactly one archive.  An instance may
be added to an archive by calling
@ID @C {
bool KheArchiveAddInstance(KHE_ARCHIVE archive, KHE_INSTANCE ins);
}
@C { KheArchiveAddInstance } returns @C { true } if it succeeds in
adding @C { ins } to @C { archive }, and @C { false } otherwise,
which can only be because @C { archive } already contains an instance
with the same Id as @C { ins }.  The instance will appear after any
instances already present.  An instance may be deleted from an archive
(but not destroyed) by calling
@ID @C {
void KheArchiveDeleteInstance(KHE_ARCHIVE archive, KHE_INSTANCE ins);
}
@C { KheArchiveDeleteInstance } aborts if @C { ins } is not in
@C { archive }.  If there are any solutions for @C { ins } in
@C { archive }, they are deleted too.  The gap left by deleting the
instance is filled by shuffling subsequent instances up one place.
@PP
To visit the instances of an archive, call
@ID @C {
int KheArchiveInstanceCount(KHE_ARCHIVE archive);
KHE_INSTANCE KheArchiveInstance(KHE_ARCHIVE archive, int i);
}
The first returns the number of instances in @C { archive },
and the second returns the @C { i }'th of those instances,
counting from 0 as usual in C.  There is also
@ID @C {
bool KheArchiveRetrieveInstance(KHE_ARCHIVE archive, char *id,
  KHE_INSTANCE *ins);
}
If @C { archive } contains an instance with the given @C { id },
this function sets @C { ins } to that instance and returns
@C { true }; otherwise it leaves @C { *ins } untouched and
returns @C { false }.  In the same way,
@ID @C {
int KheArchiveSolnGroupCount(KHE_ARCHIVE archive);
KHE_SOLN_GROUP KheArchiveSolnGroup(KHE_ARCHIVE archive, int i);
bool KheArchiveRetrieveSolnGroup(KHE_ARCHIVE archive, char *id,
  KHE_SOLN_GROUP *soln_group);
}
visit the solution groups of an archive, and retrieve a solution
group by @C { id }.
@End @Section

@Section
    @Title { Solution groups }
    @Tag { archives.soln_groups }
@Begin
@LP
A solution group is a set of solutions to instances of its
archive.  To create a solution group, call
@ID @C {
bool KheSolnGroupMake(KHE_ARCHIVE archive, char *id,
  KHE_SOLN_GROUP_METADATA md, KHE_SOLN_GROUP *soln_group);
}
Parameter @C { archive } is compulsory.  The solution group will be
added to the archive.  Parameters @C { id } and @C { md } are the Id
and MetaData attributes from the XML file; both are optional, with
@C { NULL } meaning absent, although they are compulsory if
@C { archive } is to be written later.  If the operation is successful,
then @C { true } is returned with @C { *soln_group } set to the new
solution group; if it is unsuccessful (which can only be because
@C { id } is already the Id of a solution group of @C { archive }),
then @C { false } is returned with @C { *soln_group } set to @C { NULL }.
@PP
To set and retrieve the back pointer (Section {@NumberOf intro.common})
of a solution group, call
@ID @C {
void KheSolnGroupSetBack(KHE_SOLN_GROUP soln_group, void *back);
void *KheSolnGroupBack(KHE_SOLN_GROUP soln_group);
}
as usual.  To retrieve the other attributes, call
@ID @C {
KHE_ARCHIVE KheSolnGroupArchive(KHE_SOLN_GROUP soln_group);
char *KheSolnGroupId(KHE_SOLN_GROUP soln_group);
KHE_SOLN_GROUP_METADATA KheSolnGroupMetaData(KHE_SOLN_GROUP soln_group);
}
Solution group metadata may be created by calling
@ID @C {
KHE_SOLN_GROUP_METADATA KheSolnGroupMetaDataMake(char *contributor,
  char *date, char *description, char *publication, char *remarks);
}
where @C { publication } and @C { remarks }, being optional, may
be @C { NULL }.  The attributes are retrieved by
@ID @C {
char *KheSolnGroupMetaDataContributor(KHE_SOLN_GROUP_METADATA md);
char *KheSolnGroupMetaDataDate(KHE_SOLN_GROUP_METADATA md);
char *KheSolnGroupMetaDataDescription(KHE_SOLN_GROUP_METADATA md);
char *KheSolnGroupMetaDataPublication(KHE_SOLN_GROUP_METADATA md);
char *KheSolnGroupMetaDataRemarks(KHE_SOLN_GROUP_METADATA md);
}
Initially a solution group has no solutions.  These are added
and deleted by calling
@ID @C {
void KheSolnGroupAddSoln(KHE_SOLN_GROUP soln_group, KHE_SOLN soln);
void KheSolnGroupDeleteSoln(KHE_SOLN_GROUP soln_group, KHE_SOLN soln);
}
A solution can only be added when its instance lies in the solution
group's archive.
@PP
To visit the solutions of a solution group, call
@ID @C {
int KheSolnGroupSolnCount(KHE_SOLN_GROUP soln_group);
KHE_SOLN KheSolnGroupSoln(KHE_SOLN_GROUP soln_group, int i);
}
as usual.  Solutions have no Id attributes, so there is
no @C { KheSolnGroupRetrieveSoln } function.  When solution
@C { i } is deleted, @C { KheSolnGroupSolnCount } decreases
by 1, solution @C { i + 1 } becomes solution @C { i }, and so on.
@End @Section

@Section
   @Title { Reading archives }
   @Tag { archives.read }
@Begin
@LP
KHE reads and writes archives in a standard XML format @Cite { $post2008 }.
To read an archive, call
@ID @C {
bool KheArchiveRead(FILE *fp, KHE_ARCHIVE *archive, KML_ERROR *ke,
  bool infer_resource_partitions, bool allow_invalid_solns,
  char **leftover, int *leftover_len, FILE *echo_fp);
}
File @C { fp } must be open for reading UTF-8, and it remains open after
the call returns.  If, starting from its current position, @C { fp }
contains a legal XML archive, then @C { KheArchiveRead } sets @C { *archive }
to that archive and @C { *ke } to @C { NULL } and returns @C { true }
with the current position of @C { fp } moved to after the archive.  If
there was a problem reading the file, then it sets @C { *archive } to
@C { NULL } and @C { *ke } to an error object and returns @C { false }.
Any reports in the archive are discarded without checking.
@PP
Type @C { KML_ERROR } is from the KML module packaged with KHE.  A
full description of the KML module appears in Appendix {@NumberOf kml}.
Given an object of type @C { KML_ERROR }, operations
@ID @C {
int KmlErrorLineNum(KML_ERROR ke);
int KmlErrorColNum(KML_ERROR ke);
char *KmlErrorString(KML_ERROR ke);
}
return the line number, the column number, and a string description
of the error.
@PP
@C { KheArchiveRead } builds the archive object by calling only functions
described in this guide; there is nothing special about the archive it
makes.  Parameter @C { infer_resource_partitions } is passed on to the
calls to @C { KheInstanceMakeEnd } (Section {@NumberOf instances_creation}).
@C { KheArchiveRead } builds complete representations of the solutions it
reads, by calling @C { KheSolnMakeCompleteRepresentation },
@C { KheSolnAssignPreassignedTimes }, and
@C { KheSolnAssignPreassignedResources }
(Section {@NumberOf solutions.complete}); but it does not call
@C { KheSolnMatchingBegin } or @C { KheSolnEvennessBegin }
(Chapter {@NumberOf matchings}).
@PP
Usually, if there are errors in the file, @C { KheArchiveRead } returns
@C { false } and sets @C { *ke } to the first error.  But if
@C { allow_invalid_solns } is @C { true }, then some errors lying in
solutions are handled differently:  the erroneous solutions are converted
to invalid placeholders (Section {@NumberOf solutions.placeholder}).
Each invalid placeholder solution contains its first error, and none of
its errors cause @C { false } to be returned or @C { *ke } to be set.
Not all errors, not even all errors lying in solutions, can be handled
in this way; those that cannot cause @C { KheArchiveRead } to return
@C { false } and set @C { *ke } as usual.
@PP
@C { KheArchiveRead } calls @C { KmlRead } (Appendix {@NumberOf kml.read}),
passing @C { leftover }, @C { leftover_len }, and @C { echo_fp } to it, and
setting its @C { end_label } parameter to @C { "</HighSchoolTimetableArchive>" }
if @C { leftover } is non-@C { NULL }, and to @C { NULL } if @C { leftover }
is @C { NULL }.  Appendix {@NumberOf kml.read} has the details, but just
briefly, @C { leftover } and @C { leftover_len } should be @C { NULL } when 
the archive occupies @C { fp } from its current position to the end, and
non-@C { NULL } when other material may follow the archive in @C { fp };
and @C { echo_fp } would normally be @C { NULL }.
@PP
To create an archive by reading an XML string, call
@ID {0.95 1.0} @Scale @C {
bool KheArchiveReadFromString(char *str, KHE_ARCHIVE *archive,
  KML_ERROR *ke, bool infer_resource_partitions, bool allow_invalid_solns);
}
This is just like @C { KheArchiveRead } except that the archive lies
in @C { str } instead of @C { fp }, and is expected to occupy the
entire string.
@End @Section

@Section
   @Title { Reading archives incrementally }
   @Tag { archives.inc }
@Begin
@LP
A large archive may have to be read one solution at a time.  For
this, call
@ID {0.98 1.0} @Scale @C {
bool KheArchiveReadIncremental(FILE *fp, KHE_ARCHIVE *archive,
  KML_ERROR *ke, bool infer_resource_partitions, bool allow_invalid_solns,
  char **leftover, int *leftover_len, FILE *echo_fp,
  KHE_ARCHIVE_FN archive_begin_fn, KHE_ARCHIVE_FN archive_end_fn,
  KHE_SOLN_GROUP_FN soln_group_begin_fn,
  KHE_SOLN_GROUP_FN soln_group_end_fn, KHE_SOLN_FN soln_fn, void *impl);
}
The return value and the first eight parameters, to @C { echo_fp }
inclusive, are as for @C { KheArchiveRead }.  The next five parameters
are callback functions, and the last parameter, @C { impl }, is not
used by KHE but is instead passed through to the calls on the callback
functions.  Any or all of the callback functions may be @C { NULL },
in which case the corresponding callbacks are not made.
@PP
Callback function @C { archive_begin_fn } is called by
@C { KheArchiveReadIncremental } at the start of the archive.
It must be written by the user like this:
@ID @C {
void archive_begin_fn(KHE_ARCHIVE archive, void *impl)
{
  ...
}
}
Its @C { archive } parameter is set to the archive that
@C { KheArchiveReadIncremental } will eventually build, the one it
returns in its @C { *archive } parameter; its @C { impl } parameter
contains the value of the @C { impl } parameter of
@C { KheArchiveReadIncremental }.  At the time of this call,
@C { archive } contains its Id and metadata attributes, but no
instances and no solution groups.
@PP
Callback function @C { archive_end_fn } is called at the end of the
archive, just before @C { KheArchiveReadIncremental } itself returns:
@ID @C {
void archive_end_fn(KHE_ARCHIVE archive, void *impl)
{
  ...
}
}
When this function is called, @C { archive } contains all of its
instances and solution groups.  If @C { KheArchiveReadIncremental }
returns @C { true }, there has been one callback to @C { archive_begin_fn }
and one to @C { archive_end_fn }, if non-@C { NULL }.
@PP
Callback function @C { soln_group_begin_fn } is called at the start
of each solution group:
@ID @C {
void soln_group_begin_fn(KHE_SOLN_GROUP soln_group, void *impl)
{
  ...
}
}
Its @C { soln_group } parameter is set to one of the solution
groups that the final archive will eventually contain, and
its @C { impl } parameter is as before.  At the time of this
call, @C { soln_group } contains its Id and MetaData, and
@C { KheSolnGroupArchive(soln_group) } returns the enclosing
archive, but there are no solutions in @C { soln_group }.
@PP
Callback function @C { soln_group_end_fn } is called at the end
of each solution group:
@ID @C {
void soln_group_end_fn(KHE_SOLN_GROUP soln_group, void *impl)
{
  ...
}
}
At the time of this call, @C { soln_group } contains all its
solutions.
@PP
Finally, callback function @C { soln_fn } is called after
each solution is read:
@ID @C {
void soln_fn(KHE_SOLN soln, void *impl)
{
  ...
}
}
The solution is complete, and @C { KheSolnSolnGroup(soln) } returns
the enclosing solution group.
@PP
The purpose of incremental reading is to process the solutions
as they are read, so that they can be discarded and their memory
reclaimed.  One way to save memory is to replace each solution
by a placeholder.  This can be done by passing @C { NULL } for
all callbacks except @C { soln_fn }, which would be defined
like this:
@ID @C {
void soln_fn(KHE_SOLN soln, void *impl)
{
  if( !KheSolnIsPlaceholder(soln) )
    KheSolnReduceToPlaceholder(soln);
}
}
The test is needed only if @C { allow_invalid_solns } is @C { true }.
As Section {@NumberOf solutions.placeholder} explains,
@C { KheSolnReduceToPlaceholder } reclaims most of the memory of
@C { soln }, leaving just the @C { soln } object itself and a few
key attributes, including its cost.  This memory will then be
recycled for holding other solutions.  In this way, the total memory
cost is reduced to not much more than the memory needed to hold the
instances, but enough information is retained to support operations
which (for example) print tables of solutions and their costs.
@PP
Other applications might process @C { soln } in some way
(print timetables, for example) before finishing with a call to
@C { KheSolnReduceToPlaceholder }, or even @C { KheSolnDelete }.
@End @Section

@Section
   @Title { Writing archives and solution groups }
   @Tag { archives.write }
@Begin
@LP
To write an archive to a file, call
@ID @C {
void KheArchiveWrite(KHE_ARCHIVE archive, bool with_reports, FILE *fp);
}
File @C { fp } must be open for writing UTF-8 characters, and it
remains open after the call returns.  If @C { with_reports } is
@C { true }, each written solution contains a @C { Report }
section evaluating the solution.
@PP
Ids, names, and meta-data are optional in KHE but compulsory when
writing XML:  if any are missing, @C { KheArchiveWrite } writes an
incomplete file and aborts with an error message.  They will all
be present when @C { archive } was produced by @C { KheArchiveRead }.
@PP
When an event has a preassigned time, there is a problem if one of
its meets is not assigned that time.  If the meet is assigned some
other time (which is possible in KHE, although not easy), then
writing that time will cause the solution to be declared invalid
when it is re-read.  If the meet is not assigned any time, then,
whether or not the preassigned time is written, the meaning is that
the preassigned time is assigned, which is not the true state of
the solution.  The same problem arises with preassigned event
resources whose tasks are not assigned the preassigned resource.
@PP
Accordingly, @C { KheArchiveWrite } also writes an incomplete
file and aborts with an error message when it encounters a meet
(or task) derived from a preassigned event (or event resource)
whose assigned time (or resource) is unequal to the preassigned
time (or resource).
@PP
When writing solutions, @C { KheArchiveWrite } writes as little as
possible.  It does not write an unassigned or preassigned task.
It does not write a meet if its duration equals the duration of
the corresponding event, its time is unassigned or preassigned,
and its tasks are not written according to the rule just given
(see also Section {@NumberOf solutions.complete}).
@PP
A similar function is
@ID @C {
void KheArchiveWriteSolnGroup(KHE_ARCHIVE archive,
  KHE_SOLN_GROUP soln_group, bool with_reports, FILE *fp);
}
It also writes @C { archive }, omitting all its solution
groups except @C { soln_group }.  Also,
@ID @C {
void KheArchiveWriteWithoutSolnGroups(KHE_ARCHIVE archive, FILE *fp);
}
writes @C { archive } omitting all solution groups.
@End @Section

@EndSections
@End @Chapter
