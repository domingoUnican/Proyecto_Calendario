@Chapter
    @Title { Solution Monitoring }
    @Tag { monitoring }
@Begin
@LP
As a solution changes, it is continuously @I monitored by a
hand-tuned constraint network.
@BeginSections

@Section
    @Title { Measuring cost }
    @Tag { monitoring.cost }
@Begin
@LP
KHE measures the badness of a solution as a single integral value
called the @I { cost }, or sometimes the @I { combined cost }
because it includes the cost of both hard and soft constraint
deviations.  Storing costs in this way is convenient, because it
allows costs to be assigned using @C { = }, added using @C { + },
and compared using @C { < } and so on in the usual way.  The hard
cost is shifted left by 32 bits, to ensure that it is more
significant than any reasonable total soft cost, then added
to the soft cost.
@PP
The type of a combined cost is @C { KHE_COST }, a synonym for
the standard C 64-bit integer type @C { int64_t } (a fact best
forgotten).  To find the current combined cost of a solution, call
@ID @C {
KHE_COST KheSolnCost(KHE_SOLN soln);
}
This value is stored explicitly in @C { soln }, so this function
takes virtually no time to execute.  Call
@ID @C {
KHE_COST KheCost(int hard_cost, int soft_cost);
}
to create a combined cost.  The two components of a combined cost
may be accessed by
@ID @C {
int KheHardCost(KHE_COST combined_cost);
int KheSoftCost(KHE_COST combined_cost);
}
There is also the constant @C { KheCostMax }, which returns the
maximum value storable in a variable of type @C { KHE_COST } (a
synonym for @C { INT64_MAX }) and the function
@ID @C {
int KheCostCmp(KHE_COST cost1, KHE_COST cost2);
}
which returns an @C { int } which is less than, equal to, or
greater than zero if the first argument is respectively less
than, equal to, or greater than the second, as needed when
sorting items by cost.  The implementation does not make the
mistake of merely subtracting @C { cost2 } from @C { cost1 };
the result then would be a @C { KHE_COST } which will usually
overflow the @C { int } result.
@PP
The suggested way to display a combined cost is as a decimal
number with the hard cost before the decimal point and the
soft cost after.  Five decimal places are displayed, allowing
for soft costs up to 99999.  Larger soft costs are displayed
as 99999.  To assist with this, function
@ID @C {
double KheCostShow(KHE_COST combined_cost);
}
returns a value which, when printed with @C { printf } format
@C { "%.5f" }, prints the cost in this format.
# @PP
# By changing symbol @C { KHE_COST_SHOW_DIGITS } at the start of
# @C { khe.h }, the number of decimal places can be changed.  By
# default its value is 9999.  By changing it to, say, 99999, the
# value returned by @C { KheCostShow } will be suitable for
# printing with format @C { "%.5f" }, and so on.
@PP
These functions assume that both components of the cost are
non-negative.  There is no problem with negative combined
costs in themselves, but when a hard and soft cost are
combined together, if either is negative they may be
different if they are separated again.
@End @Section

@Section
    @Title { Monitors }
    @Tag { monitoring_monitors }
@Begin
@LP
A @I { monitor } is an object, of type @C { KHE_MONITOR }, that
monitors one part of a solution:  typically, one point of application
of one constraint.  It contains the usual back pointer and
visit number:
@ID @C {
void KheMonitorSetBack(KHE_MONITOR m, void *back);
void *KheMonitorBack(KHE_MONITOR m);
void KheMonitorSetVisitNum(KHE_MONITOR m, int num);
int KheMonitorVisitNum(KHE_MONITOR m);
bool KheMonitorVisited(KHE_MONITOR m, int slack);
void KheMonitorVisit(KHE_MONITOR m);
void KheMonitorUnVisit(KHE_MONITOR m);
}
Operations
@ID @C {
KHE_SOLN KheMonitorSoln(KHE_MONITOR m);
int KheMonitorSolnIndex(KHE_MONITOR m);
KHE_COST KheMonitorCost(KHE_MONITOR m);
KHE_COST KheMonitorLowerBound(KHE_MONITOR m);
}
return the enclosing solution, the index of @C { m } in that
solution, the cost of what @C { m } is monitoring (kept up to
date by KHE as the solution changes), and a constant lower
bound on @C { KheMonitorCost }, which is usually 0 but will
be non-zero when KHE can prove the lower bound easily.
# For example,
# an assign time monitor monitors one point of application of
# one assign time constraint (one event).  Its cost is the value
# of the cost function of its constraint applied to a number of
# deviations which is the total duration of meets derived from its
# event which are not assigned a time.
@PP
Type @C { KHE_MONITOR } is the abstract supertype of many
concrete subtypes, with these tags:
# whose type is @C { KHE_MONITOR_TAG }:
@ID -1px @Break @C {
typedef enum {
  KHE_ASSIGN_RESOURCE_MONITOR_TAG,
  KHE_ASSIGN_TIME_MONITOR_TAG,
  KHE_SPLIT_EVENTS_MONITOR_TAG,
  KHE_DISTRIBUTE_SPLIT_EVENTS_MONITOR_TAG,
  KHE_PREFER_RESOURCES_MONITOR_TAG,
  KHE_PREFER_TIMES_MONITOR_TAG,
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR_TAG,
  KHE_SPREAD_EVENTS_MONITOR_TAG,
  KHE_LINK_EVENTS_MONITOR_TAG,
  KHE_ORDER_EVENTS_MONITOR_TAG,
  KHE_AVOID_CLASHES_MONITOR_TAG,
  KHE_AVOID_UNAVAILABLE_TIMES_MONITOR_TAG,
  KHE_LIMIT_IDLE_TIMES_MONITOR_TAG,
  KHE_CLUSTER_BUSY_TIMES_MONITOR_TAG,
  KHE_LIMIT_BUSY_TIMES_MONITOR_TAG,
  KHE_LIMIT_WORKLOAD_MONITOR_TAG,
  KHE_TIMETABLE_MONITOR_TAG,
  KHE_TIME_GROUP_MONITOR_TAG,
  KHE_ORDINARY_DEMAND_MONITOR_TAG,
  KHE_WORKLOAD_DEMAND_MONITOR_TAG,
  KHE_EVENNESS_MONITOR_TAG,
  KHE_GROUP_MONITOR_TAG,
  KHE_MONITOR_TAG_COUNT
} KHE_MONITOR_TAG;
}
Each monitor object contains a tag identifying its subtype, returned by
@ID @C {
KHE_MONITOR_TAG KheMonitorTag(KHE_MONITOR m);
}
Monitors of the first sixteen types monitor one point of application of
one constraint; their cost is the total cost of deviations at that point.
They are described in detail in later sections of this chapter.  Monitors
of the last six types (from @C { KHE_TIMETABLE_MONITOR_TAG } onwards) do
not monitor constraints.  Timetable monitors hold the timetables of
resources and events (Section {@NumberOf monitoring_timetables}); time
group monitors (Section {@NumberOf monitoring_timegroup}) are used within
them.  Ordinary and workload demand monitors monitor matchings, and
evenness monitors monitor evenness (Chapter {@NumberOf matchings}).  Group
monitors group together other monitors (Section {@NumberOf monitoring.group}).
The last value is not a tag; it is a count of the number of monitor
types, allowing code of the form
@ID @C {
for( tag = 0;  tag < KHE_MONITOR_TAG_COUNT;  tag++ )
  ... do something for monitors of type tag ...
}
For those monitors that monitor a point of application of a constraint,
functions
@ID @C {
KHE_CONSTRAINT KheMonitorConstraint(KHE_MONITOR m);
char *KheMonitorAppliesToName(KHE_MONITOR m);
}
return the constraint and the name of the point of application
(if this point is an event resource, the name of the enclosing
event is returned).  For other monitors they return @C { NULL }.
Each constraint monitor also has functions which return the
specific constraint and point of application.
# @PP
# The cost of a monitor is a function of a set of @I { deviations },
# which are non-negative integers.  A deviation could be 0, although
# the cost functions all have the property that adding or removing a
# 0 from a set of deviations does not change the cost.  The deviations
# can be obtained by calling
# @ID @C {
# int KheMonitorDeviationCount(KHE_MONITOR m);
# int KheMonitorDeviation(KHE_MONITOR m, int i);
# char *KheMonitorDeviationDescription(KHE_MONITOR m, int i);
# }
# The first two return the number of deviations and the @C { i }th
# deviation; the third returns a description of the @C { i }th deviation.
# These functions are intended for reporting, not solving, and may be slow.
# @PP
# Some monitors, for example timetable monitors and group monitors, do not
# monitor constraints or calculate deviations, and so they return 0 for
# @C { KheMonitorDeviationCount }.  Most monitors have one deviation,
# and they return 1 for @C { KheMonitorDeviationCount } and @C { NULL }
# for @C { KheMonitorDeviationDescription }.  A few monitors have
# multiple deviations:  avoid clashes monitors, which have one deviation
# for each time where there is a clash (described by the name of the
# time), and limit busy times and spread events monitors, which have
# one deviation for each time group monitored (described by the name
# of the time group).
@PP
The cost of a monitor is a function of its @I { deviation }, which is
a non-negative integer.  This value can be obtained by calling
@ID @C {
int KheMonitorDeviation(KHE_MONITOR m);
char *KheMonitorDeviationDescription(KHE_MONITOR m);
}
These functions are intended for reporting, not solving.
@C { KheMonitorDeviation } returns the deviation, and
@C { KheMonitorDeviationDescription } returns a description of it:
an expression, augmented with brief text, showing how it is calculated.
The result string is stored in heap memory and may be freed by passing
it to @C { MFree } (Appendix {@NumberOf modules.m}) after use.
# @PP
# Although a deviation is a single integer, it can often be divided
# into a sum of @I { deviation parts }.  Just what one part consists
# of depends on the constraint type, and is not formally defined by
# KHE; deviation parts are intended for use only when reporting, to
# diagnose how a deviation came about, not for solving or calculating
# costs formally.  The following functions give access to the parts
# of a monitor's deviation:
# @ID @C {
# int KheMonitorDeviationPartCount(KHE_MONITOR m);
# void KheMonitorDeviationPart(KHE_MONITOR m, int i,
#   int *value, char **description);
# }
# @C { KheMonitorDeviationPartCount } returns the number of parts;
# @C { KheMonitorDeviationPart } sets @C { *value } to the value of the
# @C { i }'th part, and @C { *description } to a description of that part
# when there is one, and to @C { NULL } when there isn't.  For example,
# the description might be the Id of an event or time.  The sum of the
# values over all @C { i } equals @C { KheMonitorDeviation(m) }.  Some
# parts may have value 0, and it is usually best to skip those.
@PP
To visit the full set of monitors monitoring @C { soln }, call
@ID @C {
int KheSolnMonitorCount(KHE_SOLN soln);
KHE_MONITOR KheSolnMonitor(KHE_SOLN soln, int i);
}
Although KHE does not fully specify the order in which these monitors
appear, it does guarantee that the monitors which monitor constraints
will appear together in the list in the order that their constraints
appear in the input.  It is best to select these monitors by testing
whether the result of @C { KheMonitorConstraint } above is non-@C { NULL }.
@PP
To debug a monitor @C { m } with a given verbosity and indent, calll
@ID { 0.98 1.0 } @Scale @C {
void KheMonitorDebug(KHE_MONITOR m, int verbosity, int indent, FILE *fp);
}
The output starts with a @C { G }, @F { A } or @F { D } indicating
whether the monitor is a group monitor, an attached non-group monitor,
or a detached non-group monitor.  This is followed by the number of paths
up from the monitor to the solution (Section {@NumberOf monitoring.group}),
usually 0 or 1.  Then comes the monitor's tag and cost, then other
information depending on the monitor type and verbosity.  There is also
@ID @C {
char *KheMonitorTagShow(KHE_MONITOR_TAG tag);
}
which returns a string representation of @C { tag }.  In practice
a more useful function is
@ID @C {
char *KheMonitorLabel(KHE_MONITOR m);
}
This returns @C { KheMonitorTagShow(KheMonitorTag(m)) } if @C { m }
is not a group monitor, and @C { m }'s subtag label if @C { m } is
a group monitor.
@End @Section

@Section
    @Title { Attaching, detaching, and provably zero fixed cost }
    @Tag { monitoring.attach }
@Begin
@LP
For a monitor to be updated when the solution changes, there must
be linkages from the appropriate points within the solution to
the monitor.  When these linkages are present, the monitor is
said to be @I { attached to the solution }, or just @I { attached }.
Monitors are attached to begin with, but they can be detached at any
time, and even reattached later, by calling
@ID @C {
void KheMonitorDetachFromSoln(KHE_MONITOR m);
void KheMonitorAttachToSoln(KHE_MONITOR m);
}
Even when detached, a monitor remembers which parts of the solution
it is supposed to monitor, so the attach operation does not have to
tell the monitor where to attach itself.  To find out whether a
monitor is currently attached or detached, call
@ID @C {
bool KheMonitorAttachedToSoln(KHE_MONITOR m);
}
These three operations apply to all kinds of monitors except the
group monitors of Section {@NumberOf monitoring.group}, to which
the concept of attachment to the solution does not apply.  Another
function, highly recommended for calling at the end of a solve, is
@ID @C {
void KheSolnEnsureOfficialCost(KHE_SOLN soln);
}
This ensures that all constraint monitors are both attached to the
solution and reporting their cost to the solution, directly or
indirectly via group monitors, and that all demand and evenness
monitors are detached from the solution, guaranteeing that the
solution cost is the official cost.
@PP
While a monitor is detached, it receives no information about changes
to the solution, and, by definition, its cost is 0.  Detaching a
monitor may therefore change its cost.  If there is a change in
cost, it is reported to the monitor's parents (if it has any) as
usual.  Conversely, attaching a monitor brings it up to date with
the current state of the solution, which again may change its cost;
and again, if there is a change in cost it is reported to its parents
(if it has any).
@PP
There are two main reasons for detaching a monitor.  First, the user
might make a deliberate choice to ignore some constraints.  For
example, a solver that works in two phases, first finding a solution
that satisfies the hard constraints, and then attacking the soft ones,
might detach the monitors for the soft constraints during its first
phase.  An example of this kind of deliberate choice is KHE's matching
feature (Chapter {@NumberOf matchings}), which is implemented with
monitors.  Unlike other monitors, matching monitors are detached
initially.  KHE makes this choice deliberately, on the grounds that
the cost of the matching is not officially part of the cost function.
@PP
The second reason for detaching a monitor is that it may be clear
that its cost will be zero for a long time.  In that case, detaching
it means that no time is spent keeping it up to date, yet it still
reports the correct cost.  For example, if the meets of one point
of application of a link events constraint are assigned to each
other and those assignments will not be removed, then it is safe
to save time by detaching the corresponding monitor.
@PP
This reasoning was formerly embodied in a function called
@C { KheMonitorAttachCheck }, which assumed that certain elements
of the solution were unlikely to change, and detached monitors
accordingly.  @C { KheMonitorAttachCheck } has been withdrawn;
the equivalent functionality is now obtained, more reliably, by
calling the @C { Fix } and @C { UnFix } functions, as follows.
# @PP
# This reasoning is embodied in function
# @ID @C {
# void KheMonitorAttach Check(KHE_MONITOR m);
# }
# It assumes that certain elements of the solution will not change
# for a long time:  the way that events are split into meets,
# non-@C { NULL } assignments to meets that do not lie in nodes,
# non-@C { NULL } assignments to follower tasks, and meet and task
# domains.  It checks whether, under that assumption, the cost of
# monitor @C { m } must be and remain 0.  If so, it detaches @C { m }
# unless it is already detached; if not, it attaches @C { m } unless
# it is already attached.
# @PP
# The assumption proves nothing about the future cost of monitors of
# most types.  For example, it does not prevent the next time or
# resource assignment from producing a clash (except in circumstances
# too rare to be worth checking for).  In these cases,
# @C { KheMonitorAttach Check } merely attaches @C { m } if it is not
# already attached.  For each monitor type where more is done, the
# details are given as part of the description of that monitor type
# later in this chapter.
# @PP
# Instead of calling @C { KheMonitorAttach Check }, it is easier and much
# more reliable to indicate that certain parts of the solution will not
# change soon by fixing them (Section {@NumberOf solutions.overview}).
# Fixing causes attached monitors whose cost is 0 and must remain 0
# while the current fixes are in place to be detached, and unfixing
# causes detached monitors whose cost need not be 0 given the unfixing
# to be attached.  For each monitor type where something is done in
# response to fixes and unfixes, the details appear as part of the
# description of that monitor type later in this chapter.
# @End @Section
# 
# @Section
#     @Title { Provably zero fixed cost and fixing }
#     @Tag { monitoring.zero }
# @Begin
# @LP
@PP
# A monitor has @I { provably zero fixed cost } if enough of the
# solution is currently fixed (by calls to @C { KheMeetSplitFix },
# @C { KheMeetAssignFix }, @C { KheMeetDomainFix }, @C { KheTaskAssignFix },
# and @C { KheTaskDomainFix }) to allow KHE to prove that the monitor must
A monitor has @I { provably zero fixed cost } if enough of the
solution is currently fixed (by calls to @C { KheMeetAssignFix }
and @C { KheTaskAssignFix }) to allow KHE to prove that the monitor must
have cost 0 while those fixes remain.  For each kind of monitor, either
a specific definition of when that kind of monitor has provably zero
fixed cost is given below, or else that kind never has provably zero
fixed cost.
@PP
When one of the fixing operations just listed is called, after
doing the actual fixing KHE ensures that all monitors which did not
have provably zero fixed cost before but now do are detached.  When
one of the corresponding unfix operations is called, after
doing the actual unfixing it ensures that all monitors which had
provably zero fixed cost before but now do not are attached.  So
there is no risk that detaching these monitors could lead to cost
errors; as soon as unfixes make a non-zero cost possible, they are
attached again.
@End @Section

@Section
    @Title { Event monitors }
    @Tag { monitoring.event_monitors }
@Begin
@LP
An @I { event monitor } monitors one or more events.  The set of
monitors (attached or unattached) which monitor a given event may
be found by calling
@ID @C {
int KheSolnEventMonitorCount(KHE_SOLN soln, KHE_EVENT e);
KHE_MONITOR KheSolnEventMonitor(KHE_SOLN soln, KHE_EVENT e, int i);
}
These return the number of monitors that monitor @C { e } in
@C { soln }, and the @C { i }th of these, as usual.  The timetable
monitor for event @C { e } (Section {@NumberOf monitoring_timetables})
is not visited by these functions; it may be retrieved by calling
@C { KheEventTimetableMonitor }.
@PP
The total cost of these monitors measures how well @C { e } is
timetabled.  Functions
@ID @C {
KHE_COST KheSolnEventCost(KHE_SOLN soln, KHE_EVENT e);
KHE_COST KheSolnEventMonitorCost(KHE_SOLN soln, KHE_EVENT e,
  KHE_MONITOR_TAG tag);
}
return the total cost of all the monitors monitoring @C { e },
and the total cost of all monitors monitoring @C { e } of a
specific type, defined by @C { tag }.  @C { KheSolnEventMonitorCost }
returns 0 when @C { tag } does not specify one of the monitor
types in the following subsections.
@PP
Each point of application of a spread events constraint or link
events constraint is one event group, and a monitor of these
kinds appears on the list of monitors of each of the events in
its event group.  Similarly, an order events monitor appears
on the list of monitors of both of the events it monitors.  If
@C { KheSolnEventCost(soln, e) } is summed over all events, the cost
of such monitors is counted repeatedly, and the total may exceed
the total cost of all event monitors.
@PP
The following subsections list the various kinds of event
monitors and the details specific to each of them.  Their types
(@C { KHE_SPLIT_EVENTS_MONITOR } and so on) may be obtained by
downcasting from @C { KHE_MONITOR } after checking the type tag.
@BeginSubSections

@SubSection
    @Title { Split events monitors }
@Begin
@LP
A split events monitor has tag @C { KHE_SPLIT_EVENTS_MONITOR_TAG }
and monitors an event which is one point of application of one
split events constraint.  Functions
@ID @C {
KHE_SPLIT_EVENTS_CONSTRAINT KheSplitEventsMonitorConstraint(
  KHE_SPLIT_EVENTS_MONITOR m);
KHE_EVENT KheSplitEventsMonitorEvent(KHE_SPLIT_EVENTS_MONITOR m);
}
return the split events constraint and event being monitored, and
@ID {0.97 1.0} @Scale @C {
void KheSplitEventsMonitorLimits(KHE_SPLIT_EVENTS_MONITOR m,
  int *min_duration, int *max_duration, int *min_amount, int *max_amount);
}
sets the four last variables to the corresponding attributes of the
monitor's constraint.
# @PP
# Since the state of splitting is assumed by @C { KheMonitorAttach Check }
# to be fixed, all it needs to do here is ensure that @C { m } is attached,
# then detach it if its cost is 0.  In this case there is no efficiency
# gain from detaching @C { m }, since @C { m } only fires when events are
# split and merged.
# @PP
# When a call to @C { KheMeetSplitFix } takes the solution from a state in
# which meet splitting is not fixed in at least one meet derived from an
# event @C { e } to a state in which meet splitting is fixed in every meet
# derived from @C { e }, every attached split events monitor which monitors
# @C { e } and has cost 0 is detached.  When a call to @C { KheMeetSplitUnFix }
# takes a solution between those same two states in the opposite direction,
# every unattached split events monitor which monitors @C { e } is attached.
# @PP
# A split events monitor has provably zero fixed cost when splitting is fixed
# in all the meets derived from the event it monitors, and its cost is 0 when
# attached.  @C { KheMeetSplitFix } and @C { KheMeetSplitUnFix } may detach
# and attach split events monitors.
@End @SubSection

@SubSection
    @Title { Distribute split events monitors }
@Begin
@LP
A distribute split events monitor has tag
@C { KHE_DISTRIBUTE_SPLIT_EVENTS_MONITOR_TAG } and monitors
one point of application of a distribute split events constraint
(one event).  Functions
@ID @C {
KHE_DISTRIBUTE_SPLIT_EVENTS_CONSTRAINT
  KheDistributeSplitEventsMonitorConstraint(
  KHE_DISTRIBUTE_SPLIT_EVENTS_MONITOR m);
KHE_EVENT KheDistributeSplitEventsMonitorEvent(
  KHE_DISTRIBUTE_SPLIT_EVENTS_MONITOR m);
}
return the constraint and event being monitored, and
@ID @C {
void KheDistributeEventsMonitorLimits(
  KHE_DISTRIBUTE_SPLIT_EVENTS_MONITOR m,
  int *duration, int *minimum, int *maximum, int *meet_count);
}
sets @C { *duration }, @C { *minimum }, and @C { *maximum } to
the corresponding attributes of the monitor's constraint, and
@C { *meet_count } to the number of meets derived from the
monitored event whose duration is @C { *duration } (or to the
total number of meets if @C { *duration } is @C { KHE_ANY_DURATION }).
# @C { KheMonitorAttach Check } behaves like it does for split events
# monitors:  it first ensures that @C { m } is attached, then detaches
# it if its cost is 0.
# @PP
# A distribute split events monitor has provably zero fixed cost when
# splitting is fixed in all the meets derived from the event it
# monitors, and its cost is 0 when attached.  @C { KheMeetSplitFix }
# and @C { KheMeetSplitUnFix } may detach and attach distribute
# split events monitors.
@End @SubSection

@SubSection
    @Title { Assign time monitors }
@Begin
@LP
An assign time monitor has tag @C { KHE_ASSIGN_TIME_MONITOR_TAG }
and monitors an event which is one point of application of one
assign time constraint.  Functions
@ID @C {
KHE_ASSIGN_TIME_CONSTRAINT KheAssignTimeMonitorConstraint(
  KHE_ASSIGN_TIME_MONITOR m);
KHE_EVENT KheAssignTimeMonitorEvent(KHE_ASSIGN_TIME_MONITOR m);
}
return the assign time constraint and event being monitored.
@PP
An assign time monitor does not have provably zero fixed cost when
@C { KheMeetAssignFix } has been called for each of the meets
derived from the event it monitors and the monitor has cost 0 when
attached, because the assignments may be to other meets whose
assignments are not fixed.  The full assignment paths leading
out of the monitored meets would need to be fixed;  but that
would be awkward to implement and give no efficiency payoff,
because then the monitor would never be updated anyway.  So
an assign time monitor never has provably zero cost.
@End @SubSection

@SubSection
    @Title { Prefer times monitors }
@Begin
@LP
A prefer times monitor has tag @C { KHE_PREFER_TIMES_MONITOR_TAG }
and monitors an event which is one point of application of one
prefer times constraint.  Functions
@ID @C {
KHE_PREFER_TIMES_CONSTRAINT KhePreferTimesMonitorConstraint(
  KHE_PREFER_TIMES_MONITOR m);
KHE_EVENT KhePreferTimesMonitorEvent(KHE_PREFER_TIMES_MONITOR m);
}
return the prefer times constraint and event being monitored.
# @PP
# @C { KheMonitorAttach Check } examines the domains of the meets
# of @C { m }'s event whose durations are of interest to @C { m }'s
# constraint.  If all of these domains are subsets of @C { m }'s
# constraint's domain, then @C { m } may be detached.  A more refined
# check would use the domains of the meets' lea der meets, but
# complications with offsets have ruled that out, at least for now.
# @PP
# A prefer times monitor has provably zero fixed cost when, for each
# meet derived from the event it monitors, either that meet's splits are
# fixed and its duration is not one that the monitor monitors, or its
# domain is fixed to a subset of the set of times defined by the monitor's
# constraint.  @C { KheMeetSplitFix } and @C { KheMeetDomainFix } may
# detach prefer times monitors, and @C { KheMeetSplitUnFix } and
# @C { KheMeetDomainUnFix } may attach them.  There is a small efficiency
# payoff when the meets' assignments change within the domains.
@End @SubSection

@SubSection
    @Title { Spread events monitors }
@Begin
@LP
A spread events monitor has tag @C { KHE_SPREAD_EVENTS_MONITOR_TAG }
and monitors an event group which is one point of application of a
spread events constraint.  It appears in the list of monitors of
all the events in its event group.  Functions
@ID @C {
KHE_SPREAD_EVENTS_CONSTRAINT KheSpreadEventsMonitorConstraint(
  KHE_SPREAD_EVENTS_MONITOR m);
KHE_EVENT_GROUP KheSpreadEventsMonitorEventGroup(
  KHE_SPREAD_EVENTS_MONITOR m);
}
return the spread events constraint and event group being monitored.
There are also
@ID { 0.96 1.0 } @Scale @C {
int KheSpreadEventsMonitorTimeGroupCount(KHE_SPREAD_EVENTS_MONITOR m);
void KheSpreadEventsMonitorTimeGroup(KHE_SPREAD_EVENTS_MONITOR m, int i,
  KHE_TIME_GROUP *time_group, int *minimum, int *maximum, int *incidences);
}
The first returns the number of time groups (as in the corresponding
constraint).  The second returns the @C { i }'th time group and the
minimum and maximum number of meets wanted there (again,
as in the constraint), plus the current number of meets
incident on that time group.  If @C { *incidences } is less than
@C { *minimum } or more than @C { *maximum }, a cost is incurred.
@End @SubSection

@SubSection
    @Title { Link events monitors }
@Begin
@LP
A link events monitor has tag @C { KHE_LINK_EVENTS_MONITOR_TAG }
and monitors an event group which is one point of application of
a link events constraint.  It appears in the list of monitors of
all the events in its event group.  Functions
@ID @C {
KHE_LINK_EVENTS_CONSTRAINT KheLinkEventsMonitorConstraint(
  KHE_LINK_EVENTS_MONITOR m);
KHE_EVENT_GROUP KheLinkEventsMonitorEventGroup(
  KHE_LINK_EVENTS_MONITOR m);
}
return the link events constraint and event group being monitored.
# @PP
# @C { KheMonitorAttach Check } assumes that assignments of meets not
# lying in nodes will not change for a long time.  For each meet of each
# event monitored by @C { m } it forms a triple, consisting of the
# duration of the meet, its lead er meet as returned by @C { KheMeetLeader }
# (Section {@NumberOf solutions.meets.assignment}), and its offset
# into its lead er meet.  If any triple cannot be built because some
# meet has no lead er meet, then @C { m } should remain attached.
# Otherwise, if for each event @C { e } monitored by @C { m } the set
# of triples formed from the meets derived from @C { e } is the
# same, then @C { m } can be detached.
# @PP
# Detaching link events monitors is arguably the most important
# service provided by @C { KheMonitorAttach Check }.  This is
# because keeping these monitors up to date is slow, despite the
# author's best efforts to optimize.  When the times of a set of
# linked events change together, an attached link events monitor
# receives the changes one by one, forcing it through a tedious
# sequence of cost modifications beginning and ending with 0.
@PP
A link events monitor has provably zero fixed cost when following
to the end the chains of fixed assignments out of the meets of the
events it monitors produces the same result for each event:  the
same offsets and durations within the same final meets.
@C { KheMeetAssignFix } and @C { KheMeetAssignUnFix }
may detach and attach link events monitors.
@PP
Detaching link events monitors is the most important service provided
by fixing.  Keeping these monitors up to date is slow, despite the
author's best efforts to optimize.  When the times of a set of linked
events change together, an attached link events monitor receives the
changes one by one, forcing it through a tedious sequence of cost
changes beginning and ending with 0.
@End @SubSection

@SubSection
    @Title { Order events monitors }
@Begin
@LP
An order events monitor has tag @C { KHE_ORDER_EVENTS_MONITOR_TAG }
and monitors two events which together constitute one point of
application of an order events constraint.  It appears in the
list of monitors of both events.  Functions
@ID @C {
KHE_ORDER_EVENTS_CONSTRAINT KheOrderEventsMonitorConstraint(
  KHE_ORDER_EVENTS_MONITOR m);
KHE_EVENT KheOrderEventsMonitorFirstEvent(KHE_ORDER_EVENTS_MONITOR m);
KHE_EVENT KheOrderEventsMonitorSecondEvent(KHE_ORDER_EVENTS_MONITOR m);
int KheOrderEventsMonitorMinSeparation(KHE_ORDER_EVENTS_MONITOR m);
int KheOrderEventsMonitorMaxSeparation(KHE_ORDER_EVENTS_MONITOR m);
}
return the constraint being monitored and the four attributes of the
monitor:  the two events monitored, and the minimum and maximum separations.
# @PP
# @C { KheMonitorAttach Check } assumes that assignments of meets not
# lying in nodes will not change for a long time.  To carry out its
# work on an order events monitor, it checks whether both events
# contain exactly one meet, and if so whether those meets have the
# same lead er meet, as returned by @C { KheMeetLeader }
# (Section {@NumberOf solutions.meets.assignment}), and if so whether
# their separation (the offset into the lead er meet of the second meet,
# minus the duration plus offset into the lead er meet of the first meet)
# is in the legal range.  If so, then @C { m } can be detached,
# otherwise @C { m } should remain attached.
@PP
An order events monitor has provably zero fixed cost when both of its
events are broken into a single meet, following to the end the chains
of fixed assignments out of those two meets leads to the same final
meet, and their separation (the offset into the final meet of the
second meet, minus the duration plus offset into the final meet of
the first meet) is in the legal range.  @C { KheMeetAssignFix } and
@C { KheMeetAssignUnFix } may detach and attach order events monitors.
# Alternatively,
# the final meets may differ if they are both cycle meets; a
# different definition of separation is used then, the obvious one
# based on the index numbers of the times the meets are assigned to.
@End @SubSection

@EndSubSections
@End @Section

@Section
    @Title { Event resource monitors }
    @Tag { monitoring.event_resource_monitors }
@Begin
@LP
An @I { event resource monitor } monitors one or more event resources.
The monitors (attached or unattached) which monitor a given event
resource may be visited by
@ID {0.95 1.0} @Scale @C {
int KheSolnEventResourceMonitorCount(KHE_SOLN soln, KHE_EVENT_RESOURCE er);
KHE_MONITOR KheSolnEventResourceMonitor(KHE_SOLN soln,
  KHE_EVENT_RESOURCE er, int i);
}
The total cost of these monitors measures how well @C { er } is
timetabled.  Functions
@ID @C {
KHE_COST KheSolnEventResourceCost(KHE_SOLN soln, KHE_EVENT_RESOURCE er);
KHE_COST KheSolnEventResourceMonitorCost(KHE_SOLN soln,
  KHE_EVENT_RESOURCE er, KHE_MONITOR_TAG tag);
}
return the total cost of all the monitors monitoring @C { er }, and
the total cost of all monitors monitoring @C { er } of a specific
type, defined by @C { tag }.  @C { KheSolnEventResourceMonitorCost }
returns 0 when @C { tag } does not specify one of the monitor types
in the following subsections.
@PP
Each point of application of an avoid split assignments constraint is a
whole set of event resources, and a monitor of this kind is attached to each
of the event resources in its set.  If @C { KheSolnEventResourceCost(soln, er) }
is summed over all event resources, such a monitor is counted repeatedly,
so the total may exceed the total cost of all event resource monitors.
@PP
The following subsections list the various kinds of event resource
monitors and the details specific to each of them.  Their types
(@C { KHE_ASSIGN_RESOURCE_MONITOR } and so on) may be obtained by
downcasting from @C { KHE_MONITOR } after checking the type tag.
@BeginSubSections

@SubSection
    @Title { Assign resource monitors }
@Begin
@LP
An assign resource monitor has tag @C { KHE_ASSIGN_RESOURCE_MONITOR_TAG }
and monitors an event resource which is one point of application of
one assign resource constraint.  Functions
@ID @C {
KHE_ASSIGN_RESOURCE_CONSTRAINT KheAssignResourceMonitorConstraint(
  KHE_ASSIGN_RESOURCE_MONITOR m);
KHE_EVENT_RESOURCE KheAssignResourceMonitorEventResource(
  KHE_ASSIGN_RESOURCE_MONITOR m)
}
return the assign resource constraint and event resource being
monitored.  Like assign time monitors, assign resource monitors
are never considered to have provably zero fixed cost.
@End @SubSection

@SubSection
    @Title { Prefer resources monitors }
@Begin
@LP
A prefer resources monitor has tag @C { KHE_PREFER_RESOURCES_MONITOR_TAG }
and monitors an event resource which is one point of application of one
prefer resources constraint.  Functions
@ID @C {
KHE_PREFER_RESOURCES_CONSTRAINT KhePreferResourcesMonitorConstraint(
  KHE_PREFER_RESOURCES_MONITOR m);
KHE_EVENT_RESOURCE KhePreferResourcesMonitorEventResource(
  KHE_PREFER_RESOURCES_MONITOR m);
}
return the prefer resources constraint and event resource being monitored.
# @PP
# For each task monitored by @C { m }, @C { KheMonitorAttach Check } follows
# the chain of assignments leading out of that task to the lead er task.
# These assignments, and the domain of the lead er task, are assumed to be
# unchanging.  If all the lead ers' domains are subsets of the domain of
# @C { m }'s constraint, then no assignments to lead er tasks can violate
# @C { m }, and @C { KheMonitorAttach Check } ensures that @C { m } is
# detached.  Otherwise it ensures that @C { m } is attached.
# @PP
# A prefer resources monitor has provably zero fixed cost when resource
# domains are fixed in the tasks derived from its event resource, to
# subsets of the set of resources of its constraint.
# @C { KheTaskDomainFix } and @C { KheTaskDomainUnFix } may detach and
# attach prefer resources monitors.  There is a small efficiency payoff
# when the tasks' assignments change within the domains.
@End @SubSection

@SubSection
    @Title { Avoid split assignments monitors }
@Begin
@LP
The operations for building avoid split assignments constraints accept
a role and event groups, as required when reading XML.  However, they
also accept a set of event resources, and these are what are actually
used.  Accordingly, one avoid split assignments monitor monitors a
set of event resources, and appears in the list of monitors of each
of those event resources.  Functions
@ID -1.0px @Break @C {
KHE_AVOID_SPLIT_ASSIGNMENTS_CONSTRAINT
  KheAvoidSplitAssignmentsMonitorConstraint(
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR m)
int KheAvoidSplitAssignmentsMonitorEventGroupIndex(
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR m)
}
return the constraint and the index of the set of event resources
being monitored, suitable for passing to functions
@C { KheAvoidSplitAssignmentsConstraintEventResourceCount }
and @C { KheAvoidSplitAssignmentsConstraintEventResource }
(Section {@NumberOf avoid_split_assts}).  There are also
@ID @C {
int KheAvoidSplitAssignmentsMonitorResourceCount(
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR m);
KHE_RESOURCE KheAvoidSplitAssignmentsMonitorResource(
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR m, int i);
int KheAvoidSplitAssignmentsMonitorResourceMultiplicity(
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR m, int i);
}
The first returns the number of distinct resources currently assigned
to tasks monitored by @C { m }.  If @C { m } is a defect this number
will be at least 2.  The second and third return the @C { i }th of
these distinct resources (in an arbitrary order) and the number of
tasks monitored by @C { m } to which that resource is currently
assigned.  The monitor does not record which tasks those are.
# @PP
# For each task monitored by @C { m }, @C { KheMonitorAssignCheck }
# follows the chain of assignments from the task to its lead er task.
# These chains are assumed to be unchanging.  If they all end at the
# same lead er task, then no assignments can violate @C { m }, and
# @C { KheMonitorAssignCheck } ensures that @C { m } is detached.
# Otherwise it ensures that @C { m } is attached.
@PP
An avoid split assignments monitor has provably zero fixed cost when the
paths of fixed assignments leading out of the tasks it monitors have the
same endpoint.  @C { KheTaskAssignFix } and @C { KheTaskAssignUnFix }
may detach and attach avoid split assignments monitors.  Similarly to
link events monitors, the efficiency payoff is significant.
@End @SubSection

@EndSubSections
@End @Section

@Section
    @Title { Resource monitors }
    @Tag { monitoring.resource_monitors }
@Begin
@LP
A @I { resource monitor } monitors a resource.  The set of monitors
(attached or unattached) which monitor a given resource may be
visited by calling
@ID {0.95 1.0} @Scale @C {
int KheSolnResourceMonitorCount(KHE_SOLN soln, KHE_RESOURCE r);
KHE_MONITOR KheSolnResourceMonitor(KHE_SOLN soln, KHE_RESOURCE r, int i);
}
The total cost of these monitors measures how well @C { r } is
timetabled.  Functions
@ID @C {
KHE_COST KheSolnResourceCost(KHE_SOLN soln, KHE_RESOURCE r);
KHE_COST KheSolnResourceMonitorCost(KHE_SOLN soln, KHE_RESOURCE r,
  KHE_MONITOR_TAG tag);
}
return the total cost of all the monitors monitoring @C { r }, and
the total cost of all monitors monitoring @C { r } of a specific
type, defined by @C { tag }.  @C { KheSolnResourceMonitorCost } returns
0 when @C { tag } does not specify one of the monitor types in the
following subsections.
@PP
The following subsections list the kinds of resource monitors
and their features.  Their types (@C { KHE_AVOID_CLASHES_MONITOR }
etc.) may be obtained by
downcasting from @C { KHE_MONITOR } after checking the type tag.
Monitors of type @C { KHE_WORKLOAD_DEMAND_MONITOR }, defined in
Section {@NumberOf matchings.workload}, are also visited by
@C { KheSolnResourceMonitorCount } and @C { KheSolnResourceMonitor }.
However, the timetable monitor for a resource is not visited by these
functions; as explained in Section {@NumberOf monitoring_timetables},
it is retrieved by calling @C { KheResourceTimetableMonitor }.
@BeginSubSections

@SubSection
    @Title { Avoid clashes monitors }
@Begin
@LP
An avoid clashes monitor has tag @C { KHE_AVOID_CLASHES_MONITOR_TAG }
and monitors a resource which is one point of application of one
avoid clashes constraint.  Functions
@ID -1.0px @Break @C {
KHE_AVOID_CLASHES_CONSTRAINT KheAvoidClashesMonitorConstraint(
  KHE_AVOID_CLASHES_MONITOR m);
KHE_RESOURCE KheAvoidClashesMonitorResource(
  KHE_AVOID_CLASHES_MONITOR m);
}
return the avoid clashes constraint and resource being monitored.
@PP
An avoid clashes monitor @C { m } may have non-zero
@C { KheMonitorLowerBound(m) }.  Let @M { t } be the total duration
of the events to which @C { m }'s resource is preassigned which either
have preassigned times or are subject to an assign time constraint
of weight greater than @C { m }'s weight.  Then if @M { t } exceeds
the number of times in the cycle, the excess is a lower bound on the
number of defects that @C { m } must have in any reasonable solution
(one in which violations of @C { m } are preferred to violations of
the more expensive assign time constraints).  Converting this number
of defects into a cost using @C { m }'s cost function in the usual
way gives the lower bound.
@End @SubSection

@SubSection
    @Title { Avoid unavailable times monitors }
@Begin
@LP
#An avoid unavailable times monitor has tag
This monitor has tag
@C { KHE_AVOID_UNAVAILABLE_TIMES_MONITOR_TAG } and monitors a resource
which is one point of application of one avoid unavailable times
constraint.  Functions
@ID -1px @Break @C {
KHE_AVOID_UNAVAILABLE_TIMES_CONSTRAINT
  KheAvoidUnavailableTimesMonitorConstraint(
  KHE_AVOID_UNAVAILABLE_TIMES_MONITOR m);
KHE_RESOURCE KheAvoidUnavailableTimesMonitorResource(
  KHE_AVOID_UNAVAILABLE_TIMES_MONITOR m);
}
return the avoid unavailable times constraint and resource being monitored.
@PP
An avoid unavailable times monitor @C { m } may have non-zero
@C { KheMonitorLowerBound(m) }.  Suppose @C { m }'s resource is
subject to an avoid clashes constraint of weight greater than
@C { m }'s weight.  Let @M { t sub 1 } be the total duration of
the events to which @C { m }'s resource is preassigned which either
have preassigned times or are subject to an assign time constraint
of weight greater than @C { m }'s weight.  Let @M { t sub 2 } be
the number of times to be avoided according to @C { m }.  Then if
@M { t sub 1 + t sub 2 } exceeds the number of times in the cycle,
the excess is a lower bound on the number of defects that @C { m }
must have in any reasonable solution (one in which every meet is
assigned a time, and violations of @C { m } are preferred to violations
of the more expensive assign time and avoid clashes constraints).
Converting this number of defects into a cost using @C { m }'s cost
function in the usual way gives the lower bound.
@End @SubSection

@SubSection
    @Title { Limit idle times monitors }
@Begin
@LP
A limit idle times monitor has tag @C { KHE_LIMIT_IDLE_TIMES_MONITOR_TAG }
and monitors a resource which is one point of application of one limit
idle times constraint.  Functions
@ID -1px @Break @C {
KHE_LIMIT_IDLE_TIMES_CONSTRAINT KheLimitIdleTimesMonitorConstraint(
  KHE_LIMIT_IDLE_TIMES_MONITOR m);
KHE_RESOURCE KheLimitIdleTimesMonitorResource(
  KHE_LIMIT_IDLE_TIMES_MONITOR m);
}
return the limit idle times constraint and resource being monitored, and
@ID @C {
int KheLimitIdleTimesMonitorTimeGroupMonitorCount(
  KHE_LIMIT_IDLE_TIMES_MONITOR m);
KHE_TIME_GROUP_MONITOR KheLimitIdleTimesMonitorTimeGroupMonitor(
  KHE_LIMIT_IDLE_TIMES_MONITOR m, int i);
}
visit the time group monitors (Section {@NumberOf monitoring_timegroup})
that @C { m } monitors, one for each time group in the limit idle times
constraint.  These can be used to find out which time groups contain
idle times.
@End @SubSection

@SubSection
    @Title { Cluster busy times monitors }
@Begin
@LP
A cluster busy times monitor has tag @C { KHE_CLUSTER_BUSY_TIMES_MONITOR_TAG }
and monitors a resource which is one point of application of one
cluster busy times constraint.  Functions
@ID @C {
KHE_CLUSTER_BUSY_TIMES_CONSTRAINT KheClusterBusyTimesMonitorConstraint(
  KHE_CLUSTER_BUSY_TIMES_MONITOR m);
KHE_RESOURCE KheClusterBusyTimesMonitorResource(
  KHE_CLUSTER_BUSY_TIMES_MONITOR m);
}
return the cluster busy times constraint and resource being monitored.
Function
@ID @C {
void KheClusterBusyTimesMonitorBusyGroupCount(
  KHE_CLUSTER_BUSY_TIMES_MONITOR m,
  int *busy_group_count, int *minimum, int *maximum);
}
sets @C { *busy_group_count } to the number of busy time groups, and
@C { *minimum } and @C { *maximum } to the @C { Minimum } and
@C { Maximum } attributes of the cluster busy times constraint.  If
@C { m } has non-zero cost, then @C { *busy_group_count < *minimum }
or @C { *busy_group_count > *maximum }.  Functions
@ID @C {
int KheClusterBusyTimesMonitorTimeGroupMonitorCount(
  KHE_CLUSTER_BUSY_TIMES_MONITOR m);
KHE_TIME_GROUP_MONITOR KheClusterBusyTimesMonitorTimeGroupMonitor(
  KHE_CLUSTER_BUSY_TIMES_MONITOR m, int i);
}
visit the time group monitors (Section {@NumberOf monitoring_timegroup})
that @C { m } monitors, one for each time group in the cluster busy times
constraint.  These can be used to find out which time groups are busy.
@End @SubSection

@SubSection
    @Title { Limit busy times monitors }
    @Tag { monitoring.limitbusy }
@Begin
@LP
A limit busy times monitor has tag @C { KHE_LIMIT_BUSY_TIMES_MONITOR }
and monitors a resource which is one point of application of one limit
busy times constraint.  Functions
@ID @C {
KHE_LIMIT_BUSY_TIMES_CONSTRAINT KheLimitBusyTimesMonitorConstraint(
  KHE_LIMIT_BUSY_TIMES_MONITOR m);
KHE_RESOURCE KheLimitBusyTimesMonitorResource(
  KHE_LIMIT_BUSY_TIMES_MONITOR m);
}
return the limit busy times constraint and resource being monitored.
Functions
@ID @C {
int KheLimitBusyTimesMonitorDefectiveTimeGroupCount(
  KHE_LIMIT_BUSY_TIMES_MONITOR m);
void KheLimitBusyTimesMonitorDefectiveTimeGroup(
  KHE_LIMIT_BUSY_TIMES_MONITOR m, int i, KHE_TIME_GROUP *tg,
  int *busy_count, int *minimum, int *maximum);
}
visit the time groups monitored by @C { m } that are currently
defective, in unspecified order.  For each @C { i }, @C { *tg } is
set to one defective time group, @C { *busy_count } is set to the
number of times @C { m }'s resource is busy during @C { *tg }, and
@C { *minimum } and @C { *maximum } are set to the minimum and maximum
values from the constraint; so either the resource is underloaded
during @C { *tg } and @C { *busy_count < *minimum }, or the resource
is overloaded during @C { *tg } and @C { *busy_count > *maximum }.
@PP
Limit busy times monitors contain a @C { ceiling } attribute,
set and retrieved by
@ID @C {
void KheLimitBusyTimesMonitorSetCeiling(KHE_LIMIT_BUSY_TIMES_MONITOR m,
  int ceiling);
int KheLimitBusyTimesMonitorCeiling(KHE_LIMIT_BUSY_TIMES_MONITOR m);
}
When @C { busy_count > ceiling }, the usual formula is overridden:
the deviation is 0.  For why this might be useful, consult
Section {@NumberOf ejection.repair.demand}.  The default value of
@C { ceiling } is @C { INT_MAX }, which effectively turns it off.
If @C { m } is attached when @C { KheLimitBusyTimesMonitorSetCeiling }
is called, it will be detached and reattached by the call.
#@ID @C {
#void KheLimitBusyTimesMonitorMaximumDetachFromSoln(
#  KHE_LIMIT_BUSY_TIMES_MONITOR m);
#void KheLimitBusyTimesMonitorMaximumAttachToSoln(
#  KHE_LIMIT_BUSY_TIMES_MONITOR m);
#bool KheLimitBusyTimesMonitorMaximumAttachedToSoln(
#  KHE_LIMIT_BUSY_TIMES_MONITOR m);
#}
#@C { KheLimitBusyTimesMonitorMaximumDetachFromSoln } amounts to changing
#the maximum to infinity; @C { KheLimitBusyTimesMonitorMaximumAttachToSoln }
#changes it back again.  Both functions may change @C { m }'s cost.  If
#@C { m } is attached, the implementation detaches and reattaches it.
@PP
A limit busy times monitor @C { m } may have non-zero
@C { KheMonitorLowerBound(m) }.  Suppose @C { m }'s resource is
subject to an avoid clashes constraint of weight greater than
@C { m }'s weight.  Let @M { t sub 1 } be the total duration of
the events to which @C { m }'s resource is preassigned which either
have preassigned times or are subject to an assign times constraint
of weight greater than @C { m }'s weight.  Let @M { t sub 2 } be the
number of times in the cycle minus the number of times in @C { m }'s
constraint's domain.  Then at least @M { t sub 1 - t sub 2 } of the
times of the events preassigned to @C { m }'s resource must occur in
time groups limited by @C { m }.  If this exceeds the number of time
groups in @C { m }'s constraint times its @C { Maximum } attribute,
then the excess, converted into a cost using @C { m }'s cost function
in the usual way, gives the lower bound.
@End @SubSection

@SubSection
    @Title { Limit workload monitors }
    @Tag { monitoring_resource_monitors_workload }
@Begin
@LP
A limit workload monitor has tag @C { KHE_LIMIT_WORKLOAD_MONITOR }
and monitors a resource which is one point of application of one
limit workload constraint.  Functions
@ID @C {
KHE_LIMIT_WORKLOAD_CONSTRAINT KheLimitWorkloadMonitorConstraint(
  KHE_LIMIT_WORKLOAD_MONITOR m);
KHE_RESOURCE KheLimitWorkloadMonitorResource(
  KHE_LIMIT_WORKLOAD_MONITOR m);
float KheLimitWorkloadMonitorWorkload(KHE_LIMIT_WORKLOAD_MONITOR m);
}
return the limit workload constraint, the monitored resource,
and its current workload; and
@ID @C {
void KheLimitWorkloadMonitorWorkloadAndLimits(
  KHE_LIMIT_WORKLOAD_MONITOR m, float *workload,
  int *minimum, int *maximum);
}
also returns the workload, plus the minimum and maximum values from
the constraint.
@PP
Limit workload monitors contain a @C { ceiling } attribute,
set and retrieved by
@ID @C {
void KheLimitWorkloadMonitorSetCeiling(KHE_LIMIT_WORKLOAD_MONITOR m,
  int ceiling);
int KheLimitWorkloadMonitorCeiling(KHE_LIMIT_WORKLOAD_MONITOR m);
}
When @C { busy_count > ceiling }, the usual formula is overridden:
the deviation is 0.  For why this might be useful, consult
Section {@NumberOf ejection.repair.demand}.  The default value of
@C { ceiling } is @C { INT_MAX }, which effectively turns it off.
If @C { m } is attached when @C { KheLimitWorkloadMonitorSetCeiling }
is called, it will be detached and reattached by the call.
#@PP
#These functions may be used to suppress monitoring of the maximum limit:
#@ID @C {
#void KheLimitWorkloadMonitorMaximumDetachFromSoln(
#  KHE_LIMIT_WORKLOAD_MONITOR m);
#void KheLimitWorkloadMonitorMaximumAttachToSoln(
#  KHE_LIMIT_WORKLOAD_MONITOR m);
#bool KheLimitWorkloadMonitorMaximumAttachedToSoln(
#  KHE_LIMIT_WORKLOAD_MONITOR m);
#}
#@C { KheLimitWorkloadMonitorMaximumDetachFromSoln } amounts to changing
#the maximum to infinity; @C { KheLimitWorkloadMonitorMaximumAttachToSoln }
#changes it back again.  Both functions may change @C { m }'s cost.  If
#@C { m } is attached, the implementation detaches and reattaches it.
@PP
A limit workload monitor @C { m } may have non-zero
@C { KheMonitorLowerBound(m) }.  Add up the workloads of the tasks
to which @C { m }'s resource is preassigned.  If this exceeds the
maximum of the corresponding limit workload constraint, converting
the excess into a cost using @C { m }'s cost function in the usual
way gives the lower bound.
@End @SubSection

@EndSubSections
@End @Section

@Section
    @Title { Timetable monitors }
    @Tag { monitoring_timetables }
@Begin
@LP
A @I { timetable } is a record of what is going on at each time.
As part of monitoring cost, KHE monitors the timetable of each
resource and each event.  Function
@ID @C {
KHE_TIMETABLE_MONITOR KheResourceTimetableMonitor(KHE_SOLN soln,
  KHE_RESOURCE r);
}
returns the timetable monitor of resource @C { r }, and
@ID @C {
KHE_TIMETABLE_MONITOR KheEventTimetableMonitor(KHE_SOLN soln,
  KHE_EVENT e);
}
returns the timetable monitor of event @C { e }.  Type
@C { KHE_TIMETABLE_MONITOR } is a subtype of type @C { KHE_MONITOR }
with tag @C { KHE_TIMETABLE_MONITOR_TAG }.  The cost of a timetable
monitor is always 0, so it never appears in any list of defects.
@PP
When a timetable monitor is attached, a particular set of meets is
known to it at any moment.  For a resource timetable monitor it is
the set of meets that are assigned a time and the resource.  For an
event timetable monitor it is the set of meets derived from the
event that are assigned a time.  The monitor offers these operations,
which report which meets are running at each time:
@ID { 0.98 1.0 } @Scale @C {
int KheTimetableMonitorTimeMeetCount(KHE_TIMETABLE_MONITOR tm,
  KHE_TIME time);
KHE_MEET KheTimetableMonitorTimeMeet(KHE_TIMETABLE_MONITOR tm,
  KHE_TIME time, int i);
}
@C { KheTimetableMonitorTimeMeetCount } returns the number of
known meets running at @C { time }, and
@C { KheTimetableMonitorTimeMeet } returns the @C { i }th of these
meets.  Closely related to them is
@ID @C {
bool KheTimetableMonitorTimeAvailable(KHE_TIMETABLE_MONITOR tm,
  KHE_MEET meet, KHE_TIME time);
}
which returns @C { true } if moving @C { meet } within @C { tm },
or adding it to @C { tm }, so that its starting time is @C { time },
would neither place @C { meet } partly off the end of the timetable
nor cause clashes.
@PP
A timetable monitor offers no operations which report its set of meets
directly.  For event timetables one can use functions @C { KheEventMeetCount }
and @C { KheEventMeet } from Section {@NumberOf solutions.objects} to
obtain the meets derived from a particular event; the timetabled meets
are just those with an assigned time.  For resource timetables one can
use @C { KheResourceAssignedTaskCount } and @C { KheResourceAssignedTask }
from Section {@NumberOf solutions.tasks.asst} to obtain all the tasks
assigned the resource; the timetabled ones are just those whose
enclosing meet has an assigned time.
@PP
The condition @C { KheTimetableMonitorTimeMeetCount(tm, time) >= 2 }
is true at each time when @C { tm } has a clash.  To find out quickly
which times these are, use
@ID {0.96 1.0} @Scale @C {
int KheTimetableMonitorClashingTimeCount(KHE_TIMETABLE_MONITOR tm);
KHE_TIME KheTimetableMonitorClashingTime(KHE_TIMETABLE_MONITOR tm, int i);
}
They return all times such that @C { tm } has a clash at that time,
not in chronological order.
@PP
As usual, timetable monitors are created by @C { KheSolnMake } and
exist for as long as the solution does.  There is one for each
resource, and one for each event.  Unlike other monitors, however,
timetable monitors are not attached initially.  It is possible for
the timetable returned by @C { KheResourceTimetableMonitor } or
@C { KheEventTimetableMonitor } to be unattached and so not up
to date (it will be empty in that case).  It can be brought up to
date by attaching it.
@PP
Link events monitors (but not spread events monitors) depend on
event timetable monitors.  All resource monitors except limit
workload monitors depend on resource timetable monitors.  When a
monitor is attached, any unattached timetable monitor(s) it depends
on are also attached.  When the last monitor that depends on some
timetable monitor is detached, that timetable monitor is detached.
Thus, unless the user chooses to attach a timetable monitor directly,
timetable monitors are attached only as needed by other monitors.
Detaching a timetable monitor causes KHE to abort unless no attached
monitors depend on it.
@PP
Although it would make sense to treat a timetable monitor as a
group monitor, that option is not offered.  The user who wants
all the problems associated with a single resource or event to
be channelled through a single monitor must create a group
monitor, separate from the timetable monitor, and add the
appropriate monitors to it in the usual way.
@PP
Timetable monitors may be debugged by calling @C { KheMonitorDebug }
as usual.  And
@ID @C {
void KheTimetableMonitorPrintTimetable(KHE_TIMETABLE_MONITOR tm,
  int cell_width, int indent, FILE *fp);
}
prints a conventional tabular timetable, using @C { Days } and
possibly @C { Weeks } time groups from the instance to determine
its shape.  Parameter @C { cell_width } is the width of each cell,
in characters.
@End @Section

@Section
    @Title { Time group monitors }
    @Tag { monitoring_timegroup }
@Begin
@LP
A @I { time group } monitor is a monitor associated with one
timetable monitor.  It monitors what is happening at the times
of its time group within the timetable; specifically, it keeps
track of how many of the times of the time group are busy in
that timetable (occupied by at least one meet).  It also keeps
track of how many idle times the time group contains, but only
if there is a limit idle times monitor in the vicinity that needs
to know.
@PP
Time group monitors are created and attached by KHE as required,
and it is best not to meddle with that.  However, there is no
problem with retrieving information from them:
@ID @C {
KHE_TIMETABLE_MONITOR KheTimeGroupMonitorTimetableMonitor(
  KHE_TIME_GROUP_MONITOR m);
KHE_TIME_GROUP KheTimeGroupMonitorTimeGroup(KHE_TIME_GROUP_MONITOR m);
int KheTimeGroupMonitorBusyCount(KHE_TIME_GROUP_MONITOR m);
}
These return @C { m }'s associated timetable monitor, the time group
that @C { m } monitors, and the number of busy times in that time group.
@PP
When a limit idle times monitor is attached which monitors
@C { tgm }'s time group within @C { tgm }'s timetable monitor,
two other functions related to idle times calculations may be
called:
@ID @C {
int KheTimeGroupMonitorIdleCount(KHE_TIME_GROUP_MONITOR m);
void KheTimeGroupMonitorFirstAndLastBusyTimes(
  KHE_TIME_GROUP_MONITOR tgm, KHE_TIME times[2], int *count);
}
The first returns the number of idle times.  The second places
the first and last busy times into @C { times }, and sets
@C { *count } to the number of times it placed there.  If
there are no busy times, @C { *count } is 0; if there is one
busy time, @C { *count } is 1; else @C { *count } is 2.  This
specification does not refer to idle times, but nevertheless the
function will abort if there is no limit idle times monitor nearby.
@End @Section

@Section
    @Title { Group monitors }
    @Tag { monitoring.group }
@Begin
@LP
Sometimes the cost of a @I single monitor is needed:  for example, when
reporting problems to the user.  And the total cost of @I all monitors
is always needed, since that is the cost of the solution.
@PP
Sometimes something in between these two extremes is needed:  the
cost of a set of related monitors.  To support this, the monitors
of a solution are organized into a directed acyclic graph, or
@I { dag } for short, of arbitrary depth.  Each monitor reports
its cost to its parent monitors.  The dag is often a tree, in
which case the picture looks like this:
@CD -1px @Break @Diag margin { 0.2c } {
||0.5rt RR:: @Box 2c @Wide 0.9c @High @I Soln
//0.6c
||0.5rt GMA:: @Box 2c @Wide 0.9c @High @I { Group @LLP monitor }
&4c     GMB:: @Box 2c @Wide 0.9c @High @I { Group @LLP monitor }
//0.6c
||0.5rt NGA:: @Box 2c @Wide 0.9c @High @I { Non-group monitor }
&2c     NGB:: @Box 2c @Wide 0.9c @High @I { Non-group monitor }
&2c     ...
&2c     NGC:: @Box 2c @Wide 0.9c @High @I { Non-group monitor }
//0.6c
||0.5rt SOLN:: @Box 14c @Wide 0.4c @High @I { Solution }
//
@Arrow from { GMA } to { RR }
@Arrow from { GMB } to { RR }
@Arrow from { NGA } to { GMA }
@Arrow from { NGB } to { GMA }
@Arrow from { NGC } to { GMB }
@Arrow from { SOLN@NW ++ { 0.5c 0 } } to { NGA }
@Arrow from { SOLN@NW ++ { 1.5c 0 } } to { NGA }
@Arrow from { SOLN@NW ++ { 2.5c 0 } } to { NGA }
@Arrow from { SOLN@NW ++ { 5.0c 0 } } to { NGB }
@Arrow from { SOLN@NW ++ { 6.0c 0 } } to { NGB }
@Arrow from { SOLN@NW ++ { 7.0c 0 } } to { NGB }
@Arrow from { SOLN@NE -- { 0.5c 0 } } to { NGC }
@Arrow from { SOLN@NE -- { 1.5c 0 } } to { NGC }
@Arrow from { SOLN@NE -- { 2.5c 0 } } to { NGC }
}
The leaves are the @I { non-group monitors }, the various monitors
described previously which monitor the solution directly.  The
internal nodes are called @I { group monitors }, because they
monitor a set of monitors (their children).  The cost of a group
monitor is the sum of the costs of its children.
@PP
The solution object itself is a group monitor (initially, the
only one).  It supports all the group monitor operations, plus
the many other operations described earlier.
@PP
Group monitors have type @C { KHE_GROUP_MONITOR }, a concrete subtype
of @C { KHE_MONITOR }, like @C { KHE_ASSIGN_TIME_MONITOR } etc.
@C { KHE_GROUP_MONITOR } is a supertype of @C { KHE_SOLN }, so upcast
@ID @C { (KHE_GROUP_MONITOR) soln }
is safe, although often unnecessary, since many operations on
type @C { KHE_GROUP_MONITOR } have @C { KHE_SOLN } versions.
For example, since @C { KHE_GROUP_MONITOR } is itself a subtype
of @C { KHE_MONITOR }, the total cost of all monitors could be
found by calling
@ID @C { KheMonitorCost((KHE_MONITOR) soln) }
but of course the equivalent @C { KHE_SOLN } version, @C { KheSolnCost },
is easier to use.
@PP
When the solution changes at some point, the change is reported to
the non-group monitors that monitor that point.  Each updates its
cost and reports any change to its parents, which update their
cost and report to their parents, and so on until there are no
parents.  The dag usually has a single root, the solution object
itself, but it does not have to be that way, because the links
that join non-group and group monitors to their parent monitors
can be added and deleted at will.
@BeginSubSections

@SubSection
    @Title { Basic operations on group monitors }
    @Tag { monitoring.group.basic }
@Begin
@LP
Unlike other types of monitors, group monitors other than the
solution object can be freely created and deleted.  Function
@ID @C {
KHE_GROUP_MONITOR KheGroupMonitorMake(KHE_SOLN soln, int sub_tag,
  char *sub_tag_label)
}
creates a new group monitor with no parents and no children.  It
is passed the solution as a parameter, and it remembers it, but
it is not made a child of it.  Functions
@ID @C {
int KheGroupMonitorSubTag(KHE_GROUP_MONITOR gm);
char *KheGroupMonitorSubTagLabel(KHE_GROUP_MONITOR gm);
}
return the @C { sub_tag } and @C { sub_tag_label } attributes of
@C { gm }.  These are used to distinguish kinds of group
monitors.   If @C { sub_tag_label } is non-@C { NULL }, it is
printed when debugging.  The values of these attributes in
solution objects are @C { -1 } and @C { "Soln" }.  The term
`sub-tag' is used because group monitors already have a tag
attribute, whose value is @C { KHE_GROUP_MONITOR_TAG }.
@PP
A group monitor other than the solution object may be deleted by calling
@ID @C {
void KheGroupMonitorDelete(KHE_GROUP_MONITOR gm);
}
Its children will no longer have it as a parent, and its parents will
no longer have it as a child.  For each parent of @C { gm }, the hole
in the parent's list of child monitors is plugged by moving the last
child monitor to @C { gm }'s position.  For each child of @C { gm },
the hole in the child's list of parent monitors is plugged by moving
the last parent monitor to @C { gm }'s position.
@PP
Every group monitor can have any number of child monitors, and
every monitor (group or non-group) can have any number of parent
monitors.  Even the solution object can have parents, allowing
monitoring of the total cost of a set of solutions.  The operations
for adding children to a group monitor and removing them are
@ID { 0.95 1.0 } @Scale @C {
void KheGroupMonitorAddChildMonitor(KHE_GROUP_MONITOR gm, KHE_MONITOR m);
void KheGroupMonitorDeleteChildMonitor(KHE_GROUP_MONITOR gm, KHE_MONITOR m);
}
Here @C { m } could be a non-group monitor or a group monitor.
@C { KheGroupMonitorAddChildMonitor } makes @C { m } a child of
@C { gm }, and @C { gm } a parent of @C { m }.  It aborts if this
would create a cycle in the dag (only possible when @C { m }
is a group monitor).  @C { KheGroupMonitorDeleteChildMonitor }
removes @C { m } from @C { gm }, leaving @C { m } with one less
parent and @C { gm } with one less child.  The resulting holes
are plugged as described above for deleting group monitors.  It
aborts if @C { m } is not a child of @C { gm }.  There is also
@ID {0.98 1.0} @Scale @C {
bool KheGroupMonitorHasChildMonitor(KHE_GROUP_MONITOR gm, KHE_MONITOR m);
}
which returns @C { true } when @C { m } is a child of @C { gm }.
It is useful when @C { m } may already be a child of @C { gm }:
@ID @C {
if( !KheGroupMonitorHasChildMonitor(gm, m) )
  KheGroupMonitorAddChildMonitor(gm, m);
}
No-one is checking that one monitor does not become the child of
another twice over; and if it does, its cost will be counted twice
in the cost of its parent.
@PP
For a group monitor @C { m }, @C { KheLowerBound(m) } is the sum of
the lower bounds of @C { m }'s children.  It may increase when a
descendant is added, and decrease when a descendant is removed.
@PP
Initially, all non-group monitors are made children of the
solution object, and all of them except demand monitors are
attached to the solution, so that @C { KheSolnCost } is the
total cost of all non-demand monitors, which is indeed the
cost of the solution.  Care is needed when grouping not to
inadvertently disconnect monitors from the solution, since
then their costs will not be counted, or to connect them via
multiple paths, since then their costs will be counted
multiple times.  It is usually best to make a new group monitor
a child of the solution immediately:
@ID @C {
gm = KheGroupMonitorMake(soln, sub_tag, sub_tag_label);
KheGroupMonitorAddChildMonitor((KHE_GROUP_MONITOR) soln,
  (KHE_MONITOR) gm);
}
And when deleting a group monitor, the best option may be
helper function
@ID @C {
void KheGroupMonitorBypassAndDelete(KHE_GROUP_MONITOR gm);
}
It calls @C { KheGroupMonitorDelete }, but first it makes @C { gm }'s
children into children of @C { gm }'s parents, if any, thus keeping
them linked in.  There is also
@ID @C {
void KheSolnBypassAndDeleteAllGroupMonitors(KHE_SOLN soln);
}
which applies @C { KheGroupMonitorBypassAndDelete } to every
group monitor of @C { soln }.
@PP
Functions
@ID @C {
int KheGroupMonitorChildMonitorCount(KHE_GROUP_MONITOR gm);
KHE_MONITOR KheGroupMonitorChildMonitor(KHE_GROUP_MONITOR gm, int i);
}
visit the child monitors of group monitor @C { gm } in the
usual way.  If @C { gm } is the solution object, these
versions of the functions allow the user to avoid the upcast:
@ID @C {
int KheSolnChildMonitorCount(KHE_SOLN soln);
KHE_MONITOR KheSolnChildMonitor(KHE_SOLN soln, int i);
}
Functions
@ID @C {
int KheMonitorParentMonitorCount(KHE_MONITOR m);
KHE_GROUP_MONITOR KheMonitorParentMonitor(KHE_MONITOR m, int i);
}
visit the parent monitors of @C { m }.  There is also
@ID @C {
bool KheMonitorDescendant(KHE_MONITOR m1, KHE_MONITOR m2);
}
which returns @C { true } if @C { m1 } is a descendant of @C { m2 },
including when the two are equal.
@End @SubSection

@SubSection
    @Title { Defects }
    @Tag { monitoring.group.defects }
@Begin
@LP
Informally, a defect is a specific problem with a solution.
In KHE, the word has a formal meaning as well:  a @I defect
is a monitor whose cost is non-zero.
@PP
It can be helpful to target defects directly, rather than wasting
time changing parts of the solution where there are no defects.
This is especially the case near the end of the solve process, when
there may be thousands of monitors but only a handful of defects.
To support this, KHE offers fast access to those child monitors of
a group monitor which are defects:
@ID @C {
int KheGroupMonitorDefectCount(KHE_GROUP_MONITOR gm);
KHE_MONITOR KheGroupMonitorDefect(KHE_GROUP_MONITOR gm, int i);
}
When a monitor's cost changes from zero to non-zero, the monitor
is added to its parents' defect lists; and when its cost changes
from non-zero to zero it is removed.  These updates take a
constant and negligible amount of time per parent.
# @PP
# The defects could appear in any order.  Function
# @ID @C {
# void KheGroupMonitorDefectSort(KHE_GROUP_MONITOR gm, bool diversify);
# }
# sorts the defects by decreasing cost, allowing the worst defects
# to be targeted first.  The order is @I not kept up to date as the
# solution changes and defects are added and removed.  If @C { diversify }
# is @C { true }, ties in cost are broken differently depending on the
# monitor's solution's diversifier.
# @PP
When the group monitor is the solution object there are convenience
versions:
@ID @C {
int KheSolnDefectCount(KHE_SOLN soln);
KHE_MONITOR KheSolnDefect(KHE_SOLN soln, int i);
}
# void KheSolnDefectSort(KHE_SOLN soln);
# void KheSolnDefectDiversifySort(KHE_SOLN soln);
There is also
@ID @C {
void KheGroupMonitorDefectDebug(KHE_GROUP_MONITOR gm,
  int verbosity, int indent, FILE *fp);
}
which is like @C { KheMonitorDebug } applied to @C { gm }, except
that it prints only the defective children.
@PP
If a solution is changed and then changed back again to its original
state, its cost returns to its original value, but there are two ways
in which its defects can be different.  First, they may appear in a
different order.  Second, although the number of defects which are
demand monitors (Chapter {@NumberOf matchings}) must return to its
original value, the demand monitors that make up that number may
change.  This is because there are many maximum matchings in general,
and KHE does not guarantee to find any particular one of them.
@PP
In practice, one wants to traverse a list of defects and try to
repair them.  Quite commonly, an attempt to repair a defect will
remove it temporarily and then reinstate it if the repair was not
successful.  This will cause the defect to be shifted to the end
of the defect list.  A simple traversal of the defects from first
to last will visit some defects more than once, and others not
at all.  To handle this problem, it is necessary to make a copy
of the defects and traverse the copy.  Although every defect
will have non-zero cost at the time it is copied, as the list
is traversed, after the solution changes or if the list includes
demand monitors, one cannot assume that every monitor on the copy
list will have non-zero cost.
# KHE offers functions
# @ID @C {
# void KheGroupMonitorCopyDefects(KHE_GROUP_MONITOR gm);
# int KheGroupMonitorDefectCopyCount(KHE_GROUP_MONITOR gm);
# KHE_MONITOR KheGroupMonitorDefectCopy(KHE_GROUP_MONITOR gm, int i);
# }
# plus convenience versions of them for solutions:
# @ID @C {
# void KheSolnCopyDefects(KHE_SOLN soln);
# int KheSolnDefectCopyCount(KHE_SOLN soln);
# KHE_MONITOR KheSolnDefectCopy(KHE_SOLN soln, int i);
# }
# The first function makes a private copy of the list of defects (it
# does not copy the monitors, just the list), and the second and third
# traverse this copied list.  This list does not change until the next
# call to @C { KheGroupMonitorCopyDefects(gm) }, so the problems with
# traversing a changing list are removed.  On the other hand, after the
# solution changes or if the list includes demand monitors, one cannot
# assume that every monitor on the copy list will have non-zero cost.
# @PP
# When a solution is copied, @C { KheGroupMonitorDefectCopyCount } will
# be 0 for every group monitor of the copy, whatever it was in the
# original.  It is not safe to copy a defect copy list, since it could
# contain group monitors which have been deleted since it was used.
@PP
To find the total cost of all monitors of a given type in
the descendants of @C { gm }, call
@ID @C {
KHE_COST KheGroupMonitorCostByType(KHE_GROUP_MONITOR gm,
  KHE_MONITOR_TAG tag, int *defect_count);
}
It returns the number of defects, in @C { *defect_count }, as well
as the cost.  It traverses the whole sub-dag of monitors of @C { gm }
(actually, just the defects), so it is slow:  it is intended for
reporting, not for solving.  It returns @C { 0 } when @C { tag }
is @C { KHE_GROUP_MONITOR_TAG }, because it attributes cost to
the monitors that originally generated it.  Version
@ID @C {
KHE_COST KheSolnCostByType(KHE_SOLN soln, KHE_MONITOR_TAG tag,
  int *defect_count);
}
may be called when the group monitor is the solution object.
The values returned by these functions are displayed in a
convenient tabular form by functions
@ID @C {
void KheGroupMonitorCostByTypeDebug(KHE_GROUP_MONITOR gm,
  int verbosity, int indent, FILE *fp);
void KheSolnCostByTypeDebug(KHE_SOLN soln,
  int verbosity, int indent, FILE *fp);
}
which print one line for each kind of monitor under
@C { gm } or @C { soln } for which there are defects.
@End @SubSection

@SubSection
    @Title { Tracing }
    @Tag { monitoring.group.tracing }
@Begin
@LP
Sometimes a solver needs to know which monitors have experienced
a change in cost recently.  Ejection chain solvers, for example,
need this information, and @I { monitor tracing } provides it.
@PP
Tracing involves objects of type @C { KHE_TRACE }.  To create one, call
@ID @C {
KHE_TRACE KheTraceMake(KHE_GROUP_MONITOR gm);
}
where @C { gm } is the group monitor to be traced.  The solution may
be traced by upcasting it:
@ID @C {
t = KheTraceMake((KHE_GROUP_MONITOR) soln);
}
The group monitor that a trace object is for can be found by calling
@ID @C {
KHE_GROUP_MONITOR KheTraceGroupMonitor(KHE_TRACE t);
}
To delete a trace object, call
@ID @C {
void KheTraceDelete(KHE_TRACE t);
}
This will call @C { KheTraceEnd(t) } below if needed.  KHE keeps a
free list of trace objects in the solution object, so many trace
objects can be created and deleted at virtually no cost.
@PP
Actual tracing is initiated and ended by calling
@ID @C {
void KheTraceBegin(KHE_TRACE t);
void KheTraceEnd(KHE_TRACE t);
}
These must be called in matching pairs.  @C { KheTraceBegin } removes
any information left over from any preceding trace, and attaches
@C { t } to its group monitor so that it can record what happens.
@C { KheTraceEnd } detaches @C { t } from its group monitor.
Different trace objects may be attached and detached quite
independently of each other, even when they have the same group monitor.
@PP
After the trace ends, the following functions may be called:
@ID @C {
KHE_COST KheTraceInitCost(KHE_TRACE t);
int KheTraceMonitorCount(KHE_TRACE t);
KHE_MONITOR KheTraceMonitor(KHE_TRACE t, int i);
KHE_COST KheTraceMonitorInitCost(KHE_TRACE t, int i);
}
@C { KheTraceInitCost } returns the initial cost of @C { t }'s group
monitor (at the time the trace began); @C { KheTraceMonitorCount }
returns the number of child monitors of @C { t }'s group monitor
whose cost changed during the trace; @C { KheTraceMonitor } returns
the @C { i }th of these child monitors; and
@C { KheTraceMonitorInitCost(t, i) } returns the initial cost of
@C { KheTraceMonitor(t, i) }.
@PP
These functions may be called during a trace as well as after
it, returning values as though the trace had just ended.  While it
is not an error to call @C { KheGroupMonitorAddChildMonitor } or
@C { KheGroupMonitorDeleteChildMonitor } while tracing the group
monitor concerned, it is not recommended.  A solution cannot be
copied while one of its group monitors is being traced.
@End @SubSection

@EndSubSections
@End @Section

@EndSections
@End @Chapter
